Dieses Werk steht unter der GFDL und CC Non Comercial

===Überschrift===

__Unterpunkt__

**Befehle**

\\ \\ Besondere Dateien

:(){:|:};: <-- dont trie this at home!



===root===
__root werden__

!! Auschließlich für die Administration des Systems!!

!! Vermeiden Sie grafische Anmeldung !!

UID = 0
GID = 0

**su -**  (alle ausser Ubuntu)
+ Starte im Terminal eine Subshell mit Rootrechten. 
+ - bedeuted dass die **Umgebungsvariablen** für root neu eingelesen werden sollen

!! Vergewissern sie sich dass su auf /bin/su zeigt !!
!! Anlegen eines Alias sinnvoll !!

**sudo -s** (Ubuntu)

+ Nach der Anmeldung sollte eine # statt eines $ erkennbar sein

\\ /etc/securetty \\ --> definierte Terminals an denen sich root anmelden darf

\\ /var/log/messages \\ --> loggt Erfolgereiche und Fehlgeschlagene Anmeldungen als root
			Aug 28 22:31:48 Dickkopf su: (to root) l1zard on /dev/pts/3 !! erfolgreich !!
			Aug 28 22:31:28 Dickkopf su: FAILED SU (to root) l1zard on /dev/pts/3 !! fehlgeschlagen !!

__Befehl als root/anderer Benutzer ausführen__

**sudo <Befehl>** 
+ Führt <Befehl> als root aus

**sudo -u <User> <Befehl>**
+Führt <Befehl> als <User> aus

Tipp:
alias getroot='/bin/su -'

===Shell===

__Arten der Shell__

Datei /etc/shells enthält alle validen Shells
#Bourne Artige Shells
sh --> bourne shell
bash --> bourne again shell
ksh --> Korn Shell
zsh --> z Shell (Sehr Stark konfigurierbare Shell)
#C Artige shell
csh --> C-Shell
ash --> Advanced Shell
tcsh --> Tenex C Shell

sash --> System Adminstrators Shell

!! Die Standardshell kann mit **chsh** von jedem Nutzer geändert werden **

**echo $0** --> zeigt den Typ der aktuell verwendete Shell oder Subshell an
	    --> in einem Shellscript verweist $0 auf Pfad und Namen des verwendeten Shellscripts

__Aufrufen der Shell__
+ interaktiv durch ein Terminal
- Standard bei Nichtgrafischen Anmeldungen
- gnome-terminal
- Xterm 
- konsole
- yakuake

+ Auslesen von Shellkommandos aus Dateien
- Shellscripte mit Schleifen, Bedingungen und definierbaren Datenstrukturen
--> Der auszuführende Benutzer sollte  das Scritp mindestens lesen +r und ausführbaren +x können


!! Benutzen Sie chown +rx <user> <Shelscript.sh> um die Rechte zu vergeben !!

- sourcen von Befehlsfuntionnen und aliassen 
--> z.B . ~/.bashrc oder source ~/.bashrc
--> einlesen von Befehlen und Variablen ohne eine Subshell zu starten
!! Kommandos in der zu sourcenden Datei müssen in PATH sein!!

__Shells und Subshells beenden__
+ für sog. Loginshells: logout oder exit
+ für Subshells immer exit

!! Eine LoginShell ist eine spezielle Form einer Subshell !!

===Befehle===

?? Eine Kette von Zeichen die duruch die Eingabetaste abgeschlossen 
wird. ??

?? Jede Zeichenkette wird durch Leerzeichen getrennt in Wörter zerlegt??

<Befehl>	<Parmeter zur Spezifizierung des Befehls>
<erstes Wort>  <alle weiteren Wörter>

!! \<Enter> Maskiert die bedeutung der Entertaste und man kann in der nächsten Zeile weiter Schreiben !!

__Parameter__
+ Option/Schalter: Parmeter beginnt mit - (Aspekte eines Befehls lassen sich an und ausschalten)
--> kurze Schalter: -a -f -g oder auch -afg
--> lange Schalter: --long --with-enabled aber __nicht__ --longwith-enabled 

+ Argumente: Parmeter beginnt ohne einleitendes "-" oder "--"
--> Meist Namen von Dateien und Verzeichnissen die mit dem Befehl bearbeitet oder verarbeitet werden sollen

KOMMANDO == Was wird gemacht
OPTIONEN == Wie wird es gemacht
ARGUMENTE == Womit wird es gemacht

__Shelltypen__
LoginShell: Die Shell die beim Login verwendet wird 
**bash -l** --> bash als Loginshell festlegen 
+ Die Aufrufe **su -, login, ssh** gibt der Shell als erstes ein ** - ** als Programmname mit, was sie zur login Shell macht    

Interaktive Shell: Shell reakiert auf Nutzereingaben und gibt Statusmeldungen zurück
+ einlesen der Shellspezifischen Konfigurationsdateien im Heimatverzeichnis des Benutzers, wie zum Beispiel \\ ~/.bashrc \\

Nichtinteraktive Shell: Ein Shellscript wird ohne Nutzerintervention ausgeführt **Shellscripte
+ Shellscript
+ Ein Programm bedient sich einer Shell um ein anderes zu starten
+ keine Verwendung von Aliasnamen

__Bash__
Reihenfolge in der nach .profile gesucht wird:
\\ /etc/porfile \\ --> \\ ~/.bash_profile \\ --> \\ ~/.bash_login \\ --> \\ ~/.profile \\

\\ ~/.profile \\ | \\ /etc/profile \\ --> Einstellungen für Nutzer | Global für die Loginshell 
				      --> festlegen von **umask** und Umgebungsvaribalen
				      --> festlefgen der Umgebungsvariablen und der Tastaturbelegung  	

\\ ~/.bashrc \\ | \\ /etc/bash.bashrc \\ --> Bashspezifische Konfigurationseinstellungen für Nutzer | Gloabal
					 --> setzen von Aliassen, Programmen die beim aufrufen der Shell ausgefürt 
					     werden soll z.B. kann man hier festlegen ob das Prgramm **fortune** 
					     jedes mal gestartet werden soll

\\ ~/.bash_logout \\ --> Befehle und Variablen die beim Abmelden aus bash ausgeführt werden soll, optional

__Buildins__
Befehle die von der Shell selbst zur Verfügung gestellt werden
Sie werden von der Shell ausgeführt.

__Externe ausführbare Programme__
Die Shell startet diese Programme durch aufrufen ihres Namens aus /(s)bin /usr/(s)bin

__Überprüfen ob ein Kommando ein Buildin oder ein ausführbares Programm ist__
**type <Bfehlsname> **
--> mögliche Ausgaben: is hashed, is Pfad/zu/bin, is a shell buildin

**man bashbuildins** --> manuelle bash befehle 

__Sonderzeichen__
Zeichen die für die Shell besonders interpretiert werden müssen durch \ maskiert werden
$&(){}[]*?!<>"';\

!! Um das maskierte Zeichen zu maskieren muss man es doppelt maskieren \\ !!
!! **touch 'neue datei'** oder **touch neue\ datei** erzeugen eine leere datei mit leerzeichen !!


__Maskieren__
**"Mein Text"** --> "" maskiert Leerzeichen und Steuerzeichen aber keine Sonderzeichen
**'Meine $TEXT'** --> '' maskiert Steuerzeichen und Sonderzeichen
**Mein\ Text** --> maskiert ein einzelnes Sonderzeichen oder Steuerzeichen
TIPP:
**mkdir "Verzeichnis 21" --> legt ein Verzeichnis mit dem Namen Verzeichnis 21 an


__Shell Variablen und die Umgebung__
+ Setzen einer Variable: FOO=bar
--> weist der Variablen FOO den Wert bar zu

+ Shellvaribalen: nur für die aktuelle Shell sichtbar
+ Umgebungsvariablen: werden beim Starten eines Befehls an den Kindprozess weitervererbt
		      steruen das Verhalten von einigen Programmen und bash im Besonderen	

+ Eine Umgebungsvariable deklarieren:
**export FOO=bar** --> deklariert die Variable FOO mit dem Wert bar und exportiert diese als Umgebungsvariable
**export FOO BAR VAR** exportiert die Variablen FOO BAR VAR zu Umgebungsvariablen

+ Umgebungsvariablen anzeigen:
**env**
**export**

+ Alle Shellvaribalen anzeigen:
**set**

!! Umgebungsvariablen sind auch Shellvaribalen aber nicht umgekehrt !!

__Ein Programm in einer veränderten Laufzeitumgebung starten__
**env <Optionen> <Befehl>** --> Ein Programm in einer Umgebung starten
-i --> starte mit einer leeren Shellumgebung, keine Umgebungsvariablen gesetzt
-u <VAR> --> entferne Variable temporär von Umgebung

__Unexportiren von Variablen__
**export -n VAR** --> unexportiert (negiert) die Variable VAR

__Löschen von Variablen__
**unset VAR** --> löscht eine Shellvariable und damit auch Umgebungsvariablen

__Anzeigen des Inhalts von Shellvariabeln__
**echo $<VAR>** --> stellt den Bezug zur Variablen <VAR> her. zum Beispiel USER=rootm,aber echo $USER

__Anzeigen des Aktuellen vrtuellen Devices auf welches das Terminal lauscht__
**tty** --> zeigt das /dev an auf dem das Terminal gerade lauscht

__Umgebungsvariablen in Bash__
BASH --> Pfad zur binärdatei der aktuell aufgerufenen Bash

BASH_SUBSHELL --> Indikator für die Subshelltiefe, 0 bedeute keine Subshells, 1 in der ersten Subshell usw.

BASHPID --> PID der aktuell aufgerufenen Bashshell

BASH_VERSION --> Version der aktuell aufgerufenen bash

DIRSTACK --> Der erste Wert des Verzeichnis Stack (siehe **dirs**, **pushd** **popd**)

EDITOR --> Der Standardeditor (vi, emacs,  pico, nano, ...)

EUID --> effektive UID

FUNCNAME --> Name der aktulle aufgerufenen Funktion
         --> funktion(){ echo $FUNCNAME; };funktion

GROUPS --> Gruppenzugehörigkeit des aktuellen Benutzers

HOME --> Heimatverzeichnis des aktuellen Benutzers

HOSTNAME --> Namen des Hostnamens des aktullen System

HOSTTYPE --> Identifiziert den Typ der Hardware auf dem die Bash asugeführt wird

IFS --> Internal Filed Seperaor (Interner Zeichentrenner, standartwert leer)
    --> echo "$IFS"|cat -vte

LINENO --> Verweist auf die aktulle Anzahl der Zeilen der bash im Shellscript auf die Zeile des Scripts

MACHTYPE --> Architekturtyp nach **GNU company system format**

OLDPWD --> letztes von bash aufgesuchtes Verzeichnis

OSTYPE --> Typ des Betriebsystems (OSTYPE)
       --> ~> echo $OSTYPE
       --> linux

PATH --> Pfade durch : getrennt in der die Shell nach ausführbaren Dateien sucht
     --> /usr/lib/mpi/gcc/openmpi/bin:/home/l1zard/bin:/usr/local/bin:/usr/bin:/bin:/usr/bin/X11:/usr/X11R6/bin:/usr/games:/usr/lib/jvm/jre/bin:/usr/lib/mit/bin:/usr/lib/mit/sbin

PIPESTATUS --> exit Status der letzten fg Pipe

PPID --> Prozess ID des Elternprozess der aktuellen Shell 
     --> In Subshell ist es die PID der abhängigen Elternshell
     --> Shellscripten PID der Shell in der Script aufgerufen wurde

PROMPT_COMMAND --> Ist diese Variable gesetzt, kann sie einen Befehl erhalten der vor dem anzeigen des Prompts PS1
angezeigt wird

PS1 --> Erstes Promptzeichen

PS2 --> Zweites Promptzeichen

PS3 --> Drittes Promptzeichen wird angezeigt wenn in einer *select* Schleife genutzt

PS4 --> Viertes Promptzeichen wird angezeigt wenn **set -x** verwendet wird

PWD --> Aktuelles Verzeichnis indem sich der aktuell Nutzer befindet

SECONDS --> Anzahl der Sekunden die das Script gelaufen ist

SHELLOPTS --> Optionen die für die aktulle Shell gesetzt sind

SHLVL --> gibt die tiefe der Verschachtelung der aktullen Shell an

UID --> UID des Nutzers der Shell/Shellscript ausführt


__Postions Paramter__
$0 --> Name der Shell/ des Shellscripts
$1 $2 --> ... Parameter die dem Script übergeben werden $1 ist der 1. Parameter usw ...
$#  --> Anzahl der übergebenen Argumente
$* --> Alle Positionsparamter als ein einziges Wort "$1 $2 $3 ..." 
$@ --> Alle Parmeter gesehen als ein Text, dabei wird jedes Argument einzeln interpretiert "$1" "$2" "$3" .." ....
$! --> PID des letzten Hintergrundjobs
$- --> Flags die dem Script durch set übergeben werden
$_ --> letztes Argument des vorherigen Befehls
$? --> Exit Status des letztes Befehls, der zuletzt aufgerufnene Funktion oder des letzten Befehls/Scripts
$$ --> PID des gerade ausgeführten Scripts| der gerade ausgeführten Shell

**shift** --> Postionsparameter nach links verschieben. Aus $2 wird $1 und so weiter.

__Aliasnamen für einen längeren Befehl vergeben__
**alias <Name>='<Befehl> <Optionen> <Argument>' --> <Name> als Alias für den <Befehl> setzen. Es können <Optionen>
						    <Argumente> und **Postionale Parameter** vergeben werden

**unalias <Name> --> entfernt einen bereits vergebenen Alias so dass <Name> neu gesetzt werden kann
-a --> alle vergebenen Aliasse von der Momentan Aktiven Shell entfernen

\\ /etc/bash.bash.rc \\ --> globale Aliasse festlegen
\\ /etc/.bashrc \\ --> vom Nutzer vergebenen Aliasse festlegen

__Optionen für die aktuellen Shell festlegen__
**set** --> Anzeigen der Shellvariablen und setzen von Optionen 
-x --> Debugging Modus für die Shell oder Scripte anschalten 
+x --> Debugging Modus für die Shell oder Script abschalten
-o <Option> --> Setzen einer Shell Option
+o <Option> --> Enttfernen einer Shell Option	
	emacs --> Emacs Mode der Shell
	vi   --> Vi Mode der Shell
	possix --> In den Possix Konformen Modus schalten
	noclobber --> verhindern dass berreits bestehende Dateien mit einer Ausgabeumlenkung überschrieben werden
	pipefail --> der Exitstatus der Pipe entspricht dem letzten Kommando dass zuletzt einen Exit Status >0 hatte
	notify --> sofort nach Beendigung des letzten Hintergrundjobs dessen Satus ausgeben
	noexec --> Befehle einlesen aber nicht ausführen, kann verwendet werden um Shellscripte nach Syntaxfehler ab-
		      zusuchen
	histexpand --> den Ausgeführten Befehl mitsamt seines Befehls in der History ablegen
	monitor --> Einschalten des Monitormodes mit Jobkontrolle
	xtrace --> dasselbe wie -x|+x	

__Warten bevor ein weiterer Befehl ausgeführt wird__
**sleep <n>** 
--> n Sekunden warten

__Argumente auf der Shell ausgeben__
**echo "Hello World"**
Hello World
$

**echo -n Hallo**
Hallo$ 
--> Ausgabe ohne Zeilentrenner

__Shell im Vi Modus__
**set -o vi**

__Shell im Emacs Modus (Standardverhalten)__
set -o emacs

__Befehl abbrechen__
**Strg+C**

__Eingabestrom beenden__
**Strg+D**

__Befehl stoppen__
**Strg+Z**

__Shellhistory__
**history** gibt die komplette Liste aller zuletzt einegbenen Befehle aus 
-c löschen der History
n beschränkt die history auf die letzen n Befehle

**down-key** --> zum letzten Befehl blättern
**up-key** --> zum vorherigen Befehl blättern

**Strg+R** --> Liste der zuletzt aufgerufenen Befehle inkrementell durchsuchen
	   --> mehrmaliges Drücken nach eingabe eines Suchmuster durchsucht die History nach allen
	       passenden Suchmustern	

**Strg+S** --> siehe **Strg+S** nur vorwärts
**Strg+G** --> durchsuchen der Shellhistory beenden

\\ ~/.bash_history \\

HISTFILE --> Umgebungvariable die auf die bash history Datei verweist
HISTSIZE --> Größe der gemerkten Befehle
HISTFILESZE --> Größe der bash history

~> !! 
--> den letzten Befehl wieder aufrufen

~> sudo !!
--> das gleiche als root

--> !n
--> das n-te Kommando wieder aufrufen

--> !-n
--> das letz-nte Kommando wieder hervorufen

-->!?<Muster>
--> der zuletzt aufgerufenen Befehl dass <Muster> entspricht

--> !n:$
--> das letzte Wort des n-ten Befehls (!-n:$ respektive)

-->!n:^
--> das erste Wort des n-ten Befehls (!-n:^ respektive)

!n:a-b
--> die Wörte a bis b des n-ten Befehls (!-n:a-b respektive)

!n:a*
--> alle Wörter ab dem a-ten des n-ten Befehls (!-n:a* respektive)

^<StringA>^<StringB>
--> ersetze im letztn Befehl <StringA> durch <StringB> und wiederhole es

Sinnvolle Kombinationen sind möglich

__löschen in Bash__
**Strg+w** --> lösche Wort von rechts nach links

**Strg+d** --> lösche ein Zeichen von links nach rechts

**Strg+u** --> lösche alles von rechts nach links

**Strg+k** --> lösche alles von links nach rechts

__Die beiden Zeichen vor/unter dem Cursor tauschen__
**Strg+t**

__Die beiden Wörter vor/unter dem Cursor tauschen__
**Alt+t**

__Zeichen in Groß/Kleinschreibung umwandeln__
**Alt+u** | **Alt-l** --> ein ganzes Wort in Groß / Kleinbuchstaben umwandeln

**Alt+c** --> ein einzelnese Zeichen in Groß / Kleinbuchstaben umwandeln jenachdem ob es vorher Klein/Groß war

__Einen Editor starten__
**Srg-X Str-E** --> Starten des Editor der in EDITOR oder VISUAL definiert wurde


__Den Bildschirm löschen__
**clear**
**Str+l**

__Befehl abbrechen__
**Strg+c**

__Eingabe beenden/Dateneingabestrom beenden__
**Strg+d**

__hashing__
+ Abspeichern von bereits aufgrerufenen Programmen in einem Cache
**hash -r** --> löschen der gehashten Funktionen

__Der Subshell einen Befehl übergeben__
**bash -c <Befehl>**

__Mehrere Kommandos__
**<Command1>;<Command2>;...** --> Befehle werden Seqeuntiell ausgeführt

**<Command1> && <Command2> --> <Command2> wird nur ausgeführt wenn der \\ exit Status \\ 
von <Command1> den Wert 0 hatte (logisches Und)

**<Command1> || <Command2> --> <Command2> wird nur ausgeführt wenn der \\ exit Status \\
von <Command1> einen Wert ungleich 0 hatte (logisches Oder)

__Shell auswechseln__
--> Dabei wird keine Subshell gestartet
**exec <Shell>**

__Fordergrund/Hintergrund Prozess verwalten__
--> ohne Angabe von & werden Befehele immer im Vordergrund der aktullen Shell geführt

**Str+z** --> stoppt den aktuellen Prozess (Status stopped)

**jobs** --> zeigt alle Jobs mit laufender Jobnummer und PID
-p --> listet nur die PID
-l --> listet PID und Jobnummer

**kill %n** --> Sendet SIGTERM 15 an den Job mit der Jobnummer n

**bg %n** --> Stellt den Prozess mit der Jobnummer n in den Hintergrund

**fg %n** --> Stellt den Prozess mit der Jobnummer n wieder in den Vordergrund

===Hilfe erhalten===
**<Befehl> -h/ --help** Option --> Hilfe für ShellBuildins und die meisten Befehle und Programme
**help <Buildin>** --> Hilfe für ShellBuildins (ausführlich)

__man Pages verwenden__
--> In der Regel zu dem Programm zugehörig
--> bei opensuse ab 11.2 wird manpages als extra Paket angeboten
**man <n> <Befehl> --> ruft den n-te Handbuchseite zum <Befehl> auf
**man -a <Befehl> --> zeigt alle Handbuchstein von <Befehl> nacheinander an
**man -l <Mandatei>** --> <Mandatei> lesen die nicht der Datenbank steht

TRICK: ./configure --prefix=~/test && make && make install 
nun kann man unter ~/test/usr/share/man/manX die man-Datei mittelse **man -l manX** lesen 


MANPATH --> Umgebungsvariale die den Pfad zu den Manual Pages angibt
**manpath** --> Programm zum Konfigurieren der Manpaths falls MANPATH nicht gestzet wurde

**groff* --> Programm das zum Betrachten von Manpages verwendet wird
         --> 
__Aufabau einer man Page__
NAME Kommandoname mit knapper kurzbeschreibung

SYNOPSIS Beschreinbung der Befehlssyntax

DESCRIPTION Ausführliche Beschreibung der Kommandowirkung

OPTIONS Auflistung und Beschreibung der zur Verfügung stehenden Optionen

ARGUMNETS Die möglichen Argumente

FILES Benötigte bzw.bearbeitet Dateien

EXAMPLES Beispiele zur Anwendung

SEE ALSO Querverweise auf verwandte Themen

DIAGNOSTICS Fehlermeldungen des Kommandos

COPYRIGHT Autoren des Kommandos

BUGS Fehler die aus dem Ansatz des Kommandos folgen

fetter text        	Literale Angaben wie in der Anzeige.
       kursiver text    Ersetzen durch passendes Argument.
       [-abc]           Ein oder mehrere Argumente innerhalb der [ ] sind optional.
       -a|-b            Optionen, die durch | abgegrenzt sind, können nicht zusammen benutzt werden.
       Argument ...     Argument kann wiederholt werden.
       [Ausdruck] ...   gesamter Ausdruck innerhalb [ ] kann wiederholt werden.

__Themengebiete der man Pages__
--> Jede Manual Page ist in Themenabschintte 1 bis 9 und n unterteilt
--> Manual Pages können in merheren Themengebiete unterteilt sein
**man <n> Befehl>**

1 Benutzerkommandos die jeder Nutzer ausführen darf

2 Systemcalls die an den Kernel geschickt werden können

3 Funktionen der Programmiersprache C

4 Gerätedateien und Treiber

5 Konfigurationsdateien und Dateiformate (z.B crontab)

6 Spiele

7 Makros und Konventionen (z.B groff, ASCII)

8 Kommandos die nur von root Benutzt werden sollen (z.B useradd)

9 Funktionen des Kernel

n neue Befehle

__Navigieren in Manpages__
--> **less* wird als Pager für man Standardmäßig verwendet
Rückwärsts suchen: /
Vorwärts suchen: ?
Beenden: q

<SPACE> --> eine Seite vorblättern
<Alt+v> --> eine Seite zurückblättern
<gg> --> Zum Beginn des Textes springen
<g<N>> --> zur Zeile N springen
<GG> --> zum Ende des Textes springen
<q> --> das Programm verlassen
<h> --> eine kurze Hilfe für less erhalten

--> in dolphin/konqueror man:/<Name>

__Manpages nach Namen durchsuchen__
**whatis <Stichwort>**

__Manpages nach DESCRIPTION durchsuchen__
**apropos <Stichwort>**
**man -k <Stichwort>**

__Info Seiten__
--> alle Befehle die in Coreutils Paket enthalten sind bieten eine ausführlicherer info Page
**info <Befehl>**

__Howtos__
www.tldp.com
\\ /usr/share/doc/HOWTO \\

===Vi(m)===
**view <File> --> Datei im readonly mode
**vi**
-r recover <File> --> Datein nach einem Absturz wiederherstellen
-t <Marke> <File> --> Starte Bearbeitung ab <Marke> falls vorhanden
+          <File> --> Öffne an der letzen Zeile
+n         <File> --> Öffne Datei an Zeile n
+"se nu"   <File> --> Öffne Datei mit Zeilennummerierung
+"<Kommandobefehle>" <File> --> öffne vi und fürhe dabei anschließend die <Kommandobefehle> aus

__Konfigurationsdatein__
\\ ~/.vimrc \\

__Kommando-Modus__
--> Jede Taste stellt einen Befehl oder eine Folge von Befelen dar 
--> Wechsel mit **Esc**

__Syntaxhighlighting einschalten__
:syntax on

__Eingabe/Einfüge-Modus__
--> Alle Eingaben werden als Text verstanden
--> Wechsel mit **i** (insert), **a** (append), **o**, **O**, **A**

__Kommandozeilenmodus__
--> vom Kommandomodus durch **:** gewechselt
--> Eingabe von Befehlen

__Befehle__
j,k runter,hoch navigieren

l,h rechts,links navigieren

:q Beenden ohne speichern

:w Speichern

:q Beenden ohne speichern

:w Speichern

:q! Beenden und Änderungen verwerfen

:wq Speichern und beeenden

<n>x löschen von n Zeichen

i Text einügen 

a Text anfügen

A Text am Ende der Zeile konvertieren

R Text ersetzen

r <NeuZeichen> ein Zeinen durch <NeuZeichen> ersetzen

e Zum Ende des nächsten Wortes springen

w zum Anfang des nächsten Wortes srpingen

0 zum Anfang der Zeile springen

$ Zum Ende der Zeile springen

dd Eine Zeile löschen

<Bewegung><n>d löschen von n Zeichen Bewegungen

u mache die Vorherige Aktion rückkängig (undo)

U mache alle Aktionen rückgängig (all undo)

Str+r mache die Rückgängigmachung rückgängig

p den kopierten/oder gelöschten Text kopieren

v den Text "visuell" hervorgehoben markieren

c Änderungen druchführen

ce Änderungen bis zum Ende eines Wortes durchführen

c <n> <Bewegung> Änderungen n Bewgungen durchführen

G  zum Ende der Datei springen

gg zum Anfang einer Datei springen

Strg+g Die Aktulle Zeile und den Status der Datei anzeigen

<n>G zur Zeile n Springen 

/<Ausdruck> nach <Ausdruck> suchen

% Eine korrspondierende Klammrer finden

:s/alt/neu <Enter> einmal alt durch Wort neu in der Zeile ersetzen

:s/alt/neu/g alle Wörter alt durch neu in der Zeile ersetzen

:%s/alt/neu/gc alle Wörte alt durch neu in der gsamten Datei ersetzen und vorher um Bestätigung fragen

:!<Befehl> führt <Befehl> aus ohne vim zu verlassen

v <Bewegung> :w <Dateiname> den durch <Bewegung> markierten Text in Datei <Dateiname> speichern

:help <Thema> Hilfe zu einem Vim Thema anzeigen

__Set__
:set number --> nummerierung einschalten
: syntax on --> Syntaxhighlighting einschalten

===Emacs===
Control-Taste <Strg> vorkonfiguriert C
Meta-Taste <Esc> und <Alt> vorkonfiguriert M

__Statuszeile__
--> Unten links durch eine Kette von Zeichen dargestellt

-:--- Seit dem letzen Speichern unverändert

-:**- Inhalt geändet aber noch nicht gespeichert

-:%%- Inhalt der Datei nur lesbar

\  Am ende der Zeile Zeile geht in der nächsten graphischen Zeile weiter beide Zeile sind eigentlich eine

__Beenden von Emacs__
C-x C-c

C-z Zeitweise verlasen (Emacs got stopped)

__Hilfe in Emacs__
C-h r Emacs Manual

C-h t Emacs Tutorial

C-h m Hilfe zum aktuellen Modus

__Dateien ladan und speichern__
C-x C-s Speichern des aktullen Puffer

C-x s Speichern aller ungespeicherten Puffer

C-x C-w Speichern des aktuellen Puffers in eine andere Datei

C-x C-f Finden (laden) einer Datei

__Befele zum Blättern__
C-v Eine Bildschimseite vorblättern

M-v Eine Bildschirmseite zurückblättern

C-l Lade Inhalt des Bildschirms neu und stell aktullen Text in die Mitte

C-p Eine Zeile zurückblättern

C-n Eine Zeile vorblättern

C-b Ein Zeichen zurückblättern

C-f Ein Zeichen vorblättern

M-b Ein Wort zurückblättern

M-f Ein Wort vorblättern

C-a Zum Anfange der Zeile springen

C-e zum Ende des Zeile springen

M-a zum Anfang des Satzes springen

M-e zum Ende des Satzes springen

M-< zum Anfnag einer Datei springen

M-> zum Ende einer Datei springen

__Markierungen setzen__
C-<Space> oder C-@ Markierung an der aktullen Stelle setzen

C-u C-<Space> zur gesetzen Markierun zurückkehren (erneutes aufrufen kehrt zur Vorletzten zurück usw.)

__Bewegungszähler__
--> Dient dazu Bewegungschritte vor einer Aktion zu definieren
C-u <Aktion>
C-u 8 * --> schreibt 8 mal das Zeichen *

__Einnen Emacs-Befehl anhalten__
C-g

__löschen__
<delete> löschen eines Zeichens (<entf>, <backspace>)

M-<delete> löschen bis vor Wortanfang

M-d löschen bis zum Wortende

C-k löschen von Curorpostion bis zum Ende der Zeile

M-k löschen bis zum Satzende

C-<Space> C-w markieren und löschen

__einfügen__
C-y gelöschten Text einfügen

__undo__
C-x u die letzte Aktion rückgängig
C-_ die letzte Aktion rückgängig

__Fesnter in Emacs__
C-x 1 Zum normalen Fenster zurückkehren. Schließt ein versehentlich geöffnetes Fenster

C-x C-b anzeigen aller Puffer

C-X b <File> rückkehr zu Puffer <File>

__Textteile ersetzen__
M-x replace-string <Ausdruck1> <Enter> <Ausdruck2> --> Ausdruck1 wird duruch Ausdruck2 ersetzt

__Modes-Wechseln__
M-x <mode>-mode
 c-mode 
 perl-Mode
 text-mode
 fundamental-mode

__Suchen__
C-s Vorwärts i-search

C-r Rückwärts i-search

===Dateien verwalten===
!! Linux ist Case Sensetive !!

!! Dateien müssen nicht durch Endungen markiert sein wie zum Beispiel .txt oder .jpg !!

__Versteckte Dateien erstellen__
.<dateiname> --> .<dateiname> ist nicht sichtbar mit **ls**

__Absolute und relative Pfadnamen__
relativ --> relativ zum aktuellen Verzeichnis (Pfadangabe satrtet mit dem aktullen Verzeichnis oder $PWD)

absolut --> relativ zum gesamten Verzeichnisbaum (Pfadangabe started mit dem / Symbol)

.. --> bezieht sich auf das Elternverzeichnis

. --> bezieht sich auf das aktulle Verzeichnis selbst

__Durch Verzeichnisse bewegen__
**cd <DIR>** --> gehe zu <DIR>
cd .. --> gehe in das Elternverzeichnis
cd - gehe in das zuletzt aufgerufene Verzeichnis

cd -- gehe in das vorvorherige Verzeichnis

**pwd** Print Working Directory den aktullen Pfad ausgeben

__Der Verzeichnis Stack__
**pushd <DIR>** --> lege <DIR> auf den Verzeichnisstabel und wechsle in <DIR>
+N --> lege das N-te von l nach r Verzeichnis im Stack nach oben und rotiere
-N --> lege das N-te von r nach l Verezichnis im Stack nach oben und rotiere
-n <DIR> --> lege <DIR> unter das erste Verzeichnis im Stack ohne zu wechseln

**dirs** --> zeige den momentanen Verzeichnisstabel
-v Zeige den Verzeichnisstabel nummeriert beginnet bei 0

**popd <DIR>** --> entferne <DIR> vom Verzeichnisstabel
+N --> entferne N-te von l nach r Verzeichnis im Stack und rotiere
-N --> entferne das N-te von r nach l Verzeichnis im Stack und rotiere
-n <DIR> --> entferne <DIR> aus dem Verzeichnis ohne zu rotiren

<Aktion> ~+<N> --> Führe <Aktion> auf dem Stack im Verzeichnis N aus 
--> beispiel: mv testfile ~+2

__Verezeichnisse und Dateien listen__
**ls** --> listet alle (außer versteckte) Dateien im aktuellen Verzeichnis auf
-a Alle auch versteckte
-l detailiert
rwxrwxrwx+ N <user> <group> <Dateigröße in Bytes> <letzte Änderung> <Name der Datei>
-i zeige informationen zu i-nodes
-s zeige Informationen über die Größe der Dateien
-R zeige Rekursiv, -R1 zeigt rekursiv eine zeile pro eintrag
-F zeige Informationen über den Typ an 
	* ausführbar chmod +x
	/ verzeichnis mkdir
	@ link ln -s
	| FIFO mkfifo
	= Unix Domain Socket
-p Zeige verzeichnisse durch / gekennzeichnet
-h Größenangaben in lesbarer Form MB GB usw anstelle von Blöcken ausgeben
-t sortiert nach Erstellungszeit
-S sortiert nach Größe
-X  sortiert nach Dateityp
-d <DIR> zeige nur Informationen über das Verzeichnis <DIR> nicht seinen Inhalt
!!Merke ls -lisah !!

__Verezichnisse anlegen und löschen__
**mkdir <DIR>** --> das verzeichnis <DIR> anlegen
-p --> erstelle auch Elternverzeichnis falls diese noch nicht existieren

**rmdir <DIR> --> das leere Verezichnis <DIR> löschen
-p --> lösche auch leere Ahnenverzeichnisse
!! rmdir löscht nur leere Verzeichnisse. Verzeichnisse mit inhalt müssen mit
rm -r <DIR> gelöscht werden !!

**mktemp <Datei>XXXXX** --> erstellt eine tempräre Datei oder ein Verzeichnis in /tmp mit zufälligen Namen
			--> wobei die X eine Zufallsschablone ist
-d --> Ein Verzeichnis erstellen
-q --> Quite
-u --> dry run nichts tun nur simmulieren
-t --> erstellt das Verzeichnis welches durch die Umgebungsvariable $TMPDIR festgelegt wurde

__Wildcards__
* eine belibige Folge von Zeichen

? ein einzeilnes Zeichens

[abc] eines der Zeichen a, b oder c

[!abc] alle Zeichen außer a, b oder c

{rot,gelb,blau}.txt die Wörter rot.txt, gelb.txt und blau.txt

Bsp: rm *.rpm -->löscht alle Dateien die auf .rpm enden
     rm  ?.ax --> löscht zum beispiel die Dateien die auf a.ax bax c.ax aber nicht ca.ax
     rm [abc].deb --> löscht a.deb, b.deb oder c.deb aber nicht d.deb oder cd.deb	
     mkdir -p /etc/init.d/{rc1.d,rc2.d,rc3.d,rc4.d,rc5.d}	

__kopieren von Dateien und Verzeichnisse__
**cp <Quelle> <Ziel>* --> kopiert Quelle nach Ziel, wenn Ziel bereits exitsiert wird Ziel überschrieben 
-r -R --> rekursives kopieren. Einen Ordner mit mehreren Dateien kopieren. 
-i --> existiert <Ziel> bereits, frage nach ob es überschrieben werden soll
-b --> lege von existierenden Dateien eine Sicherheitskopie <Ziel> an 
-p --> Dateiattribute der Quelldatei bleiben erhalten
-u --> kopiert nur wenn <Quelle>  neuer als <Ziel> ist
-d --> kopiert symblosche links aber nicht das Ziel auf das diese verweisen
-H --> wenn <Quelle> symbolische Links enthält kopiere stattdessen das Ziel auf das diese verweisen
-v --> verbose
-a --> kurzform für -drp <zum reddundanten Speichern von Daten>

__Synchronisieren von Dateien__
**rsync <Quelle> <Ziel>** --> zwischen Quelle und Ziel synchroniserien 
-A --> erhalte ACLs
-r --> rekursiv
-t --> erhalte time modfication Stamps
-p --> erhalte Rechte
-o --> erhalte Besitzer 
-g --> erhalte Gruppe
-v --> verbose 
--progress --> zeige den Fortschritt an
--exclude=<PATTERN> --> Dateien diesem <PATTERN> matchen werden nicht gesyncht
-h --> rechne in für Menschen lesbare Form um
--delete --> Falls Datei beim letzten synchronisieren in <Quell> gelöscht wurde, lösche sie auch in <Ziel>
-c --> berechne keine Prüfsumme beim synchronisieren. (sinnvoll bei vermehrt großen Datein > 1 GB)
-l --> kopiere symbolische Links als Links 
-s --> no space-splitting

Trick: 
folgende crontab macht täglich um 23:19 ein Backup nach /mnt/Backup und sendet eine mail an den User l1zard auf dem
Rechner Alucard:
19 23 * * * /usr/bin/rsync -r -t- -p -o -g -v --progress -h --delete -c -l -s /home/l1zard /mnt/Backup|mail -s "daily backup job with rsync finished" l1zard || mail -s "daily backup with rsync failed" l1zard


__verschieben und umbenennen von Dateien__
**mv <Quelle> <Ziel>** --> verschieben von <Quelle> nach <Ziel>  
                      --> befinden sich Qulle und Ziel innerhalt des gleichen Verzeichnisses wird die Quelle umebnannt in 
                      den Zielnamen 

__Diff und Merge von Dateibäumen__
**diff <Optionenn> <Dateien>** --> Dateien Zeilenweise vergleichen
-r --> rekurisv durch Dateibäume durch
-N --> nicht vorhandene Dateien im Ziel als leer behandeln
-q --> es wird nur ausgegben ob Dateien von einander verschieden sind
-a --> alles auch binäre Dateien als Text behandeln
-u --> im Unified für gnu **patch** lesbaren und anwendbarem Format ausgeben

__löschen__
**rm <Datei>** --> löscht <Datei>
-r --> löscht rekursiv auch Verzeichnisse und Unterverzeichnisse
-f --> force 
-i --> fragt vorher nach
-v --> verbose
!! alias rm='rm -i' für root!!
!!ACHTUNG: rm -rf /* !!

__links erstellen__
**ln -s <Quelle> <Ziel> --> sybolische Verknüpfung von <Quelle auf <Ziel> erstellen
!! Symbolische links erstellen eine Datei mit den Verweis auf eine andere Datei, über Dateisystemgrenzen hinweg !!
!! löschen von Quelle zerstört Ziel !!

**ln* <Quelle> <Ziel> --> harte Verknüpfung von <Quelle> nach <Ziel> erstellen
!! Eine Datei verweist auf den gleichen i-node !! 
!! löschen von Quelle lässt Ziel intakt !!

__Pager more__
z --> nächste Seite anzeigen
b --> vorherige Seite anzeigen
v --> editor vi aufrufen
/ --> rückwärts suchen
<Strg>-l --> zeichnet Bildschirm auf
<Enter> --> nächste Zeile anzeigen
! <Kommando> --> Kommando in Subshell asuführen


__Pager less__
<down> e j <Enter> --> nächste Zeile anzeigen
f z --> nächste Seite anzeigen
<up> y k --> vorherige Zeile anzeigen
b --> zeigt vorherige Seite an
g --> zum Anfang springen
G --> zum Ende springen
? / --> Vorwärts|rückwärts suchen
N n --> Suche Vorwärts| rückwärts fortzen
! <Kommando> --> Kommando in Subshell
v --> ruft vi auf
r <Strg-l> --> zeichnet Bildschirm neu

**zless** --> mit gzip komprimierte Dateien in less ansschauen 
	  --> ist die Datei nicht komprimiert wird less aufgerufen


**strings** --> Anzeigen der lesebaren ASCII Zeichen einer Binärdatei
-f --> Den Dateinamen vor jede Zeile schreiben
-n N --> nur Zeilen anzeigen die mindestens N Zeichen lang sind
-e s| S| b| l| B| L --> die Art der Encodierung festlegen
	s 	single 7 Bit Zeichen
	S	single 8 Bit Zeichen
	b	16 bit bigendian
	l	16 bit littleendian
	B	32 bit bigendian
	L	32 bit littleendian
@<Datei> --> Kommandozeilenoptioen werden von der Datei eingelesen

__Dateien finden__
*find* <PFAD> <Optionen> --> sucht in Pfad mit den entsprechenden Dateien
-name <Name> nach den passenden Dateinamen <Name> suchen. Regexp und globbing ist erlaubt
-type <b|c|d|f|l|p|s> nach den Typen b=blockorientiertes Gerät
                                     c=zeichenorientiertes Gerät
                                     d=Verzeichnis
			             f=normale Datei
                                     l=symbolischer link
                                     p=FIFO finden
                                     s=Unix Domain Socket

-user <User> nach Dateien suchen die <User> gehören
-group <Group> nach Dateien suchen die <Group> gehören

-size +|-<b|c|k|M|G> suche nach Dateien mindestens so groß wie|kleiner als in 512-bytes blocks|bites|kilobites|
megabites|gigabites

-atime|-amin Zugriffszeit in Tagen|Minuten 
-mtime|-mmin  Änderungszeit in Tagen|Minuten
-ctime -cmin letzte Änderung in Tagen|Minuten auf inode-basis

-links Suche nach Dateien, deren Refernezzähler den angegebenen Zahlenwert hat

-inum finde verweise auf die Datei mit der entprechenden Inode-Nummer

-a logisches und

-o logishces oder

! Nicht

Tricks:
find . -name 'my*' -type f -ls
--> alle regulären Dateien die mit my  beginnen und gibt die "extendet file information" aus

find / -path /proc -prune -o -path /sys -prune -o -type f -name myfile -print
--> finde die Datei myfile in / und suche dabei nicht in /proc und nicht in /sys

find /home/ -iname "*.mp3" -type f -exec chmod 444 {} \;
--> alle Datei mp3 und MP3 werden auf nur lesbar gesetzt

find /home/peters -type f -print0|xargs -0 tar cfz peters.tar.gz
--> alle dateien in peters's heimatverzeichnis in ein tar.gz packen

find ${*-.} -type f |xargs file|awk -F, '{print $1}'|awk '{$1=NULL;print $0}'|sort|uniq -c|sort -n
--> liste alle verzeichnisse und Dateien nach der Anzahl des vorhandenen Typs im aktullen Verzeichnis

find . -type d -empty -print0|xargs -0 rmdir
find . -type d -empty -ok rmdir {} \;
--> lösche und finde leere verzeichnisse
-o 
find . -type d |sed -e "s/[^-][^\/]*\// |/g" -e "s/|\([^ ]\)/|-\1/" 
--> stelle die Verzeichnisstruktur als Baum dar

find . -name "*.php3" | sed 's/\(.*\).php3$/mv "&" "\1.php"/'|sh
--> finde und ersetze .php3 files in .php files

for f in $(find * -type f); do echo "dos2unix $f $f";done|sh
--> konvertiere alle Dateien vom Dos Style in den Unix Style

IFS=' ; for i in $(find . -type f -print); do sha256sum "$i"; done
--> Checksummen über alle Verzeichnisse berechnen die unter . befinden

find . -type d |xargs du -ms |sort -g
--> finde das Verzeichnis das den meisten Platz auf der aktuellen Platte verbracht

for f in $(find / -type l -printf "%p \n"); do test -h "$f" && test -e "$f" || echo ""$f" broken";done

find / -type l -print0|xargs -0 ls -L1|grep "nicht möglich"
find / -type l -exec ls -L {} \;|grep "nicht möglich"
--> finde defekte symbolische links 

!! find eignet sich gut, wenn man viele Dateien auf einmal mit einem befehl bearbeiten will !!
!! Seine Ausgabe lassen sich gut mittels sed und awk weiter verarbeiten !!


**Dateien lokaliesieren**
**updatedb** --> aktualisieren der locate datenbank kann nur von root ausgeführt werden

**locate <Datei>** --> findet alle vorkommen mit dem namen <Datei> die in der lokalen Datenbank vorkommen

**slocate <Datei> --> slocate secure locate ist eine neue implemntation von locate muss bei suse aus den quellen installiert
werden, berücksichtigt auch dateiberechtigungen d.h. es werden nur dateien angezeigt die der nutzer auch sehen darf 


**slocate -u** dasselbe wie updatedb
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Scriptvorschlag linken nach updatedb um Abhängikeiten zu befriedigen:
#!/bin/bash

slocate_updateddb()
{
SLOCATE=$(which slocate || echo "no")
if ["$SLOCATE" != "no" ]
	then
		$SLOCATE -u
	else
		echo "slocate not found or script broken"
fi
}

if [ "$UID" == "0" ]
	then
		slocate_updatedb
	else
		echo "must be root"
		exit 1
fi
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

**which <Datei>** --> suche nach Dateien in $PATH

**whereis <Datei>** --> findet Dateien, Verzeichniss, Manpages, Quelldateien  zu <Datei>
-b --> finde nur binäre dateien
-s --> finde nur Quelldateien
-m --> finde nur Manpages


===Dateien mit doodle Indzieren und finden===
libdoodel doodle installieren

__Dateien indzieren__
**doodle -bfV $HOME/Ebooks/ /usr/share/doc -P $HOME/NICHT_INDIZIEREN/ -B=DE -B=EN**
--> indiziere die Verzeichnisse (-b) $HOME/Ebooks /usr/share/doc aber nicht $HOME/NICHT_INDIZIEREN (-P) und berücksichtige
auch Dateinamen (-f). Sei dabei verbose (-V), nutze die Sprachen Deustch (-B=DE) und Englisch -B=(EN)

\\ export DOODLE_PATH=$HOME/.doodle/index \\ --> Indexdatei von doodle

__Dateien finden__
**doodle -i --database=$HOME/.doodle/index <Begriff>** durchsucht den nach <Begriff> und benutzt dabei die Datenbank 
(--database) $HOME/.doodle/index als referenz (nur notwendig wenn DOODLE_PATH nicht gesetzt) und ignoriert 
Groß/kleinschreibung (-i)

-e --> extrahiere das exakte Schlüsselwort (verlangsamt das Programm deutlich)

Tipp: **alias fdoodle='doodle -i --database=$HOME/.doodle/index'**

**catfish** --> grafisches frontend für doodle**
**pydoodle** --> python frontend in development frag matthias ;)

Tipp aktuallieren des doodel index um 3 Uhr nachts Montag bis Freitag:
0 3 * * 5 doodle -bf $HOME/Ebooks /usr/share/doc -B=DE -B=EN --database=$HOME/.doodle/index || mail l1zard@Alucard -s 
"error during doodle refresh action"

===Dateien miitels regulärer Ausdrücke durchsuchen  \\ grep \\===
**grep '<Muster>' <Datei>** --> durchsucht <Datei> nach Muster zeilenweise
			    --> bei grep die '' nicht bei der Eingabe von Suchmustern verwenden
-c --> Anzahl der passenden Zeilen
-i --> ignoriere Groß- und Kleinschreibung
-n --> in welcher Zeile wurde der Ausdruck gefunden
-B --> numerische 
-r --> rekursiv mehrerre Dateien innerhalb eines Unterverezeichnisses sichen
-v --> Nur Zeilen die das Muster nicht enthalten 
-e --> meherre Muster mit oder Verknüpfen
-f <Conffile> --> lese einen oder mehrere Reguläre Ausdrüke aus <Conffile>
--line-bufferd --> grep schreibt seine Ausgabe zeilenweise anstatt alles aauf einmal nützlich für read
-E --> exteneded reguläre Expressions nutzen

__Suchmuster__
abc --> die Zeichenkette abc

[a-Z] --> Eines der Zeichen a-Z einmal

[^abc] --> Alle Zeichen ausser a b oder c

. --> ein beliebiges Zeichen beliebig oft auch gar nicht

+ --> ein beliebiges Zeichen mindestens einmal

? --> ein optionales Zeichen oder ein optionales Suchmuster

^abc --> abc am Anfang einer Zeile

abc$ --> abc am Ende einer Zeile

abc* --> abc beliebig oft also abcabcabc aber nicht "abc abc"

\ --> maskiere ein Sondereichen 
Beispiel ^a.*\.txt findet affe.txt arzt.txt usw

\< Anfang eines Wortes

\> Ende eines Wortes

a(bc) Die Buchtabenfolge bc beliebig oft nach a

{n,m}  Muster mit n bis m-maliger Wiederholung (nur **egrep**)

[[:alnum:]] Ein Alfanumerisches Zeichen

[[:alpha:]] Ein Zeichen aus de Alphabet

[[:blank:]] Ein Leerzeichen oder Tab

[[:lower:]] findet nur Kleinbiuchstaben

[[:upper:]] findet nur Großbuchstaben

[[:punct:]] findet ein Sazuzeichen `! " # $ % & ' ( ) * + , - . / : ; < = > ? @ [ \ ] ^ _ ` { | } ~'.

[[:digit:]] Eine Ziffer

[[:xdigit:]] Eine Hexadezimale Ziffe 0 bis f

Beispiel:
finde alle Nutzer deren UID 4-Stellig ist
** grep -e '^.*:x:[[:digit:]]{4;}:' /etc/passwd**


**fgrep <STRING>** --> Dasseelbe wie **grep -f** --> Eine Liste von String in Dateien suchen
		   --> Interpretiert keine regulären Expressions

__Und und Oder__
grep -E "(wort1|wort2)" | egrep "(wort1|wort2)" --> Suchmuster enthält wort1 oder wort2
grep -il wort1 <datei> | xargs grep -il wort2 --> Suchmuster entält Wort1 und wort2

===Standardkanäle und Filter==
0 Standard-Eingabe

1 Standard-Ausgabe

2 Standard-Fehlerausgabe

> Umlenkung der Standardausgabe
2> Umlenkung des Standardsfehler
&> Einen Kanal in einen anderen umleiten

**:> <Datei>** --> dasselbe wie cat /dev/null > <Datei>

**<programm> > <Datei>** --> Ausgabe in Dateiumlenken

**<programm> 2> <Datei>** --> Fehlerausgabe in <Datei> umlenken

**<programm> &> <Datei>** ; **<programm> > <Datei> 2>&1** --> Standardausgabe und Fehler nach <Datei> umleiten 

**<programm> >> <Datei>** --> Ausgabe an Dateianhängen

**<programm> < <Datei>** --> Programm liest Eingabe aus <Datei>

**<programm1>|<programm2> --> <programm2> nimmt seine Eingabeargumente aus der Ausgabe von <programm1>

**programm 3>&1 1> output 2>&3** --> Standartausgabe wird in die Datei output gelenkt und den Inhalt von der Datei output
in die Standardfehlerausgabe 

**echo FALSCH | find / -name pwd 2>&1 > treffer** --> leitet __nicht__ Std Fehler in den Standrderror
**echo RICHITIG | find / -name pwd > trefffer 2>&1** --> !!!So ist es richtig!!! Stderror wird an Stdtout anggehängt und 
Ausgabe dann geschrieben


\\ /dev/fd/N \\ --> Filedescriptor N

!! set -o noclobber --> Shell überschreibt existierende Dateien nicht durch Umleitungen !!

__xargs__
+ Ausgabe eines Progamms als Argumente zeilenweise übergeben
+ oft in zusammenhang mit find

**find / -name "*.~" | xargs rm** --> jede einzelne Datei die auf .~ endet und von find das rm Programm seqentiell
				      anwenden

**find / -name "*.bak" |xargs tar xvfz backup.tar.gz** --> jede von find gefundene Datei wird in das Archiv eingefügt 

__Dateien aus dem EIngabestrom barbeiten mit cat__
**cat** --> liest den Datenstrom von Stdtin oder Datei
-b --> durchnummerieren nichtleerer Zeilen
-E --> markieren des Ende der Zeile
-n --> durchnummerieren aller Zeilen auch leerer
-s --> unterdrückt die Ausgabe von mehreren Leerzeilen
-T --> stelle Tabulatorzeichen als ^I dar
-v --> macht Steuerzeichen sichtbar 
-A == -vET
-t=-vT
-e=-vE

!! cat > <Datei> << "EOF"  !!

!! cat <Datei1> <Datei2> <Datei3> > Dateien !!

**tac** --> liest den Datenstrom von Stdin oder Datei von unten nach oben

**head** --> liest die ersten 10 Zeilen
-N --> liest die ersten N Zeilen
-n <n> --> wie -N
-c <n> --> nur ersten N Zeichen anzeigen


**tail** -->liest die letzten 10 Zeilen
-N --> liest die letzten N Zeilen
-n <n> --> wie -N
-n <n> -f --> liest die letzten <n> zeilen und jede neuen Input 
-c <n> --> nur die ltzten <n> Zeichen anzeigen


!! tail -n 30 -f  <Datei> Wichtig für die Beobachtung von Protokolldateien !!

!! tail +30 <Datei> Alles ab Zeile 30 !!

**od** --> Oktaler dump einer Datei

**hexdump** --> hexadezimaler dump einer Datei

**xxd** --> kann zusätzlich zum Hexdump eine zusätzliche Binäre Form erzeugen


__Texte bearbeiten und manipulieren__
**expand** --> Tabs in Leerzeichen konvertieren

**unexpand** --> Leerzeichen in Tabs konvertieren
-t N --> N Leerzeichen bilden einen Tab, überstehende Leerzeichen werden nicht berücksichtigt

__Zeichen in Texten manipulieren__
**tr <s1> <s2>** --> tauschen von einzelenen Zeichen gegen andere in einem Datenstrom
-d <s1> --> löschen anstelle von austauschen der Zeichen <s1>
-c --> ersetzen von Zeichen die nicht in <s1> stehen durch <s2>
-s --> mehere Zeichen <s1> durch ein einzelnes <s2> ersetzen
 
!! tr -s Ae Ä < text1 > text2 !!

!! Für komplexre Minipulationen empfiehlt sich sed !!

__Text Zeilenumbrüche herbeiführen__
**fmt <Datei>** --> Zeilenumbruch bei <Datei> nach 75 Zeichen bewirken
-w N --> Zeilenumbruch nach N Zeichen anstelle von 75 Zeichen bewirken


__Text für den Drucker kompatibel machen__
**pr <Datei>** --> Formatierungen für den Drucker
-N --> ergibt eine Darstellung von N Zeichen
-h <t> --> auf jeden Seitenkopf steht der text <t>
-l <N> --> <N> Zeilen pro Seite
-n --> vergibt jeder Zeile eine 5-stellige Zeilennummer
-o <N> --> text um N Zeichen vom linken Rand einrücken
-d --> nutze Doppelte Spacezeichen anstelle von einmal Space

__text nummerieren__
**nl <Datei>** --> Zeilen nummerieren
-b a|t|p <Ausdruck>  --> nummeriere a(lle) t nur nicht leere oder nur die Zeilen die auf <Ausdruck> passen
-h |-f a|t|p --> header|footer Stile
-i <N> --> inkremnet um N pro Zeile
-n ln|rn|rz|lz --> formatiere die Zeilennummerierung linksbündig|rechtchbündig|rechtbündg mit führende nullen|linksbündig mit führenede nullen
-p ignoriere Seiten Zeilenzahl wird bei logischen Seiten nicht auf den Anfangswert zurückgesetzt
-v <N> --> beginne Numerierung bei N


__Wörter zählen__
**wc <Datei>** --> gibt Anzahl von Zeilen, Wörter oder Zeichen von <Datei> aus
-l --> nur Zeilen, Anzahl \n NL Zeichen
-w --> nur Wörter
-c --> Nur Zeichen c(harcter)

!! rpm -qa|wc -w gibt aus wieviele rpms auf dem System installiert sind !! 

!! Useless use of cat: cat bla|wc -w einfacher: wc -w bla !!

__Wörter sortieren__
**sort** --> sortiert den Dateneingabestrom standarmäßig aufsteigend nach ASCII 
LC_ALL=de_DE --> setzt Sortierwerigkeit auf "deutsche" Sortierung
-k N --> soritere das nte Feld
-k N,M --> sortiere vom N-ten bis M-ten Feld
-b --> ignoriere Führende leerzeichen
-d --> sortire wie im Wörterbuch
-f --> ignoriere Groß und Kleinschreibung
-i --> nicht druckbare Zeichen ignorieren
-o <Datei> --> schreibe Augabe in <Datei>
-r --> sortiere Absteigend
-n --> numerisch sortiren
-g --> behandele Zahlen als Integer und sortire dann, ignoriert Buchstaben
-u --> unique

__Nur Zeilen mit gleichen Inhalten ausgeben__
**unique** vergleiche zwei aufeinander folgende Zeilen und gib doppelte zeichen nicht aus
-u --> gib nur einmalige vorkommende Zeilen aus

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
TIPP:
Marvin: rpm -qa > liste1.txt
Alucard: rpm -qa > liste2.txt
cat liste1.txt liste2.txt> liste.txt
uniq -u liste.txt

Gibt nur die Pakte aus die entweder auf Marvin oder auf Alucard installiert sind aber nicht auf beiden
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

__Dateien Spaltenweise beschneiden__
**cut** --> beschneidet eine Datei Spaltenweise
-c S,M-N --> schneide die Spalten S aus und zusätzlich Spalten N-M beliebig oft wiederholbar
cut -c 15,1-5 /etc/passwd schneidet Spalten 1-5 und Spalte 15 aus, wobei jede Spalte ein Zeichen entspricht

-d <Trennezeichen> --> soll der Delimiter ein anderes Trennzeichen sein muss dieses angegeben werden
-f --> Spaltenweise ausscheneiden
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++
cut -d: -f1,1 /etc/passwd gibt die liste alle Nutzer aus
cut -d' ' -f3 Datei gibt die dritter Spalte von Datei aus, wobei der Zeilentrenner das Leerzeichen ist und '' die
	      neben dem Fragezeichen
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++

__Dateien zusammenführen__
**cat <File1> <File2> > <Outptfile>**

**paste <Datei1> <Datei2>** --> Dateien Zeilenweise zusammnführen
	 		    --> dabei entthalten 2 Zeilen die jeweiligen Zeilen der <Datei1> und  <Datei2>

-s --> Dateien nacheinander ausgeben

-d --> einen anderen Trennen angeben

**join** --> Dateien relational zusammenführen
-t --> einen anderen Feldtrenner bestimmen
-i --> ignoriere die Groß und Kleinschreibung
-R T --> nutze die T-te Spalte der R-ten Datei als Referenz 
-o <FORMAT> --> eine andere Ausgabeformatierung als die der Eingabe benutzen

__Dateien identifiezieren__
**file** --> zeigt den Dateityp basierend auf der Mime Datenbank an

\\ /usr/share/misc/magic \\ --> Unter SuSE enthält die Regeln für file


**cmp <DateiA> <DateiB>** --> überprüft ob die beiden Dateien <DateiA> und <DateiB> identisch sind byteweise
-b --> gebe unterschiedliche Bytes an
-s --> silent 


===FHS Linux Dateisystem===
/bin --> wichtige ausführbare Dateien ohne die Linux nicht funktionieren würde

/boot --> Dateien die zum booten relevant sind 
	\\ vmlinuz \\ der Kernel
 	\\ grub/menu.lst \\ konfigurationsdatei für grub in grub2 befinden sich diese in /etc
	\\ initrd \\ Initial ramdisk die beim booten des Kernels benötigt wird, enthält zu landete Module

/sbin --> Programme die zum Systemstart von linux benötigt werden, die aber nur von root ausgeführt werden dürfen 
oder von Benutzern nur eingeschränkt genutzt werden dürfen

/lib --> Shared librarie

/lib/modules --> Kernelmodule

/dev --> Gerätedateien **udev**
	\\ /dev/null \\ der Mülleimer
	\\ /dev/random /dev/urandom \\ generiert zufällige Zeichenfolge
	\\ /dev/zero \\ generiert Nullen
	\\ /dev/sdX \\ Scsi Geräte, ATA Platten, Usb Platten und Sticks
	\\ /dev/hdX \\ IDE Platten
	\\ /dev/dvd \\
	\\ /dev/sr0 \\ 
	
/etc --> Konfigurationsdateien
	\\ fstab \\ --> alle beim Start des Systems einzuhändenen Dateisysteme mit Optionen und Eigenschaften
	\\ mtab \\ --> alle momentan eingehängten Dateisysteme
	\\ hosts \\ --> Konfiguration des TCP/IP Netzwerks
	\\ inittab \\ --> Konfigurationsdatei für den Start für Linux
	\\ /etc/init.d/rc.x \\ --> Scripte die im runlevel x ausgeführt werden meistens 1-5
	\\ /etc/issue \\ --> Begürßungstext vor der Anmeldung angezeigt
 	\\ /etc/modt \\ --> Begrüßungstext nach einer Anmeldung angezeigt
	\\ /etc/passwd \\ --> Nutzer inklusive gruppenzugehörigkeiten und Shell sind hier festgelegt
	\\ /etc/shadow \\ --> enthält verschlüsselte Passwörter und ihre Einstellungen

/opt --> Drittanbieter Software

/usr/local --> Aus dem Quelltext kompillierte Software und die dazugehörigen Dateien

/usr/bin --> Programme die nicht zum Systemstart gebraucht werden

/usr/sbin --> Systemprogramme für root die nicht beim Systemstart benötigt sind

/usr/lib --> Bibliotheken die nicht von Dateien in /bin oder /sbin benötigt werden

/usr/share --> von der Rechnerarchitektur unabhängige Dateien
      
/usr/share/doc --> Dokumentation
 \\packages \\ --> Unter SuSE zusätzliche Dokumentation zu den einzelnen Paketen

/usr/share/man --> Manual Pages

/usr/share/info --> Info Seiten

/usr/src --> Quellpakete
	\\ /usr/src/linux \\ Quellen des linux kernels sollte auf die Version auf den aktuellen Kernel gelinkt sein
	\\ /usr/src/pacakges \\ Qullen und SPECs zur Rpm-Paketierung

/proc --> Dateien werden vom Kernel erzeugt und werden erhalten informationen
	\\ /proc/<PID>/status \\ Informationen zum laufenden Prozess mit der <PID>
			/environ  Umgebungvariablen
			/exe Link zum Programm
			/fd Verzeichnis dass die offenen Dateidiskriptoren des Prozesse abbildet
			/maps Speichermapping
			/mem Speicherbedarf des Prozessses
			/stat Status des Prozesses
			/statm Informationen zunm belegten Speicher

	\\ /proc/cpuinfo \\ Informationen zur CPU
	\\ /proc/devices \\ Liste der Dateien die vom Kernel unterstützt werden
	\\ /proc/dma \\ Liste der belegten DMA-Kanäle 
	\\ /proc/interrupts \\ Liste der vom Kernel beanspruchten Interruppts
	\\ /proc/ioports \\ Liste der vom Kernel beanspruchten I/O Ports
	\\ /proc/kcore \\ Abbild des Arbeistspeichers kann nur root lesen
	\\ /proc/loadavg \\ Auslastung der CPU innerhalt der letzten 1,5,15 Minuten
	\\ /proc/meminfo \\ Speicherauslastung des Swapbereichs
	\\ /proc/mounts \\ Liste der eingehängten Dateisysteme
	\\ /proc/scsi \\ Informationen zu Scsi und Hostadapter
	\\ /proc/version \\ Versionsinformationen zum Kernel
	!!! \\ /proc/cmdline \\ Kommandozeilenargumente die dem Kernel übergeben wurden !!!
	\\ /proc/kmsg \\ Protokolldatei des Kernels
	\\ /proc/partitions \\ Alle bekannten Partitions
	\\ /proc/pci/ \\ PCI-Geräte
	\\ /proc/ide/drivers \\ Informationen zu IDE-Geräten
	\\ /proc/net
		/arp \\ ARP-Tabelle des Kernels
		/dev \\ Statisken deer Netzwerk Geräte
		/dev_stat \\ Status der Netzwerk Geräte
		/igmp \\ Tabelle des Internet Group Management Protocol (Routing)
		/ip_tables_$ \\ Informationen über die Firewallregeln iptables
		/netstat \\ Netzwerkstatistiken
		/route \\ Routing Tabelle des Kernels
		/rpc \\ Informationen aktiver RPC-Dienste
		/snmp Daten des Simple Network Management Protocols
		/tcp \\ Tabelle des TCP Sockets
		/udp \\ Tabelle der UDP Sockets
		/unix \\ Tabelle der geöffnete Unix Domain Sockets mit Referenzzähler, Protokoll, Flags, Typ, Status, 
			Inodenummer und Pfad
		\\
	\\ /proc/sys/kernel 
			/acct \\ Kontrolle zur Prozesserzeugung
			/ctrl-alt-del \\ Was passiert beim druck auf ctrt-alt-del einzustellen in \\ /etc/inittab \\
			/domainanem \\ Der NIS Domainname des Rechners
			/hostname \\ Der Rechnername
			/modprobe \\ Zugriffspfad zum Programm, dass die Module nachläd
			/osrelease \\ Version des Kernels
			/ostype \\ Linux, bsd
			/panic \\ Schwerwiegender Fehler 
			/version \\ Übersezungsdatum des Kernel
			\\
	\\ /proc/sys/net
			/802 \\ Daten zum E802-Protokoll
			/core \\ Einstellungne zum Netzwerk 
			/ethernet \\ Unterverzeichnis mit Daten zum Ethernet Protokoll
			/ipv4 
				/conf \\ weitere Verzeichnisse zu jedem im System befindlichen Netzwerkdevice
				/accept_redircts \\ kernel akzeptiert icmp packages oder nicht
				/accept_source_route \\ 1 in Falle von Routern 0 sonst
			\\

/sys --> Sicht auf Hardware und Steuerungsschicht

/var --> Variable Dateien
	\\ /var/log/ \\ logdateien
	\\ /var/log/messages \\ logdatei die man bekommt wenn man dmesg aufruft
	\\ /var/spool/mail \\ Systemmails
	\\ /var/sppol/cups \\ wartende Druckaufträge
	\\ /var/spool/cron \\ Nutzer cronjobs
	\\ /var/lib/ \\ temporäre Datenbanken die von anderen Programmen benötigt werden
		/clamav \\ Virendefinition für clamav
		/zypp \\ Informatione die zypper auf dem System zwischenspeichert
		/Yast2/failedpackages \\ Informationen über Pakete die aufgrund eienes Fehlers nicht installiert wurden
	\\ /locatedb \\ die Datenbakn die von updatedb erzeigt wird

/tmp --> temporäre Dateien die nach einer gewissen zeitspanne gelöscht werden
!! Im gegensatz zu Windows empfiehlt es sich nicht diese Dateien von Hand zu löschen !!
!! kde und gnome schreiben wichtige Dateien hierher !!

/srv/ --> Dateien die von verschiedenen Dateien angeboten werden
	\\ www \\ --> Dateien des Apache

/media --> wechselbare Medien (Cds Dvds Usbsticks) werden hier gemounted

/mnt --> Zugriff auf andere Datenträger zum Beispiel zweite gemountete Partition oder zweite Festplatte

/home --> Heimatverzeichniss der Benutzer im System ausser root

/root --> Heimatverzeichnis von root

/lost+found --> Dateien die beim wiederherstellen von **e2fsck** wiederhergestellt wurden

__FHS Schema__
		statisch 			dynamisch

lokal		/etc /bin /sbin /lib		/dev /var/log 

enterfernt 	/usr /opt			/home /var/mail

===Archivieren und Komprimieren===

__Dateien archiveren mit tar__
**tar [ARCHIVDATEI] [DATEI IM ARCHIV]** erzeugt und entapckt Archive die mit tar erstellt wurden
-cf erzeugt ein neues Archiv
-M bearbeiten von multi-volumes-archive
-r hängt Dateien and ein besethendes Archiv
-t zeige den Inhalt des Archiv
-x auspacken des Archives
-z mit gz komprimieren
-j mit bz2 komprimieren
-P entferne die führenden / nicht bei absoluten Pfaden
-C nur beim Auspacken einen Anderes existierendes Verezichnis zum AUspacken angeben


**tar xvfz <Archiv.tar.gz** --> entpacken des gz Archivs 

**tar xvfj <Archiv.tar.bz2** --> entpacken des bz2 Archives

**tar tvfj <Archiv.tar.bz2** --> testen, einsehen des bz2 Archives

**tar tvfz** <Archiv.tar.gz** --> testen, einsehen des gz Archives 

**gunzip <Datei.gz>** -->  dekomprimieren der <Datei.gz>

**bunzip2 <Datei.bz2>** --> dekomprimieren der <Datei.bz2**

**unzip  <Datei.zip>** --> entpacken eines Windows zip Archives

**rar e <Datei.rar** --> entpacken eines rar Archives

__Dateien aus einem Datenstrom komprimieren/dekomprimieren__
**cpio** Archiv aus der Standardausgabe erzeugen
-o erzeuge Archive auf der Standardausgabe (output)
-i einlesen eines Archives (input)
-t gebe namen beim extrahieren aus
-d erzeuge Verzeichnis falls notwendig, immer dann wenn eine Verezichnishierarchie entpackt werden soll
-F eine Datei angeben
-u überschreiben von Dateien beim auspacken
-p <Verzeichnis> Angeben eines zusätzlichen Verzeichnisses

Beispiel einpacken: 
**find . -type f| cpio -ov > archive.cpio**
**ls | cpio -ov > verzeichnis.cpio**
 
Beispiel auspacken:
**cpio -iv < archive.cpio**

**info cpio** enthält die ausführliche sehr gut dokumnetirerte Anleitung

Tipp:
Ein Backup des homverzeichnisses anlegen
**find /home |cpio -o > backup.cpio**

__Dateien splitten__
**split <Sehr_große_Datei>** --> zerhacken von sehr großen Dateien
-a Suffix festlgen
-b <N>b|K|MB|M|G|GB|T|P Größe in Bytes,... pro Teil
-d Numerischer Suffix anstelle Alphabetische Suffix

Beispiel: split -a name_ -b 2GB <Große_Datei> 

__Dateien wieder zusammenfügen__
!! Mit cat !!
**cat aa1 aa2 aa3 >> Große_Datei** --> fügt eine mit **split** zerteilte Datei wieder zusammen

===Benutzer und Gruppen===

__Nachrichten an alle Benutzer senden__
**wall [Datei]** --> schickt eine Nachricht an alle Nutzer, falls Datei verwedndet wird, wird Nachricht aus Datei 
		     ausgelesen

__Benutzerkontoinformationen anzeigen__
**id <Nutzer>** gibt UID username GID Gruppenname der Primären und Sekundären Gruppe(n) von nutzer an
ohne Angabe des Nutzers die Information des aktuell angemeleten  Nutzers
-G alle GIDs 
-g die effektive GID
-n Namen anstelle der Nummern ausgeben nur sinnvoll mit -u, -g oder -G
-u effektive User ID

**w** --> gibt Informationen über die Aktivitäten angemeldeter Benutzer aus

**who** --> Informationen über Nutzer relational zu Systeminformationen ausgeben
-a --> alles Anzeigen
-b --> Zeit seit dem letzten Boot
-d --> Ausgeben bereits toter Prozesse
-q --> Anzahl der Nutzer die insgesanmt angemldet sind

**groups [<User>]** --> listet die Gruppenzugehlörigkeit des von <User> auf
		    --> falls keine <User> angegeben werden alle Gruppen des momentanen Nutzers ausgegeben


__/etc/passwd__
<Benutzername>:x:<UID>:<GID>:<GECOS>:<Heimatverzeichnis>:<Shell>

__/etc/shells__
Liste der Shells die ein Nutzer mittels **chsh** als login erhalten kann

__/etc/shadow__
<Benutzername>:<Kennwort verschlüsselt>:<Datum der letzten Änderung des Kennworts>:<Min>:<Max>:<Warnung>:<Frist>:<Sperre>

__/etc/group__
<Grupenname>:<Kennwort>:<GID>:<Mitglieder>

__/etc/login.defs__
Standartkonfiguration für die login Programmtools **pwdutils** 

__Benutzerkonten anlegen__
**useradd <User>** --> legt den <User> an
-c Eintrag in GECOS
-d Heimatverzeichnis
-e JJ-MM-TT Datum an dem der Zugang gesperrt, wird ohne Angabe von JJ-MM-TT sofort gesperrt
-g primäre Gruppe des Benutzers
-G sekundäre Gruppen des Benutzers durch , getrennt
-A relative Gruppen hinzufügen
-R relative Gruppen wegnehemen
-s login Shell des Benutzers
-u UID eindeutige Nutzerid 
-o in Zusammenhang mit -u legt UID auch an wenn diese schon vergeben war
-m legt das Heimatverzeichnis des Nutzers an und kopiert Dateien aus /etc/skel 
-k nur in Zusammenhang mit -m alternatives Skel-Verzeichnis
--show-defaults | -D anzeigen und manipulieren der Standardwerte

\\ /etc/default/useradd \\ --> enthält die Standardeinstellungen wenn keine Optionen angegeben wurde


__Benutzerkonten manipulieren__
**usermod <User>** --> Einstellungen für <User> ändern
		   --> nicht erlaubt für Nutzer die noch angemeldet sind
		   --> affektiert nicht PIDs von laufendden Prozessen, crontabs und at-jobs
-L --> den Account des Nutzers sperren
-U --> den Account des Netzers entsperren
-g --> setzend er neuen Primärgruppe
-G --> ädnern der Sekundärgruppen
-a --> Gruppe hinzufügen, mit -G $$DEBIAN$$
-f --> Interaktiv ändern

__Benutzer Passwörter vergeben__
**passwd** Passwort für den aktuell angemeldeten Benutzer ändern
**passwd <User>** Passwort als root für <User> ändern
-S <User> Passworteinstllungen anzeigen
-Sa Passworteinstellungen für alle anzeigen
-e Benutzer wird gezwungen beim nächsten Login ein Passwort zu vergeben (setze das 3. Feld in \\ /etc/shadow \\ auf 0)


__Passwörter von die \\ /etc/passwd \\ in \\ /etc/shadow \\ konvertieren__
**pwconv** --> Trägt alle Passworthashes die in der \\ /etc/passwd \\ stehen in die \\ /etc/shadow \\ ein
-P <PATH> --> einen alternativen Pfad <PATH> angeben

**pwunconv** --> Trägt alle Passworthashes die in der \\ /etc/shadow \\ stehen in die \\ /etc/passwd \\ ein
-P <PATH> --> einen alternativen Pfad <PATH> angeben


__Passwowrteinstellungen ändern__
Zugang sperren --> **passwd -l <Nutzer>**, **chage -E <Datum> <Nutzer>, editeren der /etc/shadow durch setzen eines ! vor 
dem Kennwort, editieren der /etc/passwd durch setzen eines * anstelle eines x im zweiten Record 

Zugang freigeben --> **passwd -u <Nutzer>**, **chage -E -1 <Nutzer>, editeren der /etc/shadow durch entfernen des ! vor
dem Kennwort

Kennwortänderung höchstens alle N Tage --> **passwd -m N <Nutzer>**, **chage -m 7 <Nutzer>**, editieren der 4.Spalte der
/etc/shadow

Kennwortgülitgeitsdauer --> **passwd -x N <Nutzer>, **chage  -M N <User>**, editieren der 5. Spalte der /etc/shadow

Gnadenfrist nach Ablauf des Kennworts --> **chage -I N <User>, editieren der 7. Spalte der /etc/shadow

Warnfrist setzen --> **passwd -w N <User>**, **chage -W N <User>**, editieren der 6. Spalte der /etc/shadow

!! chage kann interaktiv ausgeführt werden !!


__Syntax der Dateien \\ /etc/passwd \\ und \\ /etc/shadow \\__
**pwck** --> überprüft die Paswortdateien nach Fehlern und ungenutzten Nutzern
-s --> Sortieren der Passwortdatei
-P <Pfad> --> Suche nach den beiden Passwortdateien im Pfad


__Root Passswort vergessen__
(1) Starten des Betriebssystem init=/bin/sh
(2) passwd neues root passwort setzen
(3) neu starten 

!! Funktioniert nicht mehr bei allen Systemen !!
!! Einige eigentlich die meisten Distris haben Vorkehrungen gegenüber dieser Attacke !!


__Benutzer löschen__
**userdel <User>** --> <User> vom System entfernen
-r entsorgen des Heimatverzeichnis, der crontabs und der mails

**find / -uid <UID> -delete** --> finde und lösche Dateien die dem Nutzer mit der <UID >gehören

__Datei mit vi direkt bearbeiten__
**vipw** --> Editor für /etc/passwd
-s --> Editor für /etc/shadow

**vigr** --> Editor für /etc/group

VISUAL; EDITOR bestimmt welcher Editor aufgerufen wird

__Gruppen hinzufügen__
**groupadd <Group>** --> Gruppe <Group> hinzufügen
-g <GID> --> die Gruppe erhält <GID> 
-r --> System Gruppe anlegen \\ /etc/login.defs \\
-o --> das gleich wie bei useradd

__Gruppen modifizieren__
**groupmod <Gruppe>** --> <Gruppe> modifizieren
-g <GID> --> Gruppe <GID> neu zuweisen
-n <Name> --> Gruppe den neuen <Namen> zuweisen
-R <Nuzer> --> den NUtzer aus der Gruppe entfernen


__Gruppe löschen__
**groupdel <Group>** <Group> entfernen 
!! Nur möglich wenn die Gruppe nicht als primäre Gruppe einem User zugeordnet worden ist !!

===Zugriffsrechte===

__Rechte Oktal__
r = 4				
w = 2
x = 1

bei regulären Dateien:
t= 1ugo Sticky Bit	Nur der Eigentümer kann die Datei löschen, alle anderen dürfen aber schreiben und lesen
			sofern die Rechte gesetzt sind
			Sinn? Beachte cat /dev/null > <Datei>	

S= 2ugo Setuid Group	wird immer mit den Rechten der <Gruppe> geöffnet egal wer sie öffnet oder ausführt 
			Alle erzeugten Dateien gehören der Gleichen Gruppe wie das Verzeichnis selbst

s= 4ugo Setuid User	wird immer mit den Rechten des <Users>  geöffnet egal wer sie öffnet oder ausführt
			keine Wirkung auf Verzeichnisse


kernel Syscall include fchmod() 
#include <sys/stat.h>
       S_ISUID  (04000)  

       S_ISGID  (02000)  

       S_ISVTX  (01000)  

       S_IRUSR  (00400)  

       S_IWUSR  (00200) 

       S_IXUSR  (00100)  

       S_IRGRP  (00040)

       S_IWGRP  (00020)

       S_IXGRP  (00010)

       S_IROTH  (00004)

       S_IWOTH  (00002)

       S_IXOTH  (00001)

!! Für binäre Programme muss x gestzet sein. Für Shellscripte muss x und r gesetzt sein !!

!! Bei Verzeichnissen ist r um den Inhalt das Verzeichnisses lesen zu dürfen, w um Im Verzeichnis Dateien anlegen und
löschen zu könnnen, x um das Verzeichnis benutzen zu dürfen indem Sinne das man darauf cd anwenden darf !!

**ls -l** --> zeigt Berechtigungen an
**alias fstat='stat -c "%a %n"'** --> zeigt Berechtigungen Oktal an

__Berechtigungen ändern__
**chmod <Berechtigungen> <Datei>** --> <Berechtigungen> für <Datei> ändern
-R --> rekursives ändern
Berechtigunen für:
u --> User 
g --> Group
o --> Other (Rest der Welt)

Werte können explizit entweder Oktal oder durch Rechtebits vergeben werden:
**chmod 750 <Datei>** oder **chmod u=rwx,g=rx-,o=---**
**chmod u=rwx go=--- <Datei>**

Rechte können hinzugefügt oder entzogen werden 
**chmod +x <Shellscript>** --> das Shellscript für alle ausführbar machen
**chmod u+x <Shellscript>** --> das Shellscript für den User ausführbar machen
**chmod g-x <Shellscript>** --> das Shellscript nicht für die Gruppe ausführbar machen

--refernce=<Name> Verwendet die Rechte für die der Datei <Name> als Referenz für die Rechte der neuen Datei
Trick: Angeben meherer Refernzdateien für verschieden Gruppen im Verzeichnis des Admins nach dem Schema
/root/Permissions/Gruppe1 Gruppe1, ist eine leere Datei die lediglich als Referenz für die Gruppe1 dient

__Benutzer und Gruppenzugehörigkeit ändern__
**chown <user>:<group> <Datei>** --> gebe <Datei> die <User> und <Group> Zugehörigkeit
**chown <user>:  <Datei>** --> gebe <Datei> die <User> Zugehörigkeit
**chown :<group> <Datei>** --> gebe <Datei> die <Group> Zugehörigkeit
-R --> rekursiv

__Gruppenzugehörigkeit ändern__
**chgrp <Group> <Datei>** --> Gruppenzugehörigkeit als Normaler Nutzer ändern, wenn dieser der Gruppe zugehört und er Besitzer der <Datei> ist
-R --> rekursiv

__umask__
--> legt fest welche Berechtigungen Dateien maximal haben wenn sie angelegt werden
**umask** setzen und anzeigen der Umask 
-S --> Werte Symolisch

\\ ~/.profile \\ 

Bitweise Und verknüpfung mit den Standartugriffsrchten
Besipiel: 
rwxrx-r--	Rechte Symbolisch
754		Rechte Oktal
777		+ 777 im Z_8
023		Umask		

072		Umask
777		+777 im Z_8
705		-1 für das x bit (Dateien werden grundsätzlich nicht ausführbar angelegt)
604		Rechte Oktal
rw----r--	Rechte Symbolisch Dateien
rwx---r-x	Rechte Symbolisch für Verzeichnisse


__ACLs__
**setfacl -m u:<User>:<rwx>,g:<Group>:<rwx> <Datei>** --> Setzt rwx ACL Werte für <Datei> für den <User> bzw für <Group>

**setfacl -b <Datei>** --> entfernt alle ACLs von der <Datei>

**setfacl -x u:<User1>,u:<User2>,g:<group> <Datei>** --> entfernt ACLs von der <Datei> für <User>

**setfacl -M <ACL> <Datei>** --> liest die Rechte für <Datei> aus <ACL>

**setfacl -m mask:<rwx>:<rwx> <Datei>** --> Setze die "Effective Rights mask" für <Datei>

Beispiel <ACL> Datei: 
user:axel:rw-
user:tippy::rw-
group:lensmen:r--
groue:fafnir:---
mask::rw-
other::---

**getfacl <Datei>** --> Zeigt die gesetzten ACLs an
-n --> numerische Werte anstelle symbolischer Werte verwenden
--omit-header --> ohne Header ausegben
-R --> rekursiv

Acls müssen in der \\ /etc/fstab \\ als Option bekannt gegeben werden
Option: acl
**mount -v -o remount /home**	

__Erhalten von ACLs__
**cp -p** oder **cp -a** --> erhält auch ACLs beim kopieren

**rsync -A** --> erhält ACLs beim synchronisieren von Dateien

**star** --> erhält Dateien beim Archivieren

___Dateiattribute__
**lsattr <Datei>** --> anzeigen der Attribute
Die beiden Wichtigsten:
a --> nur anhängen
i --> immutable Nicht löschen nicht verändern

**chattr +|-<Attribut> <Datei>** --> <Attribut> zu|von <Datei> hinzufügen|entfernen
Beispiel:
**chattr +a Logdatei** --> erlaubt nur noch das Anhängen von Einträgen an die Datei. Sinnvoll um Logdateien vor
Manipulation zu schützen

__Erweiterte Datei Attribute__
--> Ähnlich wie ACLs für Attribute 
--> man 5 attr


===Prozessverwaltung===
Pseuoprozess(0)--> ruft init Prozess auf--> Startetd weitere Prozesse
\\ /etc/inittab \\

PID init ist immer 1

!! Für Firewalls empfiehlt es sich den init Prozess zu beenden und gegen iptables auszutauschen !!

Jeder Prozess ist einer PID und eine PPID zugeorndet
			Prozess_ID   Parrent_Prozess_ID

<Strg-c> --> Sendet Signal 15 SIGTERM an Prozess
<Strg-z> --> Sendet Signal 20 SIGTSTP an Prozess

**jobs** **fg** **bg**

__Prozesszustände__
runnable --> Prozess warted auf Ausführung

operating --> Prozess wird von der CPU gerade bearbeitet

sleeping --> Porzess warted auf nächsten Prozess status --> runnable oder end

end --> Prozess wird beendet

stopped --> Prozess wurde mittels <Strg-z> oder vom Signal 20 gestopped

TRICK:  grep ^state: /proc/$!/status --> Status des aktuellen Prozesses erfragen

__Zombies__
Prozesse die in der Luft hängen und keinen Elternprozess mehr haben

__Prozessinformationen einholen__
**ps** --> zeigt Informationen zu Prozessen an
POSSIX Optionen:
a --> zeigt alle Prozzese mit Terminal
u|l --> Zusatzinfomationen über die aktullen Prozesse
r --> listed nur die Programme auf, die momentan laufen
T --> zeigt alle Prozesse im aktuellen Terminal
U <User> --> zeige alle Prozesse von <User> an
x zeigt auch Prozesse ohne Terminal an
GNU Optionen:
--forest --> zeigt die Prozesshierarchie als Baum
-A |-e --> zeige Alle auf der Maschine laufenden Prozesse auch Daemons
-w --> bei der Ausgabe wird nichts abgeschnitten

**ps <PID>** --> zeigt Informationen zum Prozess mit <PID> an
-C <Name> nutze <Name> anstelle von <PID>

**ps u -wA** --> alle laufenden Programme inklusive Pfad und zusätzlichen Informationen

Tipp:
l1zard@Marvin:~> kill $(ps -A|awk '/Name/{print $1}')
kill $(ps -A|grep beagled|awk '{print $1})' --> den beagled töten

**pstree** --> den Prozessbaum anzeigen
-p --> mit PID anzeigen
-u --> Besitzerwechsel anzeigen
-G --> grafische Zeichen zur Darstllung verwenden

Tipp:
**watch -n 1 pstree -up** --> zeige den Prozessbaum mit Besizerwechsel und PID jede Sekunde

__Ein Signal an einen Prozess senden__
**kill <SiGNAL> <PID>** --> sendet <SIGNAL> an Prozess mit der <PID> 

**kill <SiGNAL> -1** --> sendet <SIGNAL> an alle Prozesse die dem aktuellen Benutzer gehören 
!! **kill -l** !! --> listet die Signale über die Linux mit Prozessen kommunizieren kann

<SIGNAL>
SIGHUP	1	hangup: beende alle Prozesse die Kindprozesse der aktuellen Shell sind

SIGINT	2	interrupt: <Strg-c> den Prozess unterbrechen

SIGKILL	9	kill: beendet den Prozess ohne Rückfrage, offene Dateien werden vom Prozess nicht geschlossen

SIGTERM	15	terminate: beendet den Prozess, offene Dateien werden ordnungsgemäß beendet ("sauberer kill")

SIGCONT	18 	continue: Setz den mit SIGSTOP angehaltenen Prozess fort

SIGSTOP	19	stop: hält den Prozess an

SIGTSTP	20	terminal stop: Entspricht <Str-z>

<PID>
PID > 0 --> sende das Signal an den Prozess mit der angegebenen PID

PID == 0 --> sende das Signal an alle Prozesse der gleichen Prozessgruppe wie der gesendete

PID < -1 --> Die Prozessgruppe dessen Identifizierungsgruppe zur entsprechenden PID gehören

PID == -1 --> sende das Siganal an alle Prozesse die dem aktuellen Benutzer gehören

**killall <SIGNAL> <Name>** --> sendet <SIGNAL> an alle Prozesse mit <Name> 
-i --> fragt vorher nach

!! exit-Status - 128 = Siganlnummer !!


__Prozessprioritäten__
-20 > x > 19 --> je kleiner die Zahl desto höher die Priorität

**nice <Wert> <Befehl>** --> ruft <Befehl> mit dem nice <Wert> auf
--> nur root darf hohe Porzesspriotäten setzen also negative nice-Werte
--> init hat nice Wert 0
--> Neue Prozesse werden mit nice Wert +10 aufgerufen

**renice <Wert> <option>** --> ändert den Nice-Wert von <PID> auf <Wert>
--> normale Nutzer dürfen nice Wert mit renice nur erhöhen
-p <PID> --> Die Prozesse mit der PID ändern
-g <Group> --> Die Prozesse der Gruppe <Group> ändern
-u <User> --> Die Prozesse der Nutzer <User> ändern


**ulimit <Limit>** --> limitiere die Resourcen für eine Shell und der von ihr gestarteten Prozesse
-a --> zeige die aktuelle gestzten Limits
-d --> Schränkt die aktulle Größe des Datensegments ein
-f --> verbietet den Anwender eine Datei über eine bestimmte Größe zu erzeugen
-n --> Schränkt die maximal offnenen Dateien pro Prozess ein
-t --> Schränkt die verfügbare CPU-Zeit auf die angegeben Anzahl Sekunden ein
-u --> Schränkt die Anzahl der Prozesse je Benutzer ein 
-v --> Schränkt den virtullen Speicher ein

-H --> angeben einer harten Grenze, erfordert eine der voranstehenden Optionen
-S --> angeben einer weichen Grenze, erfordert eine der voranstehenden Optionen

Limits lassen sich am Besten in der \\ /etc/security/limits.conf \\ setzen:
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#Jede Zeile beschriebt ein gesteztes Limit für einen Nutzer in der Form
#
#<Domain>        <Typ>  <Item>  <Wert>
#
#Wobei:
#<Domain> sein kann:
#	 - ein Nutzer Name
#	 - eine Gruuppe wird entsprechend mt @Gruppe refernziert
#        - * Für den Standardeintrag
#        - % kann mit %Gruppe anagegeben werden um eine Maximalzahl von Logins festzulegen
#
#<Typ> kann die folgenden Werte haben:
#        - "soft" für Softlimits
#        - "hard" für Hardlimits
#
#<Item> kann eines der folgende Werte annehemn:
#        - core - die größe der coredumps die bei segfaults etc. angelegt werden (KB)
#        - data - maximale Data Größe (KB)
#        - fsize - maximale Dateigröße (KB)
#        - memlock - max locked-in-memory Adress Raum (KB)
#        - nofile - max Anzahl offener Dateien
#        - rss - Maximal residente Speichnutzung (KB)
#        - stack - max Stack Größe (KB)
#        - cpu - max CPU Zeit (MIN)
#        - nproc - max Anzahl von Prozessen
#        - as - address space limit (KB)
#        - maxlogins - Maximale Anzahl der Logins für diesen User
#        - maxsyslogins - Maximale Anzahl der Logins auf diesem System
#        - priority - Die Priorität mit der die Prozesse des Nutzers laufen
#        - locks - Maximale Anzahl der Locks die der Nutzer erhalten kann
#        - sigpending - Maximale Anzahl der ausseteehden Signale
#        - msgqueue - Maxiamle Anzahl von Ques (bytes)
#        - nice - max nice Werte die mit renice erhöht werden können [-20, 19]
#        - rtprio - max Realzeit Priorität
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


**nohup <Befehl>** --> theoretisch kann das einne Zombie erzeugen wenn der Elternprozess stirbt
		   --> erlaubt einem Prozess auch nach dem beenden der Nutzer Session weiter zu laufen	

__Magic Sys-Abf Taste__
Ermöglicht das Senden von Signalen und Syscalls an den Rechner.

**(<Fn>)-<Alt>-<Druck>+<Tatse>**
<Tatse>:
R --> unraw, verlasse den Keyboard-Raw Modus in den X-Late Modus

K --> Beende alle Prozesse auf dem aktuellen Terminal

B --> Starte den Rechner neu

O --> Schaltet den Rechner sofort über ACPI/APM aus

S --> Schreibe allo noch verbeliebenden aus dem Kernelfestplatten Cache auf die Festplatte

U --> umount

M --> gebe die Hauotspeicherbelegung auf der Konsole aus

E --> Sende Signal 15

I --> Sende Signal 9 an alle Prozesse aus init

L --> wie I nur mit init

F --> töte den Speicherhungrigsten Prozess

D --> Zeige alle derzeitigen Locks an

Q --> Zeige alle derzeitigen Timer an

T --> Zeige Liste mit derzeit laufenden Prozessen

W --> Zeige Prozesse im derzeit geblockten Status an

N --> renice

H --> Hilfe

<Zahl> --> setzen des Kernel Loglevel

Die Befehlsfolge REISUB kann verwendet werden um den Rechner neuzustarten

!! Magic Sys Abf kann als Kernelparameter aktiviert und deaktiviert werden !!

**top** --> Zeigt eine interaktive dynamische Prozesstabelle an
-d --> die Anzahl der Sekunden nach der die Tabelle aktuallisiert wird
-p <PID0, PID1,..,PIDN> --> nur diese Prozesse beobachten
-n N --> Stope das Programm nach N Iterationen, Beispiel **htop -d 4 -n 2** wird das Programm nach 8 Sekunden beenden

<Navigation>
h --> hilfe
k --> Signal an Prozess senden
r --> Prozess Priorität ändern renice
t,l,m --> Zusammenfassung für load avg, task cpu stats,Speicher Informationenn an und ausschalten
d, s --> Update intervall setzen

Tipp:
**htop** --> schöneres top alias top='htop'
**iotop** --> I/O top welcher Prozess kratzt da auf der Platte herum
**iftop** --> Netzwerk top
**conky** --> mit der Sprache Lua anpassbares sparsames Desktop Widget mit **conkycolors**


__Kernel Thread__
+ sind Kindprozesse des Kernels die hardwarenahe Aufgaben übernehmen
+ werden zusammen mit dem Kernel Code im Ring 0 ausgeführt
+ erkennebar dass sie im Ring 0 laufen und und zusammen mit dem Kernel geladen werden
+ meistens in [] 
+ verbrauchen in der Prozesstabelle keinen zusätzlichen Speicher
+ Kernelthreads können keinen SIGKILL und keinen SIGTERM geschickt bekommen

Trick:
**ps -A u|awk '{ if($5 == 0){print }}'** --> Zeigt alle Kernelthreads an

===Partitionen und Dateisystmeme===

__interner Verschnitt__
!! Bei einer Blockgröße von 4 KiB belegt eine Datei mit 500 Bytes nur 1/8 eines Blocks. Effektiv verbraucht sie aber dennoch
einen 4 KiB großen Block. Kleinere Blockgößen sorgen für geringeren Platzverbauch, erhöhen aber die I/O-Zeit beim lesen 
und schreiben von Dateien !!

__beschränkungen beim Festlegen von Partitionen__
IDE/SATA	4 Primäre (max) 	3 Primäre und eine Extended und 63 logische (max)
SCSI		4 Primäre (max)		3 Primäre und eine Extended und 15 logische (max)


__Fesplattengeometrie__
+Daten auf Festplatte werden in Datenblöcken zu je 4 512 Bytes (nicht zu verwechseln mit der Blockgröße des Dateisystems)
+Durchnummerierung aller Schreiben 
+Kreisförmige Spuren
+Sektoren pro Spur

Dadurch lässt sich jeder Datenblock durch seine Kopf-, Zylinder- und Sektornummer identifizieren (CHS)
--> Cylinder Heads Sectors geometrisch

Logische Durchnummerierung der Datenblock (LBA)
--> Logical Block Adressing 

__Parttiotionen anlegen__
**fdisk /dev/sdX** --> ruft den Partitionierer fdisk auf um /dev/sdX zu formatiren
m --> zeigt Hilfe und verfügbare Optionen an
d --> löscht eine Partition
a --> setze das Bootflag für eine Partition (nicht immer sinnvloll)
p --> die Partitionstabelle anlegen

Workflow zum Anlegen einer neuen 2GB großen logischen ext3 Partition ungenutzten Plattenplatz vorrausgesetzt:
(1)fdisk /dev/sdX --> 
(2)n --> Wähle e für extendet 
(3)--> Wähle 1-4 für die Nummer der Parttition 
(4)--> Wähle Startzylinder (Vorgabe empfohlen)
(5) --> Wähle letzten zylinder (Vorgabe empfohlen) 
(6)--> n --> l für logische Partition 
(7)--> wähle Startzylinder (Vorgabe empfohlen) --> 
(8) +2G --> 
(9) Mit w Tabelle auf Datenträger schreiben und fdisk verlassen --> 
(9) mke2fs -j /dev/sdX5 --> fertig

Übersicht bekannter Parttionstypen:
0  Empty           24  NEC DOS         81  Minix / old Lin bf  Solaris        
 1  FAT12           39  Plan 9          82  Linux swap / So c1  DRDOS/sec (FAT-
 2  XENIX root      3c  PartitionMagic  83  Linux           c4  DRDOS/sec (FAT-
 3  XENIX usr       40  Venix 80286     84  OS/2 hidden C:  c6  DRDOS/sec (FAT-
 4  FAT16 <32M      41  PPC PReP Boot   85  Linux extended  c7  Syrinx         
 5  Extended        42  SFS             86  NTFS volume set da  Non-FS data    
 6  FAT16           4d  QNX4.x          87  NTFS volume set db  CP/M / CTOS / .
 7  HPFS/NTFS       4e  QNX4.x 2nd part 88  Linux plaintext de  Dell Utility   
 8  AIX             4f  QNX4.x 3rd part 8e  Linux LVM       df  BootIt         
 9  AIX bootable    50  OnTrack DM      93  Amoeba          e1  DOS access     
 a  OS/2 Boot Manag 51  OnTrack DM6 Aux 94  Amoeba BBT      e3  DOS R/O        
 b  W95 FAT32       52  CP/M            9f  BSD/OS          e4  SpeedStor      
 c  W95 FAT32 (LBA) 53  OnTrack DM6 Aux a0  IBM Thinkpad hi eb  BeOS fs        
 e  W95 FAT16 (LBA) 54  OnTrackDM6      a5  FreeBSD         ee  GPT            
 f  W95 Ext'd (LBA) 55  EZ-Drive        a6  OpenBSD         ef  EFI (FAT-12/16/
10  OPUS            56  Golden Bow      a7  NeXTSTEP        f0  Linux/PA-RISC b
11  Hidden FAT12    5c  Priam Edisk     a8  Darwin UFS      f1  SpeedStor      
12  Compaq diagnost 61  SpeedStor       a9  NetBSD          f4  SpeedStor      
14  Hidden FAT16 <3 63  GNU HURD or Sys ab  Darwin boot     f2  DOS secondary  
16  Hidden FAT16    64  Novell Netware  af  HFS / HFS+      fb  VMware VMFS    
17  Hidden HPFS/NTF 65  Novell Netware  b7  BSDI fs         fc  VMware VMKCORE 
18  AST SmartSleep  70  DiskSecure Mult b8  BSDI swap       fd  Linux raid auto
1b  Hidden W95 FAT3 75  PC/IX           bb  Boot Wizard hid fe  LANstep        
1c  Hidden W95 FAT3 80  Old Minix       be  Solaris boot    ff  BBT            
1e  Hidden W95 FAT1

**sfdisk** --> liest Parttionsinformationen aus einer Datei

**sfdisk -V** --> Statusinformationen über Partitionen anzeigen

**sfdisk -l** --> Auflisten vorhandener Platten auch nicht eingehängter

**smartctl -H /dev/sdX ** --> Smartwerte einer Platte auslesen (Ist die platte noch gesund? | funktioniert nicht für
Flashspeicher)

**partprobe** --> Kernelseitig die Partitionsdatbelle neu einlsen

**cfdisk** **Yast** **DiskDruid** **parted** --> Weitere Tools zur Partitionierung

__Parttionstypen__
82 --> Linux Swap
83 --> Linux 
8e --> Linux LVM
fd --> Linux raid


\\ /proc/partitions \\


__Dateien aus verlorenen Partitionen wiederrherstellen__
**testdisk** --> untersucht Festplatten nach verlorenen oder gelöschten Partitionen und stellt darauf befindliche 
Dateien wieder her

**photorec** --> stellt gelöschte Dateien wieder her falls diese nicht physikalisch überschrieben wurden

Tipp: Dateien unwiederherstellbar machen
+++++++++++++++++++++++++++++++++++++++++++
#!/bin/bash
#Script wird mit name partition aufgerufen
#Funktioniert am besten wenn Partition nicht vom System Kernel benutzt wird

mkdir $1/__wipe__
i=0
while true
	do
		i=$(($i+1))

		dd if=/dev/urandom of="/$1/__wipe__/$i" bs=4K count=20000 #bs an die Blockgröße des Dateisystems anpassen
			
	done
wipe -r $1/__wipe__ #wipe muss installiert sein
#Script läuft sehr lange 
+++++++++++++++++++++++++++++++++++++++++++

__Superblock__
Am Anfang des Dateisystems enthält Informationen über:
--> welches Dateisystem
--> wann wurde es zuletzte ein- und ausgehängt
--> Inodes | Anzahl freier und belegter Blöcke
--> Bootflag (Linux aus dem WindowsBootloader laden)

__Erstellen eines Dateisystems__
**mkfs -t <Dateisystem> </dev/sdx> --> erstelle auf </dev/sdX> ein Dateisystem vom Typ <Dateisystem>
--> ruft die entspechenden Programme auf die für die Parttionierung des entsprechenden Dateisystems verantwortlich ist
-c --> Das Dateisystenm auf defekte Blöcke überprüfen
-v --> verbose

**mke2fs </dev/sdX>** --> erstellen eines ext2|ext3 Dateisystems auf /dev/sdX
-b N --> Die Größe N pro Block
-c --> nach defekten Blöcken suchen
-i --> Inodedichte festlegen 
-m --> Anzahl der für root reservierten Blöcke setzen
-j --> erstellt ein journal und damit ein ext3 Dateisystem
-F --> Dateisysteme formatieren die keine Blockgeräte sind zum Beispiel ein Abbild eines Dateisystems

**tune2fs </dev/sdX>** -->  die Parameter der ext2|3 Partition /dev/sdX ändern
-c --> Wert nach wieviel Malen einhängen eine Datesystemprüfung stattfinden soll,0 bedeutet nie
-C --> Manipuliert den Wert der aktullen Zahl von EInhängevorgängnen
-e contunue|remount-ro|panic --> legt das verhalten beim Auftreten von Fehlern fest
	continue:normal weitermachen
	remount-ro: readonly mounten
	panic: Kernel panic ausgeben
-i --> wie -c in Tagen d, w wochen, m Monaten
-l --> listet die Informationen über den Superblock
-m --> wie -m bei **mke2fs**
-L <Name> --> <Name> der Partition (bis zu 16 Buchstaben)

**dumpe2fs </dev/sdX>** --> extrahieren von Dateisysteminformationen
-b --> print bad blocks
-i --> nutze eine Datei anstelle eines devices 
-o superblock --> angabe eines alternativen Superblocks
-o blocksize --> die blocksize des Dateisystems festlegen

**e2image </dev/sdX> <IMAGE>** --> speichern von kritischen Dateisystem Metatdaten

**mkreiserfs </dev/sdX>** --> auf /dev/sdX ein Dateisystem erstellen

**dumpreiserfs </dev/sdX>** --> Informationen über das Reiserdateisystem auf /dev/sdX auslesen

**resize_reiserfs** --> Größe der momentan nicht verwendeten Reiserpartition ändern

**reiserfstune** --> wie tune2fs nur für reiser \\ man reiserfstune \\

resierfs != reiser4 

**mkfs.vfat </dev/sdX>** --> **mkdosfs**
-F --> Fat Dateigröße (12, 16,32)
-c --> wie **mke2fs** nach defekten Blöcken suchen
-I --> Nutzer die ganze Platte als vFat normalerweise muss voher eine Partition angelegt sein
-n --> Volume Namen vergeben

**mkntfs </dev/sdX>** --> erstelle eine Ntfs Partioton auf /dev/sdX
-f --> Schnellformatierung
-L --> setzen eines Labels
-C --> Kompression auf dieser Partition aktivieren
-N --> Ntfs Version 1.2 (Windows NT) oder 3.1 (Windows XP, Vista, Server 2003)
-I --> indexing abschalten


__Dateien Statistiken über I-Nodes__
**stat <Datei>** --> gibt die Informationen über der Datei zugeordneten I-Node aus 

__Swappartition anlegen__
**mkswap </dev/sdX>** --> erstellt eine swappartition auf 
-c --> nach defeketen Blöcken suchen
-L --> setzen eines Labels

__Swappartitionen einhängen__
**swapon </dev/sdX>** --> Swapparttion aktiieren für /dev/sdX
-a --> alle in \\ /etc/fstab \\ eingetragenen Swapdevices aktivieren
-s --> liefert den Status des aktuellen Dateisystem


**swapoff </dev/sdX>** --> swappartition auf /dev/sdX einhängen|aktivieren


!! Kernel 2.4 beschränkt auf 8 Swaps mit jeweils 2 GB Größe !!
!! Kernel 2.6 beschränkt auf 32 Swaps beliebiger Größe !!

Tipp: Schnell mal den Swapspeicher vergrößern
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#!/bin/bash

double_swap()
{
SWAP_PART=$(tail -1 /proc/swaps | awk '{print $1}')

dd if="$SWAP_PART" of=/swapfile
swapon /swapfile

return $?
}


remove_swapfile()
{
if [-f /swapfile ]
	then
		swapoff /swapfile
		rm swapfile
fi
return $?
}

case $1 in
	on) double_swap || echo "failed"
	;;
	off) remove_swapfile || echo "failed"
esac

exit 0
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++



__Dateisystem auf Fehler überprüfen__
**fsck -t <Type> </dev/sdX>** -->Dateisystem <Type> auf </dev/sdX> überprüfen
-A --> alle Dateisysteme in der /etc/fstab
-M --> ignoriere eingehängte Dateisysteme
-R --> in zusammenhang mit -A ignoriere das /-Dateisystem
-a --> automatisch reparieren
-c --> nur checken
-r --> interaktives reparieren des Dateisystems
-y --> ja zu allem
-V --> verbose
-N --> simmulieren der AKtion
-p --> wie -ya

Exit Codes:
0	Kein Fehler im Dateisystem gefunden
1	Fehler im Dateisystem gefunden und korriegiert
2	Schwerwiegender Fehler im Dateisystem gefunden und korrigiert
4	Fehler im Dateisystem gefunden aber nicht korrigiert
8	Fehler beim Aufruf des Programms
16	Fehler in der Kommandozeile
128	Fehler in der Funktion der Shared Libraries
	
**debugfs </dev/sdX>** öffnete das Dateisystem auf </dev/sdX> im Debug Modus
-w --> Dateisystem ist auch schreibbar
-c --> Dateisystem im Katastrophen Modus starten
-s --> einen anderne Superblock angeben

__mounten von Dateisystemen__
**mount <Blockgerät> <Mountpoint>** --> hängt das <Blöckgerät> auf <Mountpoint> ein
-o --> Optionen an geben
-a --> alle Geräte in der /etc/fstab mounten
--bind --> Zwei Blockgeräte auf verschiedenen Mountpoints setzen


Aufbau \\ /etc/fstab \\:
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#Gerätedatei	 	#Mountpoint	#Dateisystemtyp	#Optionen	     #Reihenfolge des Checks beim Booten		
/dev/system/swap	  none                swap       defaults              0 0
/dev/system/root   	 /                    ext3       acl,user_xattr        1 1
/dev/disk/by-id/a...	 /boot                ext2       acl,user_xattr        1 2
/dev/system/home    	 /home                ext3       acl,user_xattr        1 2
/dev/system/tmp    	 /tmp                 ext3       acl,user_xattr        1 2
proc             	 /proc                proc       defaults              0 0
sysfs             	 /sys                 sysfs      noauto                0 0
debugfs           	 /sys/kernel/debug    debugfs    noauto                0 0
usbfs              	 /proc/bus/usb        usbfs      noauto                0 0
devpts              	 /dev/pts             devpts     mode=0620,gid=5       0 0
Alucard:/media/Elements	 /srv/nfs	      nfs	 rw,... #man 5 nfs	
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

auto == Dateisystem wird aus \\ /etc/filesystems \\ oder \\ /proc/filesystems \\ ermittelt
acl == ACL aktiviert
async == Synchronisation zwischen Dateisystemen 
user_xattr == erweitere Attribute für den User
noauto == Dateisystem wird nicht automatisch eingehängt
noatime == I-node Zugriffszeit nicht aktuallisieren
defaults == dasselbe wie rw, suid, dev, exec, auto, nouser, und async
dev|nodev == interpretiere Zeichen- oder Blockorientierte Geräte auf diesem Dateisystem
exec|noexec == erlaube | verbiete das Dateien ausgeführt werden dürfen
suid == erlauben setuid setgid
rw|ro == schreibbar|nur lesbar
user == nutzer kann Dateisystem einhängen aber nur der nutzer der es eingehängt hat darf es auch wieder aushängen
users == alle dürfen ein und aushängen
usrquota | grpquota == Plattenkontingente aktivieren

nodev == verhindert das Anlegen von device Dateien (sinnvoll für /home)
nosuid == unterbindet das Ausführen von setuid Programmen (sinnvoll für /home und /tmp)
noexec == unterbindet das Ausführen von ausführbaren Programmen (sinnvoll für /tmp)

remount == Platte neu einhängen (nur sinnvoll wenn man mount manuell nutzt)
z.B. mount -o remount,ro /pladde --> mounted die /pladde nun aber readonly 

**mount <Mountpoint>** --> falls Eintrag in \\ /etc/fstab \\ 
** mount <Device>** --> falls Eintrag in \\ /etc/fstab \\

__aktuelle Geräteinformationen ausgeben lassen__
**blkid [</dev/sdX>]** --> gibt Informationen über die aktullen Geräte oder über Gerät /dev/sdX aus

Trick iso mounten:
++++++++++++++++++++++++++++++++++
mount -o loop,ro mycd.iso /home/iso
++++++++++++++++++++++++++++++++++

__Labels und UUIDs vergeben__
!! Ein Label ist ein im Superblock abgelgter Text von maximal 16 Zeichen !!

**e2label </dev/sdX> <Label>** --> das Gerät </dev/sdX> erhält das <Label>

**tune2fs -U random </dev/sdX>** --> ein neues zufäliig erzeugtes Label vergeben

Trick UUID eines Gerätes auslesen:
++++++++++++++++++++++++++++++++++++++
tune2fs -l </dev/sdX> | grep UUID
++++++++++++++++++++++++++++++++++++++

\\ /dev/disk/by-uuid \\

!! Labels und UUIDs können im ersten Feld der \\ /etc/fstab \\ als Identifier verwendet wrerden !!


__Auslastung von RAM Und Swap vergleichen__
**free** --> zeigt die Auslastung des Arbeitspeciher und er Festplattenbelegung an
-m --> in Magebytes
-k --> in Kilobites
-g --> in Gigabites abgerundet und daher sinnlos

__Mit dd Teile oder ganze Festplatten spiegeln__
**dd if=<INPUT> of=<OUTPUT> bs=<Blockgröße> count=<Zähler>

**dd if=/dev/sdX of=/mnt/Backup/sdX.dump** --> erstellt eine Abbilddatei von /dev/sdX als Datei /mnt/Backup/sdX.dump

**dd if=/dev/sda1 of=/dev/sdb1 bs=4096 conv=notrunc** --> Spiegeln einer Partition auf eine andere
						      --> conv=notrunc bewirkt hier dass die /dev/sda1 als eine ganze Datei
							  übertragen wird

**dd if=/mnt/Backup/sdX.dump of=/dev/sdX** --> spielt das Image zurück

Tipp: Um Platz zu sparen nutzt man lieber **mondo** und **mindi** die nur belegte Blöcke spiegelen
Tipp: bei defekten Platten, solche die Unakzeptabel hohe Amzahl von defekten Blöcken aufweisen nimmt man besser **dd_rescue**

**dd if=/dev/sda of=/mnt/Backup/mbr_sda.dump bs=512 count=1** --> sichert den MBR
**dd if=/mnt/Backup/mbr_sda.dump if=/dev/sda** --> stellt den MBR wieder her

**dd if=/dev/sda of=/mnt/Backup/bootloader.dump bs=446 count=1** --> sichert den Bootloader

**dd if=/dev/sr0 of=/home/User/dvd.iso** --> erstelle ein Mountbares Image einer eingelgten DVD

__Quatos einrichten__
**quotacheck** --> Quotas neu initialisieren, dabei wird der Wert des Dateisystems mit dem der Quota abgeglischen
-b --> eine Bacup der alten Quotadatei erstellen
-v --> verbose
-a --> alle eingehängten Dateissysteme die Quaotas akitviert haben
-u --> nur Quotas der aktuellen Nutzer 
-g --> nur Quotas der aktuellen Gruppe
-i --> interaktiver Modus 
-R --> nur mit -a, root auschließen


**quotaon** --> Quotas aktivieren

**quotaoff** --> Quotas deaktivieren

**edquota -u <User>** --> die Quotas für den aktuellen <User> editieren

**edquota -t** --> die Grace Periode bearbeiten

**repquota** --> Quotas anzeigegen lassen
-a --> für alle
-g --> für Gruppen
-u --> für User (Standardverhalten)

**quota** --> Quota für bestimmte User ausgeben, kann auch von Nutzern ausgeführt werden

Quotas einrichten Workflow:
(1) nachinstallieren der entsprechenden Pakete 
(2) Eintragen der entsprechenden Optionen in die \\ /etc/fstab \\ 4. Spalte
    
usrquota 
grpquota  
    
In den Dateien aquota.user, aqouta.group werden die Quotas verwaltet.

Neuer sind journaled Quotas die nach einem unsauberen Ausschalten das durchlaufen von **quotacheck** abnehmen.  	
Ausserdem arbeiten diese besser mit den Dateisystemen ext3, ext4 zusammen und beschleunigen das Hochfahren des Rechners.

grpjquota=aquota.group
usrjquota=aquota.user
jqfmt=vfv0

(3) Blöcke_INSGESAMT mittles df ermittln
(4) Quota berechenen: (%(der Blöcke Harte Grenze)* Blöcke_INSGESAMT)/100=y
(5) edquota -u <User> Quota Tabell mit den Wert y für <User> editieren
(6) edquota -u <User> <Anderer User> Möglicherweise weitere User hinzufügen
(7) In Runlevel S wechseln, alternativ init 6
(8) remount der Platte **mount -o remount,<Quotamode> /home
(9) **/etc/init.d/boot.quota restart** ausführen
(10) quotacheck -avu die Quotadatenbank neu initilisieren (nur notwendig (9) nicht durchgeführt wurde)
(11) quotaon -avu die Quota einschalten (nur notwendig falls (9) nicht durchgeführt wurde)

!! Auf Platten auf die Ständig geschrieben wird wie auf /home wird man ohne Neustart nicht klarkommen !!


===Linux booten===
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx11223344x
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx11223344x MBR
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
^                                                    ^
|                                                    |
446 Bytes Bootlaoder                              4 * 16 Bytes Partitionstabelle

für EFI Support enable beim Kernelbau
CONFIG_EFI_PARTITION=y

__Funktion des Bootlaoder Lilo|Grub__
--> Kernel finden und in den Ram laden
--> Verwalten meherer Betriebssysteme 
**GRUB** **LILO** **ISOLINUX**

__GRUB__
\\ /boot/grub/menu.lst \\
# Modified by YaST2. Last modification on Thu Jul  8 09:05:40 CEST 2010
# THIS FILE WILL BE PARTIALLY OVERWRITTEN by perl-Bootloader
# Configure custom boot parameters for updated kernels in /etc/sysconfig/bootloader

default 0  <-- Wenn keine Auswahl nach timeout erfolgt wird dieser Systemabschnitt gestartet
timeout 4  <-- timeout bis zum Start des Standardabschnitt
password --md5 x <-- Benutze md5 Algorhithmus um den Bootloader durch ein Passwort zu schütern **grub-md5-crypt**
##YaST - generic_mbr
gfxmenu (hd0,0)/message
##YaST - activate

#0
###Don't change this comment - YaST2 identifier: Original name: linux###
title openSUSE 11.2 - 2.6.31.12-0.2 
    root (hd0,0)
    kernel /vmlinuz-2.6.31.12-0.2-default root=/dev/system/root resume=/dev/system/swap splash=silent quiet showopts vga=0x314
    initrd /initrd-2.6.31.12-0.2-default

#1
###Don't change this comment - YaST2 identifier: Original name: failsafe###
title Failsafe -- openSUSE 11.2 - 2.6.31.12-0.2
    root (hd0,0)
    kernel /vmlinuz-2.6.31.12-0.2-default root=/dev/system/root showopts apm=off noresume nosmp maxcpus=0 edd=off powersaved=off nohz=off highres=off processor.max_cstate=1 x11failsafe vga=0x314
    initrd /initrd-2.6.31.12-0.2-default

Parmeter:
default --> Wenn keine Tastatureingabe wird nach timeout diese Sektion gestartet
timeout --> In Sekunden gibt an, nach wieveil Sekunden default Abschnitt gestartet wird
title --> Betriebssystemeintrag der als Auswahl im Menu beim Booten angezeigt wird
kernel --> den zu bootenden Kernel
root --> das Root Dateisystem 
chainloader +1 --> Bezeichnet einen von einer Fremd-Partition zu ladenden Bootloader

initrd --> die intiale RAM-Disk aus der diverse Kernelmodule gestartet werden
**grub-md5-crypt** --> erstellt den Hashwert der dann in \\ /boot/grub/menu.lst \\ in der Sektion password -md5 eingetragen
wird


__Grub neu installieren__
in Opensuse:
**grub --batch --device-map=/boot/grub/device.map < /etc/grub.conf** --> Grub wiederherstellen falls dieser überschrieben
wurde

**grub** --> die Grubshell aufrufen
\\ info grub \\


__grub Shell benutzen__
**grub** --> ruft die Grubshell auf, inder man grub installieren oder reparieren kann
	 --> im Bootloader Menu über c, respektive p (falls Passwort geschützt) aufrufen

Trick in der GrubShell:
grub> find /boot/vmlinuz --> findet die Partition mit einem gültigen Linux Kernel Image
(hd0,0)

grub> kernel /boot/vmlinuz root=/dev/sdX --> festlegen des Kernel Images
Linux-bzImage setup=0x1400 size=0x11d3e7

grub>initrd /boot/initrd                 --> festlegen einer gülitgen initial Ramdisk  
[Linux-initrd @ 0x5f71000,0x7e864 bytes]

grub>boot --> bootet den konfigurierten Kernel im Bootloader Menu

grub neu installieren
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
grub> root (hd0) --> sagt grub wo es nach dem root Dateisystem / suchen soll
grub>setup (hd0,0) --> konfiguriert und installiert den neunen Kernel in den bootloader der ersten partition
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Fehlermeldung von GRUB interpretieren:
Hard Disk Error		Fehler, möglicherweise is der MBR oder die Platte beschädigt
Read Errror		die zweite Stufe konnte nicht gelesen werden
Geom Error		Partitionierungsfehler, falsches Partition die auf / verweist, defekte Parttionstabelle

**info grub link troubleshooting**   

__lilo__
+ Bootloader der nur in den MBR installiert werden kann
+ nach Änderung der Konfigurationsdatei muss **lilo** ausgeführt werden

\\ /etc/lilo.conf \\
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
prompt
tineout=50  #Timer für den Bootprozess
default=linux #verweist auf den Identifier label, der das zu startende System indetifiziert, wenn  der timeout 
	      #abgelaufen ist

boot=/dev/hda4 #verweist auf das gerät auf dem das /boot Gerät angehängt ist
install=/boot/boot.b         #Pfad zum 2nd Stage Bootloader

iamge=/boot/vmlinuz-2.4.7-10 #Pfad zum Kernel Image 	
	label=linux	     #Identifier für Image	
	initrd=/boot/initrd-2.4.7-10.img    #Initial Ram Disk
	read=only			    #read only	
	root=/dev/hda9	     #Verweis auf das / Verzeichnis  			 	
	append=""	     #Kernelparamter übergeben	

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++



Fehlermeldung von LILO interpretieren:
L 	1st Stage wurde geladen und gestartet, wird zusammen mit einer Fehlermeldung in hexadezimal ausgegeben
	kann einen BIOS Fehler Indikator sein
L 00   internal error
L 01   illegal command
L 02   address mark not found
L 03   write-protected disk
L 04   sector not found
L 06   change line active
L 07   invalid initialization
L 08   DMA overrun
L 09   DMA attempt across 64k boundary
L 0C   invalid media
L 10   CRC error
L 11   ECC correction successful
L 20   controller error
L 40   seek failure
L 80   disk timeout
L BB   BIOS error

LI	2nd Stage wurde geladen
LIL	2nd Stage wurde gestartet
LIL?	2nd Stage wurde in einen fehlerhaften Adressbereich geladen, kann auf Fehlerhaften Speicher schließen
LIL-	2n Stage wurde mit einem Fehlerhaften File Descriptor geladen
LILO 	Keine Fehler, LILO ist normal gestartet

__Allgemeine Bootoptionen__
ro --> veranlasst den Kernel, die /-Partition nur lesbar einzuhängen

rw --> veranlasst den Kernel, die /-Partition mit schreibberechtigung einzuhängeden Kernel, die /-Partition mit 
Schreibberechtigung einzuhängenn

init=<Programm> --> startet das Programm anstelle von /sbin/init 
init=/bin/sh --> startet eine minimale eingeschränkte Shell zur Systemreperatur nachdem der Kernel geladen wurde

single --> Startet den Einzelbenutzermodus

maxcpus=<N> --> verwende nur N der zur Verfügung stehenden CPUS/CPU-Kerne

panic=<N> --> Im Falle eines Kernel Panics wird nach N Sekunden ein Neustart erzwungen, sinnvoll wenn man das Problem
genau analysieren möchte 

noapic, apic=off, acpi=off --> Schaltet einige der Kernel Features ab, die Probleme bereiten könnten

vga=<Videomodus> --> festlegen des Videopmodus für verwendeten Termeinals 

console=tty,9600 --> festlegen einer Konsolen auf einem Seriellen Port, 9600 ist eine der Geschwindigkeiten

netdev=<irq>,<io>,<mem_start>,<mem_end>, <name> --> Einstellungen an Netzwerkkarten erzwingen

nosmp --> Abschalten des Symmetric Multi Prozessing, unterstützung für mehrere Prozessoren abschalten

\\ /usr/src/linux/Dokumentation/kernel-parameters.txt \\ 

===Logging und Fehleranalyse===

__Fehler beim Booten analysieren__
**dmesg <Optionen>** --> Kernel logging Informationen
-c --> den Rinbuffer leeren

**dmesg|less** --> analysieren der kompletten Systemnachrichten auch die im frühen Bootstadium

Tricks:
**dmesg|grep fail** --> sucht nach Problemen
**dmesg|grep "\<E\:.*\>"** --> nach E: was ein Indikator für Fehler sein kann

___Logfiles interaktiv lesen__
**tail -f <Logfile>** --> zeigt die letzten 10 Zeilen von logfile und alle neu hinzukommenden

===Rettungsanker===

__In ein ungemountetes System Chrooten__
(1) Mounten der Platte mit dem Defekten Betriebssystem von Live CD  **mount /dev/sdX /mnt/system**

(2) Falls das System zusätzliche Partitionen wie /boot oder /usr beinhalten werden diese nun einghängt
    **mount /dev/sdX{1,5,6} /mnt/system/{boot,usr,tmp}** 

(3) **mount -o bind /dev /mnt/system/dev**

(4) **mount -o bind /sys /mnt/system/sys**

(5) **mount -o bind /proc /mnt/system/proc**

(6) erstellen der /etc/mtab auf dem chroot system 
    **cp /mnt/proc/mounts /mnt/system/etc/mtab**

(7) kopieren der resolv.conf 
    **cp /etc/resolv.conf /mnt/system/etc/resolv.conf**

(8) Einsetzen des Changeroots und festlegen der verwendeten Shell **chroot /mnt/system /bin/bash**

(9) Durchführen der Systemarbeiten

(10) Verlassen des chroot und syncen der Platte 
	**sync** 
	**exit** 

===Sys V init und der Init Prozess===

__Init__

+\\ /sbin/init \\ PID 1 
+kann nicht mit  kill -9 beendet werden
+über %Runlevel% wird der Zustand des Systems genauer festgelegt:
A,B,C --> Bedarfsrunlevel die den Zustand des Systems nicht ändern
N --> kein vorheriger runlevel. Ist der Standardrunlevel aus dem init in die runlevel S beim Starten wechselt
S --> wird beim Starten durchlaufen, bevor das System in einen der Runlevel 2 bis 5 übergeht (Systemreperaturmodus andere)
0 --> entspricht im wesntlichen dem nicht vorhandensein eines Runlevels also dem Halt des Systems **shotdown -h**
1 --> Einzelbenutzermodus ohne Netzwerk (Systemreparaturmodus Debian) 
2 --> Mehrbenutzer ohne Netzwerk
3 --> Mehrbenutzer mit Netzwerk (Standardrunlevel bei Servern)
4 --> Nicht benutzt / frei Konfigurierbar
5 --> Wie 3 mit grafischer X Umgebung
6 --> Neustart des Systems 

Die Datei \\ /etc/inittab \\:
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ #Standard-Runlevel                                                                      +
+ id:5:initdefault #Dieses runlevel wird gestartet wenn der Rechner hochgefahren wird     +
+                                                                                         +
+ #Erstes auszuführendes Script                                                           +
+ si:bootwait:/etc/init.d/boot                                                            +
+                                                                                         +
+ # Runlevels                                                                             +
+ #<Etikett>:<Runlevel>:<Aktion>:<Befehl>                                                 +
+ l0:0:wait:/etc/init.d/rc 0                                                              +
+ l1:1:wait:/etc/init.d/rc 1                                                              +
+ l2:2:wait:/etc/init.d/rc 2                                                              +
+ l3:3:wait:/etc/init.d/rc 3                                                              +
+ l4:4:wait:/etc/init.d/rc 4                                                              +
+ l5:5:wait:/etc/init.d/rc 5                                                              +
+ l6:6:wait:/etc/init.d/rc 6                                                              +
+                                                                                         +
+ #Ctr-Alt-Del                                                                            +
+ #Was passiert wenn man Strg-Alt-Entf drückt                                             +
+ ca:ctraltdel:/bin/true                                                                  +
+                                                                                         +
+ # Terminals                                                                             +
+ #<Terminal Nr>:<Runlevel>:<Aktion>:<Befehl>                                             +
+ 1:2345:respawn:/sbin/mingetty --noclear tty1                                            +
+                                                                                         +
+ samS:A:ondemand:rcsmb start && rcnmb start  #Samba bei bedarf starten und  stoppen      +
+ samK:B:ondemand:rcsmb stop && rcnmb stop                                                +
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
<Etikett>: Dient zur eindeutigen Identifikation des Feldes, bei Terminals werden die Namen des betreffenden Gerätes
	bezeichnet

<Runlevel>: Bezeichnung des Runlevel 0 bis 6

<Aktion>: Beim Aufruf dieses Runlevels/Terminals soll diese Aktion ausgeführt werden
	**respawn**     --> Der Prozess wird sofort wieder neu gestartet falls er sich beendet hat
	**wait**        --> Prozess wird einmal gestarte, warten auf Fertigstellung
	**bootwait**    --> Prozess wird beim Booten ausgeführt, init warte auf Fertigstellung
	**initdefault** --> Prozess ist nun Standardrunlevel
	**ondemand**    --> Prozess wird ausgeführt ohne das Init den Runlevel wechselt

<Befehl>: Führe folgenden Befehl aus
	--> /etc/init.d/rc --> führt die unter /etc/init.d/rc(0-S).d Scripte aus
		Sn --> Startscripte, werden beim Starten in numerisch aufsteigender n Reihenfolge gestartet
		Km --> Stopscripte, werden bei Stoppen in numerisch aufsteigender Reihenfolge beendett
			z.B. /etc/init.d/rc5.d/S01acpid --> als erstes beim Starten
			     /etc/init.d/rc5.d/K09SuSEfirewall2_init --> als 9.tes beim Stoppen	

RUNLEVEL --> Umgebungsvariable, die den gestarteten RUNLEVEL enthält

__Beim Starten in den Wartungsmodus gelangen__
+ Durch Anhängen an die Bootoptionen im Grub Startbildschirm von
	*-s --> starten des Runelevels S, single wird entsprechend der \\ /etc/inittab \\ gestartet
	*-b --> starten des Runlevels S ohne die \\ /etc/inittab \\ zu starten

+ Durch eintragen von 
**init=/bin/sh** --> wird eine RootShell ohne Passwortabefrage gestartet
		 --> dabei wird der init Prozess durch die Shell /bin/sh ersetzt		
		 --> eine Verarbeitung der \\ /etc/inittab \\ findet nicht statt

__Den runlevel wechseln__
**init <M>** --> schaltet in den runlevel <M> 
-t N --> N Sekunken zwischen dem Schicken von SIGTERM Und SIGKILL verstreichen lassen

**init <a,b,c>** --> wechseln in einen ondemand Runlevel, welcher den init Prozesszustand nicht verädnertb

**init <q,Q>** --> neu enlesen der \\ /etc/inittab \\, wenn man zum Beispiel Ctr-Alt-Del geändert hat

**runlevel** --> zeigt das vorherige und aktulle runlevel des Systems an

__Dienste manuell starten und stoppen__
** \\ /etc/init.d/<Dienst> <start,stop,status,reload,restart>**
start --> Dienst starten
stop --> Dienst stoppen
status --> fragt den Status des Dienstes ab
reload --> liest die vom Dienst benötigten Konfigurationsdateien ein
restart --> den Dienst neu starten == stop && start

Tipp:
**ln -s /etc/init.d/<Dienst> /etc/init.d/<K<N>Dienst>**
**ln -s /etc/init.d/<Dienst> /etc/init.d/<S<N>Diens>t**
Hinzufügen des Dienstes zu einem Runlevel, wobei <N> die Reihenfolge definiert, wann der Dienst gestartet oder gestoppt
werden soll, wenn man sich unsicher ist, sollte man eine höhrere Zahl als die zu nutzen, die bereits vergeben wurden


__Hinzufügen und erstellen eines eigenen Dienstes_
\\ /etc/init.d/skeleton \\ --> Gerüstdatei für das Hinzufügen eines eigenen Dienstes

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
### BEGIN INIT INFO
# Provides:          daemon
# Required-Start:    $required_before_start
# Required-Stop:     $required_before_stop
# Default-Start:     3 5
# Default-Stop:      0 6
# Short-Description: daemon providing foo by bar
# Description: daemon foo with  bar doing baz
### END INIT INFO
DIENST=/usr/bin/daemon
LOGFILE=/var/log/daemon
PIDFILE=/Var/run/daemon.pid


case $1 in
	start) #starten des Prozesses
	       #nicht daemonen sollten mit & in den Hintergrund geschickt werden
	       #Programme die eine Systemänderung bewirken sollten ihren alten Status ablegen damit er durch stoppen 
	       #des Dienstes wiederhergestellt werden kann
	       #Fehlerausagben des Scripts gehören nach /dev/null oder nach LOGFILE	
	       #Ablegen einer Prozess-ID in einer Datei PIDFILE=/var/run/daemon.pid	
	;;	
	stop) #beendet des Proezesses mit kill
	      #zurücksetzen des alten Status falls das Programm eine Systemveränderung bewirkt
	      #löschen nicht mehr benötigter Dateien inklusive /var/run/daemon.pid
	;;
	status) #Auswerten des Statuses des Prozesses durch parsen von PIDFILE
	;;
	resart) #falls dienst schon gestartet: stop && start 
		#andernfalls start
	;;
	reload) #Daemon soll Konfigration neu einlesen zum Beispiel durch senden von SIGHUP (1) PIDFILE
		#Statusänderungen am System sollen erneuert werden
	;;
	force-reload) #Daemon soll Konfiguration neu einlesen oder restart ausführen, falls ersteres nicht möglich
	;;
	*) #Was soll geschehen wenn etwas anderes auferufen wird
exit 0 #Scripte enden immer mit einem Rückagbewert von 0 wenn sie erfolgreich waren
       #Misserfolg sollte vorher abgefangen werden
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
**start_daemon -p <PIDFILE> "<DIENST>" "<Argummente>** --> starten eines Daemons 
					         --> Angabe eines PIDFILE, Name des DIENST und deren OPTS 
						 --> senden von Nachrichten an den Syslogdaemon


**pidofproc <Pfad zum Programm>** --> Prozessinformationen zu einem bestimmten Programm im Pfad anzeigen
				  --> ohne Optionen wird PID zurückgeben

**checkproc <PFAD zum Programm> --> wie **pidofproc**, $$SUSE$$

-p <PIDFILE> --> eine anderes PIDFILE als das unter \\ /var/run/daemon.pid \\ 
-n --> einen Kernelthread verfolgen

**killproc <Pfad zum Porgramm>** --> Signal an einen über Pfad aufgrufenen Prozess senden
-G --> sendet ein Signal auch an alle Kindprozsse des identifizierten Prozesses
-L --> folge symbolischen Links
-p PIDFILE --> Angabe eines PIDFILE
-n --> einen Kernelthread ein SIGNAL schicken
-v --> verbose

**startproc -p <PIDFILE> <Pfad zum Dienst> <Argumente und Optionen>**  --> starten eines Daemons 
-n <-19 bis 20> --> einen Nicewert vergeben, nur root kann negative Nicewerte vergeben
-g <GID> --> setzen der GID für den zu startenden Prozess
-l <LOGFILE> --> Angabe eines Logfiles
-q --> Ausgabe unterdrücken, be quiet
-s --> Prozess wird in einer neuer Session gestartet
-t <secs> --> Programm <secs> Sekunden warten lassen
-u <UID> --> setzen der UID für den zu startenden Prozess


**startpar <prg1> <prg1> ...** --> mehrere init Prozesse parallel starten
-p N --> setzen des Grades der Parellität
-i M --> Threading I/O setzen
-M --> make Verhalten

__Einen Dienst mittel chkconfig zu einem Runlevel hinzufügen__
$SUSE:$ **insserv </etc/init.d/<Dinest>** --> fügt den <Dienst> hinzu und löst dabei die Startabhängigkeiten auf
					   --> Das Standardrunlevel wird ermittelt 
-v --> verbose
-n --> nur testen nichts machen
-r --> das Script aus allen Runlevel entfernen
-d --> Nutze das Standardrunlevel, löscht links aus anderen Runlevels
-f --> Falls ein benötigter Service fehlt, füge trotzdem den Prozess hinzu

$Fedora$ | $SUSE$ **chkconfig**
**chkconfig** --> Auflistung aller aktuellen Runlevel Konfigurationen
		-A --> auch die Dienste listen de nur zur Bootzeit ausgeführt werden

**chkconfig <Dienst>** --> Auflistung der aktuellen Runlevel Konfiguration für <Dienst>

**chkconfig -t <Dienst2> <Dienst1>** --> Auflistung der aktuellen Runlevel Konfiguration für <Dienst1> und <Dienst2>

**chkconfig <Dienst> on** --> <Dienst> wird ab dem nächsten Bootvorgang automatisch gestart 

**chkconfig <Dienst> <N><M>...** --> <Dienst> wird ab dem nächsten Bootvorgang den Runlevel <N>,<M>,... hinzugefügt

**chkconfig <Dienst> off** --> <Dienst> wird ab dem nächsten Bootvorgang deaktivert

**chkconfig <Dienst> xinetd** --> Einen xinetd Service konfigurieren

**chkconfig -A >~root/chkconfig.save** --> Die aktuelle Konfiguration sichern

**chkconfig -s <~root/chkconfig.save** --> Eine Konfiguration aus einer gesicherten Datei wieder herstellen

-e --> Konfiguration interaktiv bearbeiten

__Einen Dienst kurzfirsitg aktivieren/deaktieren oder deren satatus abfragen__
**service <Daemon> on|off|status** --> den Daemon verwalten
on --> einschalten des Dienstes
off --> abschalten des Dienstes
status --> Statusabfrage


$Debian$ **update-rc.d** 
**update-rc.d <Dienst> defaults** --> <Dienst> wird den Runleveln 2,3,4 und 5 hinzugefügt. In 0,1 und 6 wird der Dienst
gestoppt


__Systemwartungsmodus__
**init s** --> Schaltet in den Systemwartungsmodus
+Nur root ist angemeldet, andere User sind nicht erlaubt
+<Alt>-<Strg>-<Fx> ist nicht möglich **screen** verwenden

**screen** --> Verwalten von virtuellen Terminals
	   --> Initialisieren des ersten virtuellen Terminals
<Strg>-<A>-c --> Ein neues Terminal erzeugen
<Strg>-<A>-<N> --> Auf Terminal <N> zugreifen (N=0 bis 9)
<Strg>-<A>-k --> Virtuelles Terminal beenden
	
__Herunterfahren und Neustarten__
**shutdwon <Option> <Time>** --> herunterfahren oder Neustarten nach <Time> Sekunden
<Option>
-h --> System halt
-r --> reboot
-c --> letzte Aktion rückgängig machen
-k --> nichts machen, nur testen
-f --> fsck wird in jedem Fall übersprungen
-F --> fsck wird auf jeden Fall ausgeführt beim nächsten mal Booten

<Time>
now --> sofort
12:23 --> um 12:23 Uhr
150 --> in 150 Minuten 

**shutdown -h now** == **init 0**
**shutdown -r now** == **init 6**

__Kernel austauschen__
    + Ein Neustart läuft schneller ab.
    + Das BIOS hat keine Möglichkeit, sie mit Fehlern zu nerven.
    + Das obige trifft vor allem zu, wenn Sie FakeRAID-Controller benutzen.
    + Sie müssen nicht warten, bis der SCSI-Controller alle Geräte durch gezählt hat.
    + Sie sind nicht von einer funktionierenden GRUB- oder LILO-Konfiguration abhängig.
    + Sie könnten es auch dazu missbrauchen, eine neue Version von SUSE Linux zu Installieren, ohne das System von einer CD, DVD oder Diskette zu starten
    + Sie können dem Kernel vorgeben, im Fall einer Kernel Panik über Kexec neu zu starten, wodurch auch entfernte Systeme auf schnellstem Weg neu starten. 

**kexec** --> Im laufenden Beterieb den aktuell laufenden Kernel durch einen anderen ersetzen
**kexec -l --command-line="`cat /proc/cmdline`" --initrd=/boot/initrd /boot/vmlinuz**

__Shutdown Prozess__
(1) Mitteilung an Nutzer über Shutdown
(2) Anlegen der \\ /etc/nologin \\, die login darin hindert dass neue User (außer root) sich anmelden können (beim erneuten Starten gelöscht)
(3) Alle Dienste werden gemäß den \\ /etc/init.d/rc.0\KSript \\ beendet
(4) Senden von Signal 15 (SIGTERM) an alle verbeleibenden Prozesse und warten
(5) Senden von SIgnal 9 (SIGKILL)  an alle verbleibeneden Prozesse
(6) Aushängen der Dateisysteme
(7) Senden des APM/ACPI Signals an den Rechner zum Abschalten des Rechners 

===Hardware und Hardware-Informationen===

__IRQ__
+ Interupt Request ein Signal das an die CPU gesendet wird und die aktuellen Prozess unterbricht
+ Request auf ein externes Hardware Ereignis zu lauschen und zu bearbeiten

0	System Timer	
1	Keyboard	
2	Cascade um IRQs 8-15 benutzen zu können
3	Zweiter RS-232 serieller Port (COM 2)
4	Erster RS-232 serieller Port (COM 1)
5	Sound Karte oder zweiter paralleler Port (LPT2)
6	Floppy Disk Controler
7	Erster paralleler Port (LPT 1)
8	Real Time Clock
9-11	Freier Interrupt
12	PS/2 Mouse
13	Mathemathischer Coprozessor
14	Erster ATA Controler \\ /dev/sda \\ \\ /dev/sdb \\ 
15	Zeiter ATA Controler \\ /dev/sdc \\ \\ /dev/sdd \\	 	

\\ /proc/interrupts \\ --> liste der momentan vom Kernel genutzten Interrupts

\\ /proc/dma \\ --> die benutzten DMA Kanäle

**uname** --> Informationen zum verwendeten System erhalten
-n --> Zeigt den Namen, meistens den HostNamen des Systems an
-s --> Zeigt den Namen des Kernels an, unter Linux wird Linux ausgegeben
-r --> Zeigt den Namen des Kernels mit vollständeiger Versionsnummer an
-v --> Zeigt Informationen über das Datum des eingesetzten Kernels an
-m --> Zeigt Informationen zum verwendeten Architekturtyp an, dies muss nicht zwingend der Reale Archirekturtyp sein
-p --> Zeigt den verwendeten Prozessortyp an
-i --> Zeigt die verwendete Hardwareplattform an
-o --> Zeigt das verwendete Betriebssystem an, unter Linux ist das GNU/Linux
-a --> wie -nsrvmpio

**setpci** --> konfigurieren von PCI Geräten und Abfrage von konfigurierten PCI Geräten
-v --> verbose und Informationen über PCI Geräte Konfiguration 


**lspci** --> listet die vorhandenen PCI Geräte auf 
-v --> ausführliche Ausgabe
-vv --> noch ausführlicher
-vvv --> noch viel ausführlicher
-n --> schauen nicht \\ /usr/share/pci.ids \\ nach
-t --> zeigt die Abhängigkeiten der einzelenen PCI-Geräte in einer Baumansicht
-m --> dump pci geräte daten
-mm --> dump der pci geräte daten in script lesbarer form
-k --> zeige die kernel-module an die von den entsprechenden geräten verwendet werden
-x --> hexdump der einzelnen Geräte
-b --> BUS Cetnrtic view, ohne den Kernel zu fragen, es wird nur der PCI BUS gedumpt

>> 
#PCI-ID
00:00.0 Host bridge: Intel Corporation 82852/82855 GM/GME/PM/GMV Processor to I/O Controller (rev 02)
00:1f.3 SMBus: Intel Corporation 82801DB/DBL/DBM (ICH4/ICH4-L/ICH4-M) SMBus Controller (rev 01)
00:1f.5 Multimedia audio controller: Intel Corporation 82801DB/DBL/DBM (ICH4/ICH4-L/ICH4-M) AC'97 Audio Controller (rev 01)
00:1f.6 Modem: Intel Corporation 82801DB/DBL/DBM (ICH4/ICH4-L/ICH4-M) AC'97 Modem Controller (rev 01)
02:00.0 CardBus bridge: Texas Instruments PCI4510 PC card Cardbus Controller (rev 03)
02:00.1 FireWire (IEEE 1394): Texas Instruments PCI4510 IEEE-1394 Controller (rev 01)
02:01.0 Ethernet controller: Intel Corporation 82541GI Gigabit Ethernet Controller
02:02.0 Network controller: Intel Corporation PRO/Wireless 2200BG [Calexico2] Network Connection (rev 05)


__USB__
**lsusb** --> listet die vorhandene USB Geräte 
-v --> ausführliche Ausgabe
-t --> physiaklische USB Geräteabhängigkeiten als Baum 
-n --> nichts machen
\\ /var/lib/usbutils/usb.ids \\


USB Host Controler Standard ermitteln
**lspci |grep USB**

Kernelmodule: 
usbcore  --> Kernkomponente des Kernels
usb_ohci --> Modul für USB UHCI Controler 
usb_uhci --> Modul für USB OHCI Controler
ehci_hcd --> Hilfsmodul für den USB 1.1 to 2.0 Controler

\\ /proc/bus/usb \\ --> Mountpunkt für usbfs welches Geräre und driver für USB Geräte abbildet 

\\ /sys/bus/usb \\ --> Mountpunkt für usbfs welche Geräte und driver für USB Geräte abbildet

Auswerten der Informationen eines USB BUS:
**lsusb -v -t <descriptor>**

**usbview** --> grafiches Programm für USB BUS Topologien

__Devices__

**lsdev** --> Informationen über installierte Hardware anzeigen
 	  --> sammelt  Informationen von \\ /proc/interrupts \\;  \\ /proc/ioports \\; \\ /proc/dma \\

**cat /proc/scsi/<Device>** --> Informationen über hardware

**hwinfo** --> Tool um Hardwareinformationen des Pcs zu erlangen
--short --> Kurze Zusammenfassung
--listmd --> auch RAID Geräte auflisten
--only <Dev> --> Nur Informationen über das entsprechende Gerät <Dev>
--log <File> --> Schreibe eine Logdatei in die Datei <File>

**vmstat** --> Informationen über Prozesse, Arbeitsspeicher, Paging, Block I/O
TRICK: **watch vmstat**

__IDE und ATA__
+ meist Massenspeichergeräte 
+ werden über Systembus gesteuert
+ kommunizieren über den BUS im ATAPI (Advaced technology attachment protocol Interface)

\\ /dev/hdX \\ --> Gerätedatei

__SCSI__
+ kann mit Platten, Bandlaufwerken und anderen Geräten kommunizieren
+ die Kommunikation erfolgt über ein SCSI Hostadapter mit eigenen BIOS
+ pro SCSI BUS können 7 Geräte angeschlossen werden

Jedes SCSI Gerät lässt sich durch das Quadrupel:
<host>,<channel>, <ID>, <LUN> eindeutig gekennezeichnet 

__Serial-SATA__
+ Übertragungsraten als bei IDE
+ hot swapable
+ pro Controler maximal 4 Geräte angeschlossen werden
+ wird über die libata ab Kernel 2.6 und 2.4.27 unterstützt

**lsscsi [<H:C:T:L>]** --> Informationen über SCSI über 
		       --> falls H:C:T:L angegeben wird entsprechend gefiltert
-c|--classic --> wie **cat /proc/scsi**
-H --> anzeigen der Momentan am Scsi angeschlossen en Geräte
-l --> zusätzliche Informationen anzeigen 

__Seriellen Schnittstellen__
+ I/O Port zum ANschluss serieller Geräte
+ Maus, Tastatur, Drucker, Terminals

**setserial </dev/ttySx>** --> setzen und anzeigen der Konfiguration für serielle Schnittstellen
-a --> vollständige Informationen über das Gerät ausgeben
             
Setzen einer Konfiguration mit **setserial**
**setserial </dev/ttySx> port <IO-Port> irq <IRQ> [optionen]
**setserial /dev/ttyS0 port 0x3f8 irq 4 spd_vhi

__Das Paket systat__
zypper in sysstat

**iostat** Report über CPU and I/O (NFS, lokale Platten)

**mpstat** zeigt Statistiken zu jeden einzelenen Prozessor

**sar** bericht über die Systemaktivität anzeigen

**mpstat** Statistiken für Multiprozessoren

**pmap <PID>** Statistiken über die <PID>

__Weitere Tools zur Systemüberwachung__
**uptime** --> Zeit seit dem hochfahren

**strace <Programm>** --> Rückverfolgung von System Calls und geöffenten Programmen von <Programm>
-o <Outfile> --> Speichern in einer <Outfile>

TRICKS:
*which <programm>**
anzeigen aller benötigten libraries von programmstrace -p 22254 -s 80 -o /tmp/debug.lighttpd.txt** --> Den Prozess mit der PID 22254 auf Port 80 dumpen 

**strace -e trace=open,read -p 22254 -s 80  -o /tmp/debug.lighttpd.txt** --> Den Prozess mit der PID 22254 auf Port 80 tracen und nur öffnen und lesen 
Prozesse ausgeben 

__Geräte und Treiber__
Unter \\ /lib/modules/$(uname -r)/ \\ befinden sich die vom Kernel ladbaren Module

\\ /etc/modprobe.conf \\ enthält die Liste aller zu ladenden Module  die meist auf \\ /etc/modprobe.d/ \\ 
aufgeteilt sind (new)

**modprobe -c** --> Ausgaben einer gülitgen Konfigruationsdatei für den aktuellen Modulbestand
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
alias <Modul> <Aliasname> --> alternative Namen für Module, die beim Laden mittels modprobe verwendet werden können
alias nfs4 nfs

options <Modul> <Parameter> --> zusätzliche Angabe von Optionen zu einem Modul
options ide-scsi idescsi_nocd=1

install <Modul> <Kommando> --> Zum Laden von <Modul> wird eigens definierter Befehl verwendet
install ohci-hcd /sbin/modprobe ehci-hcd; /sbin/modprobe --ignore-install ohci-hcd

remove <Modul> <Kommando> --> zum entladen von <Modul> wird ein eigens definierter Befehl verwendet
remove xfs /bin/echo "Not allowed to remove xfs from modules stack"

include <Datiename> --> Zum Laden der Konfiguration aus der entsprechenden Datei  
include /etc/modprobe.d/mydriver.conf
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\\ /etc/modules.conf \\ --> enthält die Liste und Konfiguration aller zu ladenten Module (deprecated)


**modprobe <Modul>** --> läd <Modul> in den Kernel und löst dabei Abhängigkeiten gegenüber anderer Module auf
-C --> überschreiben der \\ /etc/modprobe.d
-l <Wildcard> --> listen der angegbenen Module die zum gegeben <Wildcard> passen, wenn keins angegeben wurde liste alle
-n --> nichts machen
-s --> Fehler werden an den Syslogdaemon geschickt und nicht an den Standardfehler
-r --> entferne geladenes <Modul>
-a | --all --> Laden aller passenden Module
-q --> Fehlermeldung unterdrücken
-r <Modul> --> ruft rmmod mit der Option --stacks | -r auf


**insmod** --> wie modprobe. Abhängigkeiten werden jedoch nicht selbständig aufgelöst
-f --> erzwinge das laden eines Moduls
-k | --autoclean --> setzen  der Autoclean markierung (Entlädt Modul sobald nicht mehr genutzt)
	         --> automatisches Entladen durch den kmod Daemon
-n --> (noload) tetsen ob ein Kernel geladen werden kann
-p | --probe --> wie -n
-m |--map --> zusätzliche Ausgabe von Kernelmapping informationen, Anzeigen der Loadmap
-O <Datei> --> schreiben eiens Binary Blobs der anzeigt was in den Kernel geladen wurde
-q --> Unterdrücken der Fehlermeldung, Fehlermeldungen können nur via **echo $?** ausgemacht werden
-s --> Nachrichten an den Syslog Daemon übergeben

Beispiel:
**insmod -n -m /lib/kerne-<version>/module.ko** --> testen eines Kernelmoduls und anzeigen seiner Loadmap

**rmmod** --> entfernen von Kernelmodulen zur Laufzeit
-r | --stacks --> rekursives entladen mehrerer von einander abhängiger Module
	      --> dabei wird vom obersten Stack alle abhängigen Module entladen

-s --> Nachrichten an den Syslog Daemon übergeben 


MODPATH --> Umgebungvaribale die den pfad zu den modulen des aktuellen Kernels enthalten kann
	--> wird von insmod verwendet 


**lsmod** --> Auflisten der aktuell geladenen Module \\ /proc/modules \\
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
<Name des Moduls>	<Größe in Kb> 	<UseCount>	<Welche anderen Module>


**modinfo <Module>** --> Informationen zum <Modul> holen
-k <Kernel> --> eine andere Kernelversion als den aktuell laufenden angeben
-F <Field> --> nur das Feld mit der entsprechenden Informationen ausgeben

	<Field>: author, description, license parm,,depends, alias, filename

-a,-d,-l,-p,-n --> nur author, descirption, license, parm, filename ausgeben


__Sysfs__
+Allgemeine Geräteinformationen
+ Bildet nur die Geräte ab, die tatsächlich im System vorhganden sind im Gegensatz zu \\ /proc \\
+ 

\\ /sys/bus/(pci,bus,scsi) \\ --> Geräte sortiert nach ihrem Anschlusstyp

\\ /sys/block/ \\ --> Schnittstellen für Blockorientierte Geräte

\\ /sys/class/ \\ --> Schnittstellen für Zeichenorientierte Geräte

__HAL__
+ Hardware Abstraction Layer 
+ läuft im Kernel User Space
+ versorgt Programme mit Informationen die von Hardware gesendet wird

**hald** --> Der HAL Daemon

__D-BUS__
+ Desktop Bus Daemoen
+ ermöglicht Prozesse miteinander zu kommunizieren und registriert Hardware Ereignisse wie das hotplugging eines Gerätes
+ Sendet Informationen an dern Nutzer: "Usb Stick wurde eingefügt" 

__Udev__
Daemon \\ udevd \\ zur dynamischen Geräteerzeugung. 
(1) Einhängen eines tmpfs über /dev
(2) Starten des udevd 
(3) udevd lauscht auf uevents der Geräte entsprechend der in \\ /etc/udev/rules.d \\, \\ /lib/udev/rules.d/ \\
    und der teporär in /dev/.udev/rules.d/ definierten Regeln anlegt

\\ /etc/udev/udev.conf \\ 
<Variablen>
udev_root --> Wo soll udev Geräte Dateien anlegen, der Standard ist /dev
udev_log --> Was soll udev an den Syslogdaemon senden, Werte sind hier:
		N --> Syslogprioritätslevel
		err, debug, info

**udevadm <info,trigger,settle,control,monitor,test>** --> Tool zum Administrieren von Udev
<info> Informationen zu einem Gerät
--query --type=<name, symlink, path, property, all> --path= || --name= --> Informationen zu den Udevregeln
Bsp: **udevadm info --query=all --name=/dev/sda1**
--export-db --> Die Udev-Datenbank exportieren

<trigger> sorgt dafür dass das Entsprechende Gerät vom Kernel erfragt wird 

<settle> Überwacht den Udev Event bis alle Udev Events beendet wurden

<monitor> horscht auf Kernelevents, gibt die Rule am Bildschirm aus und gibt mögliche Möglichkeiten zum Debuggen
--kernel --> Events vom Kernel

<test> testen einer Regel und ausgeben von debugging Informationen

===Bibliotheken===
Statisch Bibliotheken: benötigte Programme und Abhängigkeiten sind statisch in das Programm gelinkt, sie können nicht mehr
geändert werden. Nachteil: erzeugt sehr große Programme. Vorteil: zur Laufzeigt nicht abhängig von möglicherweise defekten
Paketen. 

Dynamische Bibliotheken: Programm wird erst zur Laufzeit gelinkt, Änderungen sind möglich. Nachteil: Bei defekten Biblio-
theken oder neueren Versionen kann das Programm möglicherweise nicht korrekt arbeiten. Dynamische gelinkte Programme haben
in der Regel eine höhere Laufzeit, da der Linker zur Laufzeit Programme laden und linken muss.

file </lib/SchnippSchnapp.so> --> so meint hier Shard Object file 
ELF 32-Bit LSB shared object

**ldd** --> Gibt informationen über die zur Laufzeit benötigten Bibliotheken aus
	--> Bei statisch gelinkten Programmen wird ein Fehler ausgegeben
-v --> verbose 

TRICK:
**ldd $(which <programm>**
anzeigen aller benötigten libraries von programm


__Dynamische Bibliotheken__
++++++++++++++++++
+ Programm start + --> **ld-linux.so**      <-- benötigte Bibliotken finden und laden
++++++++++++++++++     (dynamischer linker)                 |
				^                           | 
				|                          \|/
\\ /lib, /usr/lib \\ -->  linkt zur Laufzeit <-- \\ /etc/ld.so.cache \\ Datenbank mit Index aller Bibliothekn

                                                         ^
							 |

				   	     **ldconfig** erzeugt <-- wird erzeug aus \\ /etc/ld.so.conf \\ 
									LD_LIBRARY_PATH    include Directive
									  |		   Pfade zu den Bibliotheken
									  |
									   - eigene Bibliotheken vor den Linker auswählen										

**ldconfig** --> aktualisieren des Bibliothekenspeichers \\ /etc/ld.so.cache \\
-v --> verbose
-N --> aktualisiert nur symbolische links zu den Bibliothken
-X --> aktualisiert nur die Bibliotheken aber keine symbolischen Links
-n <PATH> --> Nur <PATH> aktualiesieren
-f <Datei> --> eine andere Datei als die Konfigurationsdatei \\ /etc/ld.so.conf \\ bestimmen
-C <Datei> --> eine andere Datei als den Ausgabe Cache \\ /etc/ld.so.cache \\ bestimmen
-r <DIR> --> das angegeben Verzeichnis als / behandeln
-p --> anzeigen des Inhalts von /etc/ld.so.cache

Trick:
Feststellen ob eine dynamische Bibliothek von einem Programm gefunden werden kann
**ldconfig -p|grep <LIB>**

**strip** --> entfernt Symboltabellen von Programmen
--strip-debug --> nur debugging Inortmationen entfernen
--srtip-all --> alle Symbole entfernen. dies macht in den meisten Fällen das Programm unbrauchbar
--only-keep-debug --> das Gegenteil von --strip-debug, seperaten Speichern von debug Informationen
-v --> verbose

__Wichtige Bibliotheken__
\\ /lib/libc.so.6 \\ --> diese Bibliothek verweist auf die Standard C Library sie ist meisten sein Link auf die 
			 aktuelle C Bibliothek

===Debian==
$Debian, Ubuntu, Knoppix, Xandros, Sidux$

__Aufbau eines Debian Paketes__
<programm>_<Version>_<Release>-<Arch>.deb
<programm> --> Der Name des Programms
<Version> --> Versionsnummer des Programms
<Release> --> Das wievielte Mal wurde das Paket in dieser Verion gebaut
<Arch> --> Die Architektur des Pakets (i386, amd_64, all, any)

Debian Pakete sind mit ar gepackt
**ar t <Programm>**** --> entpackt das Debian Paket und zerlegt es in seine Bestandteile, dabei wird es nicht installiert
debian-binary --> binäre, ausführbare Bibliotheken und Programme
control.gz --> Anweisung was bei der Installation mit dem Paket geschehen soll, typischerweise beinhaltet es Scripte
data.tar.gz --> Dateien die nicht binär sind (z.B. Icons und Konfigurationsdateien)

**dpkg** --> Instalieren und verwalten von .deb Paketen 

(Installieren)
-i| --instal <Paket> --> installieren von Paket
--force-depends --> überspringt die Überprüfung von benötigten Abhängigkeiten
--force-overwrite --> bereits vorhanden Dateien die miteinem Paket installiert werden werden überschrieben
!! Paketen können sich Gegenseitig ausschließen !!
!! Virtuelle Abhänigkeiten: Paket hängt von einer Funktionalität die eine bestimmte Funktion anbietet ab !!

(Entfernen)
-r|--remove <Paket> --> entfernen von Paket. Konfigurationsdateien bleiben erhalten
-p|--purge <Paket> --> entfernt das Pakte samt Konfigurationsdateien
--force --> entferne trotz besthender Abhängigkeiten

(Quellcode zu einem Paket erhalten)
dpkg-source -x <Paket>.dsc --> holen der zu <Paket> passenden Quelldateien

(Informationen erhalten)
-l | --list --> List der installierten Pakete 
	ii --> das Paket ist vollständig installiert
	un --> Auf diesem System nicht installiert
	pn --> Wurde von diesem System entfernt
	rc --> nur noch Konfigurationsdateien liegen vor

-s | --stattus <Paket> --> anzeigen des Status eines einzelnen Paketes

TRICK: dpkg -l|grep ^ii.* --> zeigt nur die installierten Pakete an
	dpkg -l|grep ^rc.* --> zeigt nur die Pakete an von denen noch Konfigurationsdateien vorhanden sind 

-L|--listfiles --> Liste der Dateien die zu einem Paket gehören

-S|--search <file> --> zu welchem Paket gehört <file>

\\ www.debian.org \\

**debsums <Paket<** --> Überprüfen der Intigrität eines installierten Paketes
\\ /var/lib/dpkg/info \\ MD5-Prüfsummen Datei

**apt-get <aktion>** --> Tool zum Holen, Installieren und Verwalten von Debian Paketen
(update) --> aktualisier die lokalen Informationen über verfügbare Pakete aus \\ /ect/sources.lst

(install) <Paket1> <Paket2>-  --> <Paket1> installieren, <Paket2> deinstallieren>

(remove) <Paket> --> entfernen von Paket

(upgrade) --> einspielen aller verfügbaren Updates 

(dist-upgrade) --> aktualisieren einer besthenden Debian Version von Lenny nach Squeeze

(source) <Paket> --> holen der zu <Paket> gehörenden Quellen

**apt-listbugs <Paket>** --> Eine Liste der für das <Paket>  gemeldeten Fehler anzeigen

**apt-build <Paket>** --> ein Paket aus dem Quellcode insallieren, um für das System zu optimieren

\\ /etc/apt/sources.lst \\ --> Liste der Bezugsquellen von Debian Paketen
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ deb http://ftp.de.debian.org/debian stable main               +
+ deb-src http://ftp.de.debian.org/debian stable main           +
+ deb http://security.debian.org/ stable/updates main           +
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
1. Spalte: Typ (deb oder deb-src)
2. Spalte: URL
3. Release Pfad (stable, stable/updates, testing testing/updates, unstable, experimental) 
	testing == Squezze --->  v
	stable == Lenny <----<-- v wird zu
	Unstable == Sid --> ---->^ fließt ein in Testing
	Oldstable == Etch --> Support läuft ab
4. Supportlevel

**apt-cache <aktion>** --> durchsucht die apt Paketdatenbank
(search) <Name> --> findet alle Pakete die <Name> im Namen enthalten

(show) <Paket> --> Status-Informationen über das <Paket>

(depends) <Paket> --> Abhängigkeiten von denen <Paket> abhängt

(rdepends) <Paket> --> Pakete die von <Paket> abhängen

(stats) --> Informationen über den Paket cache

**dpkg-reconfigure <Paket>** --> eine neue Konfiguration für ein installiertes <Paket> erstellen
-f | --frontend --> ein anderes Frontend definieren **man 7 debconf** <Paket debconf-doc>
DENCONF_FRONTEND=<wert> z
-p | --priority <cirtical, high, medium,low> --> festlegen der Detailtiefe der Konfiguration
(critical)
Unbedingt zu beantowrtende Fragen, nur critical wird abgefragt
 |   
 V
(high)
Fragen die eine vernünftige Voreinstellung benötigen, nur high und critical werden abgefragt
 |
 V
(medium)
Fragen die bereits eine sinnvolle Voreinstellung haben, nur medium high und critical werden abgefragt
 |
 V
(low)
Triviale Fragen mit meist funktionierenden Voreinstlleungen werden auch abgefragt zusätzlich zu allen Fragen mit den Prioritäten medium, high und critical

__Verweiste Pakte aufspüren__
**deborphan** --> spürt Pakete und Bibliotheken auf, die von keinem Paket mehr benötigt werden

__Pakete konvertieren__
**alien** --> Script zum konvertieren zwischen Installationsformaten Rpm, Deb, Slackware
          --> benötigt rpm und deb installiert um zu funktionieren

**alien --to-deb <Paket>.rpm** --> wandelt das rpm <Paket> in ein debian Variante um
**alien --to-rpm <Paket>.deb** --> wandelt das deb <Paket> in ein Rpm Paket um

===Rpm Pakete===
$Suse, Fedorra, Mandriva,Redhat$

__Aufbau eines Rpm Pakets__
<Programm>-<Version>-Release.<Arch>.rpm
<Programm> --> Der Name des zu enthaltendenen Programms
<Version> --> Versionsnummer des Programms
<Release> --> Das wievielte Mal wurde diese Paket in dieser Version gebaut
<Arch> --> Die Architektur auf die das Paket instlliert werden kann (ppc, i386, i486, i586, i686, x86_64, noarch)

!! Pakete mit der Endung src, nosrc einhalten keine installierbaren Programme, sondern nur die Quellen und das Specfile 
das zur Erstellung dieses Pakets verwendet wurden. Pakte mit der Endung nosrc enthalten lediglich das Specfile. !!

\\ /us/lib/rpm \\ --> Scripte und Distributionspezifisch Makros, rpm Pakatedatenbank
\\ /etc/rpm/ \\ --> Konfigurationsdateien und definierte Makros

rpm Pakte sind im cpio Format gepackt mit dem entsprechenden Rpm Header, der die Metainformationen enthält

__Rpm Pakete Entpacken__
**rpm2cpio < <Paket>|cpio -it** --> den Inhalt von <Paket> anzeigen
**rpm2cpio < <Paket>|cpio -id** --> den Inhalt von <Paket> entpacken 

**rpm** --> Installieren und Verwalten von Rpm Programmen

(Installieren)
**rpm -i|-F|-U <Paket>.rpm** --> installieren|erneuern falls vorhanden|in jedem Fall erneuern von <Paket>
-h --> ausgeben eines Fortschrittsbalkens in Form von #
-v --> Sei Verbose
-vv --> gibt nochmehr Informatioen beim Installierne aus
--exclude-docs --> Dateien die als Dokumente gekennzeichnet sind nicht installiert
--nodeps  --> keinen Abhängigkeitencheck durchführen
--nosuggest --> Suggests nicht als Abhängigkeiten behandeln
--nopre --nopost --nopreun --nopostun --> das Pre|Post|Prerun|Postrun Script nicht ausfüren, hilfreich bei defekten Scripten
--oldpackge --> Das Update ersetzt ein älteres Paket durch ein neueres
--replacefiles --> bereits bestehende Dateien überschreiben
--replacepkgs --> Ersetze ein bereits installiertes Paket
--force --> --replacepks --replacefiles --oldpackage
--test --> Nichts machen nur Tetsen

(Ein QullePaket erneut übersezen)
**rpmbuild --rebuild <Paket>.src.rpm** --> ein QullPaket erneut übersetzen --> \\ /usr/src/packages/RPM \\

TRICK:
**rpm -Uhv --ignorearch --nodeps --force  --root <Pfad> <Paket>.rpm** --> Das <Paket> nach <Pfad> installieren, hier wird
auch die Datenbank angelegt, kann zum strukturellen entpacken des Rpms verwendet werden.

TRICK: **rpm -i --justdb kernel-default-2.26.3.i586.rm && rpm -i <mein-generierter-Kernel>.rpm 
 --> einen selbstgebauten Kernel installieren


(löschen)
**rpm -e <Paket>** --> deinstallieren des Rpms 
--allmatches --> kann genutzt werden um ein zweites meistens defektes Paket zu entfernen und es anschließend das reparierte
                 zu installieren
--nodeps --> keinen Abhängigkeitscheck durchführen
--noscripts --> keinerlei Scripte bei der deinstllation ausführen, zum Umgehen defekter Deinstallationscripte 
--test --> die Aktion nur testen

(abfragen)
**rpm -q <Paket>** --> Informationen über ein Paket erhalten, ohne zusätzliche Optioen fragt -q nur ab, ob dass Paket
                       installiert ist oder nicht
-a --> Die Abfrage auf alle Pakete ausdehnen bzw. alle installierten Pakete anzeigen
--last --> Die Pakte in ihrer Installationsreihenfolge absteigend sortieren

TRICK: 
**rpm -qa --last|head -N ** --> Die letzten N installierten Paket erfragen
TRICK:
**rpm -qa --last|head -1|awk '{print $1}' |xargs rpm -e** --> Das letzte Paket deinstallieren, wenn man den Namen des Paketesvergessen hat

-p --> Eine Abfrage über ein noch nicht instlliertes Paket wird mit -qp anstelle des -q eingeleitet
-l --> Auflisen der von <Paket> installierten Dateien
-i --> Die Informationsheader von <Paket> abfragen, der Informationen über Packager, Maintainer und eine kurze Beschreibung
       enthalten
-f <Datei> --> Welches Paket enthält die <Datei>
-d --> nur als Dokumentation gekennzeichente Dateien listen (impliziert -l)
-c --> nur als Konfigurationsdateien gekennzeichnete Dateien listen (impliziert -l)
--provides --> Zeigt an welche Metadateien das Paket anbiebet
-R|--requiers --> zeigt an , von welchem Paket abhängt

!! Mit --qf lässt sich die Ausgabe formatieren !!

(überprüfen)
**rpm -V <pakte>** --> verifizieren der von <Paket> installierten Dateien. Dabei werden in der Regel die md5 Summen
		       Dateien verifizieren
-a --> alle Pakete überprüfen

(Signaturen importiren)
**rpm --import <Pubkey>** --> importiert eine öffentlichen Schlüssel <Pubkey> in die Datenbank

**rpm -K <paket> --> überprüfen der Signatur eines Paketes

(Paketdatenbank erneurn oder initialisieren)
**rpm --rebuilddb** --> Die rpm Paketdatenbank neu erzeugen
**rpm --initdb** --> Die rpm Paketdatenbank initialisieren, diese Option wird beim erstmaligen installieren vorgenommen
			und muss in der Regel nicht nochmal vorgenommen werden
--dbpath <Pfad> --> der <Pfad> zur neuen Datenbank

\\ var/lib/rpm \\ --> Die Rpm Datenbank

__Rpm Pakte aus einem delta.rpm erzeugen__
Ein delta.rpm Ist wie das diff eines Binärcodes es enthält nur die Unterschiede zu einer füheren Version
Aufbau eines Delta-rpms:
<Programm>_<Version-alt>-<Release-alt>_<Version-neu>-<Release-neu>.delta.rpm

**applydeltarpm -r <Programm>-<Version-alt>-<Release-alt>.<Arch>.rpm -pv <Deltarpm> <Programm>-<Version-neu>-<Release-neu> \
		   .<Arch>.rpm** --> erzeugt das neue rpm aus einem delta rpm verbose mit Prozentangabe

**applydeltarpm -c <delta** --> check was sich geändert hat und ob das Rpm aus dem bestehenden Systempaket erzeugt werden
				kann

 
__Rpm Paketabhängigkeiten Baum ausgeben__
**rpmgraph <Paket>** --> zeigt einen Abhängikeitsbaum und ob das Paket installiert werden kann oder nicht
		     --> zeigt auch Probleme mit defekten Paketen oder unsignierten Paketen

__Verweiste Rrpm-Pakete finden__
**rpmorphan** --> nach verweisten Bibliothekn suchen

___Zypper und Yum__
$SuSE$
Das Tool zypper ist seit Version 11.0 bei SuSE zur Paketverwaltung verwendet. Es bietet seit Version 11.2 einen 
ähnlichen Komfort wie zum Beislpiel aptitute oder apt-get. Auch hier werden Pakete in Repositories verwaltet. 
Ein Repositorie kann ein lokaler Pfad, oder eine Adresse auf einem entfernteen Webserver sein, der entweder ftp oder
http spricht und halten die Rpms oder auch delta.rpms vor. 


**zypper <Globale Option> <Aktion> <Aktionsoptionen>** --> verwalten und installieren von $SUSE$ Pakte und Repositories
-v --> verbose
-n --> Nicht um bestätigung fragen und bei Aktionen die beste Option automatisch wählen
--no-cd --> Repositories auf CD/DVD bei der Aktion ignorieren
-A --> Text in Tabllen nicht abkürzen

<Aktion>:
	(Repository Verwaltung)
	lr --> Repositories auflisten
		-d --> zeige Details wie URI des repos etc
		--help --> zeige eine Liste der zusätzlich Verfügbaren <Aktionsoptionen>
		-e <File> --> exportieren der Repositoriliste in File 
	!! Die <Globale Option> -A ist in den meisten Fällen sinndvoll !!
	
	ar <URI> <Name> --> Fugt das Repositorie aus der ftp,http, lokalen <URI> als <Name> hinzu
		-n --> beschreibenden Namen für das Repository festlegen
		-f --> automatische Aktuallisierungen für dieses Repositorie aktivieren 
		-c --> <URI> überprüfen 
		-K --> deaktiviern des lokalen Rpm Caches für dieses Repsitorie
		
	rr <Nummer>|<Name> --> Das Repositorie mit <Nummer> oder <Name> entfernen 
		-d --> deaktivieren des Repositries, aber nicht entfernen
		-e --> ein deaktiviertes Repositorie wieder aktivieren
		-r|-R --> aktivieren | deaktiviern der Autoaktuallisierung für dieses Repositorie
		-p --> Eine Priorität für dieses Repositorie festlegen,  
		-k|-K --> aktivieren|deaktivieren des lokalen Rpm Caches für dieses Repositorie 
		-a --> Änderungen auf alle Repositories anwenden zum Beispiel zypper mr -aK
		-l --> Änderungen auf alle lokalen Repositories anwenden zum Beispiel: **zypper mr -l -p 1**
		-t --> Änderungen auf alle remote Repositroies anwenden zum Beispiel: **zypper mr -t -p 99**


	ref --> Alle Repositories mit der lokalen Datenbank abgleichen
		-b --> Einen Neuau der Datenbank erzwingen
		-r <URI>|<Nummer>|<Name> --> nur für dieses  Repositorie die Datenbank aktuallisieren
			
	(Software Verwaltung)
	se <Paket>--> durchsuchen der Datenbank nach <Paket>
		-s --> details 	anzeigen
		-d --> auch in der Paketbeschreibung anstatt nur in <Paket> Name suchen
		-i --> nur installierte anzeigen
		-u --> nur nicht installierte anzeigen
		--sort-by-name --> nach Namen alphabetischen sortieren
		--sort-by-repo --> nach Repository sortieren 
	
	if <Paket> --> Informationen zu einem Paket anzeigen
	in <Paket> --> installieren
		-f --> das Paket nochmals installieren, auch wenn eine exakte Version bereits vorhanden ist
		-r <URI>|<Name> --> nur von diese Repositories zu installation wählen
		-l --> bei bereits zugestimmten Lizensvereinbarungen nicht nochmals fragen
		--recommends --> installiert auch empfohlene Pakete
		-D --> nur testen nichts machen
		--download-only --> nur herunterladen nicht installieren \\ /var/lib/zypp \\
		--download-in-advance --> Die Pakete erst herunterladen und dann installieren,!! empfohlen bei kritischen
				          Netzwerkverbindungen !!
	
	rm <Paket> --> das <Paket> wieder entfernen
		-r <URI>|<Name> --> nur diese Repositories laden 
		--forec-resolution --> finde auf jeden Fall eine Lösung, auch wenn das  bedeutet das Gesamte System wird 
					gelöscht
		-D --> nur testen nichts machen
		-u (nur ab Version 11.3) --> automatisch nicht mehr benötigte Abhängigkeiten entfernen	

	up --> upgrade aller im System installierten Pakte, Vendor- oder Architekturwechsel sind Standardmäßig nicht erlaubt
		-r <URI>|<Name> --> nur diese Repositories laden
		-l --> bei bereits zugestimmten Lizensvereinbarungen nicht nochmals fragen
		--donwload-in-advance --> Die benötigten Pakete erst herunterladen und dann installieren, !!empfholen bei
					  kritischen Netzwerkverbingungen !!
		--download-only --> nur die Updates herunterladen \\ /var/lib/zypp \\
		-D --> nur testen nichts machen
	TIPP: Immer **sudo zypper -n up -l --download-in-advance** zum Updaten des Systems verwenden
	
	dup --> ein Versionsaktuallisierung des gesamten Systems durchführen (Seit 11.1)
		--debug-solver --> einen Testfall generieren
		-D --> nicht machen nur testen
		!! Wie bei debian so müssen auch hier die Repositories entsprechend angepasst werden !!
		!! Funktioniert am Besten wenn nur oss nonoss und packman verwendet wird !!

	**zypper sh** --> startet eine interaktive Shell in der zypper Kommandos interaktiv bearbeitet werden können

**yum <Globale Option> <Aktion> <Aktionsoption>** --> Verwalten von Repositories und Updates $ALLE RPM DISTRIBUTIONEN$
	(Repository Verwaltung)	
	repolist --> Auflisten verfügbarer Repositories
		disabled --> auflisten der deaktiverten Repositories
		--enablerepo=<Name> repolist --> aktivieren eines deaktivierten Repositories
		--disablerepo=<Name> repolist --> dekativieren eines aktivierten Repositories
		
	\\ /etc/yum/repos.d \\ --> Konfigurationdateien des Yum-repos
	\\ /etc/yum.conf \\ --> Manuelle Konfiguration der Repositories
	
	(Software Verwaltung)
	install <Paket> --> Installieren von <Paket>
	
	remove <Paket> --> entfernen von <Paket>

	update --> aktuallisieren des gesamten Systems
	--obsoletes --> behandelt auch den Fall das ein Paket durch ein anderes ersetzt wurde
	
	list <Paket> --> Pakete auflisten
		installed --> nur installierte Pakete anzeigen
	
		available --> nur nicht installierte Pakete anzeigen
	
	info <Paket> --> Informationen zu einem Paket anzeigen

	deplist --> Auflisten der Abhängigkeiten  		

	(Gruppen Verwaltung)
	grouplist --> auflisten der Verfügbaren Gruppen
	
	groupinfo <Group> --> Informationen zu einer Gruppe auflisten
		
	**yumdownloader --destdir /<Pfad> <Paket>** --> <Paket> nur nach <Pfad> herunterladen	

	**yum shell** --> startet eine interaktive Shell in der yum Kommandos interaktiv bearbeitet werden können
		--resolve --> auch die benötigten Abhängigkeiten herunterladen
		--source --> lade die Quellpakete und nicht die korrespondierenden Binärpakete herunter

**smart** 

TIPP:
Mit dem Programm **rpm-tidy** hält man den Cache sauber. Es entfernt nur Pakete aus dem Cache die älter als eine andere
Programmversion sind. **rpm-tidy --dir=/var/lib/zypp** würde den Zypper Cache bereinigen.

===Pakete bauen===
+ Vorteile einer Paketverwaltung lassen sich nur bei konsequenter Nutzung nutzen
+ einfachere Erkennung von Intrusion
+ Installierte Dateien können dank der Paketdatenbank besser verwaltet werden
+ Alte Konfigurationsdateien bleiben bei der deinstallation ohne spezielle Angabe sie zu löschen erhalten

__RPM Paket bauen__

\\ /usr/src/packages/SOURCES \\ --> Sourcecode, Patches und andere Dateien die als Rpm erstellt werden sollen

\\ /usr/src/packages/SPECS \\ --> Specfiles, die Bauanleitung für ein rpm

\\ /usr/src/packages/RPMS \\ --> die fertigen RPMS werden hier gespeichert

\\ /usr/src/packages/BUILD \\ --> hier werden die Sources ausgepackt und übersetzt

\\ /usr/src/packages/BUILDROOT \\ --> hier werden die Dateien und Programme testweise installiert

Workflow:
1) Specfile erstellen

2) Quellen anpassen

3) **rpmbuild -ba /usr/src/packages/SPECS/specfile** ausführen

4) Signieren des Paketes
	
4 1) 	**gpg --gen-key** erstellen eines Öffentlichen und Privaten Schlüssels
	
4 2) 	anpassen der Datei \\ /etc/rpm/macros
	+++++++++++++++++++++++++++++++++++++
	%_signature gpg
	%_gpg_path <Pfad zum .gpg Verzeichnis> 
	%_gpg_name <name und beschreibung mit **gpg --list-keys** erfragbar>
	%_gpgbin <Pfad zur Ausführbaren Datei> zum Beispiel /usr/bin/gpg

4 3) Signieren des Paketes mit **rpmsign --addsign --macros=/etc/rpm/macros <Paket>.rpm**
                                                           	
4 4) Improtieren und der Signatur
	**gpg -a --export > <file>**
	**rpmsign --import <file>

\\ /usr/src/packages/SPECS/programm.spec \\
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
##der norootforbuild flag ist ein Indikator der für den opensuse buildservice benötigt wird
#norootforbuild 

#Macros vorher definieren
%define _prefix /usr/share

###Kopfteil:
Name:                   AwOken 			#Name des Pakets

Summary:                Awsome Token Icon Theme #Kurze Zusammenfassung wozu das Paket da ist

Version:                1.1 			#Versionsnummer des Pakets

Release:                1 			#Releasenummer des Build Vorgangs, bezieht sich auf die Versionsnummer
						#des Pakets nicht auf die der Software 

Vendor: 		Opensuse BuildService	#Organisation die das Paket vertreibt und gebaut hat

Packager:		propstmatthias <pmatthias@fancynet.com> #Nutzer und E-Mail Adresse des Packagers

License:                Creative Commons Attribution-ShareAlike 2.5 License Agreement
						#Lizenz unter der die Software, der Inhalt des Paketes steht

Group:                  System/GUI/Gnome	#Die Zuordnung in der Rpm Datenbank

URL:                    http://www.deviantart.com/download/163570862/ #URL zum Sourcecode des Paketes

Source0:                 %{name}.tar.bz2		#Name inklusive Versionsnummer und tar.bz2|gz extension

Source1:		index.theme		#weitere Dateien die zum Paket gehören aber nicht bestandteil des
						#Source rpms sind

Patch0:			fancy-patch1.diff	#name diverser Patches die ebenfalls unter SOURCES liegen

PATCH1:			even-fancier.diff	

BuildRequires:  gtk2 >= 2.18			#Zum Bau der Software benötigte Pakete die installiert sein müssen
BuildRequires:  fdupes

Requires:	gnome				#Eine Abstrakte Abhängigkeit die vorhanden sein muss und von einem
						#anderen Paket angeboten werden muss

Provides:	Icon-Theme			#Eine Abstrakte Abhängigkeit die von diesem Paket angeboten wird

Conflicts:	AwOken-gnome			#Ein Paket die mit diesem Paket im Konflikt steht

Obsoletes:	sonar-icon-theme		#Ein Paket welches durch dieses Übrflüssig gemacht wird

BuildArch:              noarch			#Für welche Zielarchitektur wird das Paket gebaut

BuildRoot:              %{buildroot}		#Das Verezeichnis indem das Paket gebaut wird
						#%{buildroot} ist ein Macro der sich auf die buildroot des Servers bezieht
###Kopfteil:

#beschreibt das Paket genauer. Meist wird hierfür ein teil der README Datei herangezogen
%description 	
My fancy icon theme for public use made with the customizable 
AwOken Icon Theme.

#Angabe des Autors der Software, nicht des Packagers
Authors:
---------
        Alessandro Roncone

#Vorbereiten des Übersetzens der Software
Patchen der Software 
%prep 
%setup -q
%patch0 -p1
%patch1 -p0

#Befehle die zum Bau der Software ausgeführt werden sollen
%build
%__make %{?_smp_flags}

#Befehle die für die Installation der Software ausgeführt werden
%install
%__makeinstall DESTDIR=%{buildroot} PREFIX=%{_prefix}
%fdupes %{buildroot}%{_prefix}
find %{buildroot}/usr/share/icons/ -type f -exec %__chmod 0644 {} \;

#Befehle vor der Installation ausführen
%pre 

#Befehl nach der Installation ausführen
%post

#Befehl vor der Deinstallation ausführen
%preun

Befehle nach der Deinstallation ausführen
%postun

#Aufräumen nach der Erstellung des Rpms
%clean 
rm -rf %{buildrot}

#Auflisten der Files
#dies ist der schwierigste Prozess beim Bauen
%files 
%defattr(-,root,root)
%{_prefix}/icons/%{name}

%changelog
* <Day of Week> <Month> <Day of Month> <Year> <Name des Autors> <Paket version>
- Notiz
  +genauere Bechreibung der Notiz

* Wed Dec 8 2010 propstmattias 1.0.1-1
- initial build
   + no bugs known

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

**rpmbuild** --> erstellen von rpms, neubauen von rpms
--rebuild <src.rpm> --> baut das rpm aus dem angegeben Qullen neu
-ba --> build all, alles inklusive src.rpm bauen
-bb --> build binary, nur die Binärdatei bauen
-bs --> build soruce, nur das src.rpm erzeugen

__Debian Pakete bauen__
+ Minimale Umgebung:
			gcc, g++, make, libc6-dev, dpkg-dev } --> build-essential

+ zusätzliche Dokumentation: 
			debian-policy, developers-reference

**apt-get build-dep <paket>** --> herunterladen und installieren der Paketbau Abhängigkeiten für das Paket 
**aptitude build-dep <paket>** 

**fakeroot** --> Programm was den Root account unter Debian vorteucht und so das Paket baut
	     --> kann in einer Ugebung ausgeführt werden, um Root Privilegien vorzutäuschen

-- <Befehl> --> einen kompletten Befehl an den Fakeroot account übergeben

-s <Datei> --> Die Einstellungen der Fakeroot Umegbung als Snapshot in die <Datei> speichern

-i <Datei> --> Den Snapshot für dei Fakeroot Umgebung lesen

-u --> den Besitzer auf unknown wechseln, anstelle von root:root

Workflow:

1) **apt-get -d source --> holt Qullpakete ohne sie zu entpacken
		    --> enthält in der Regel drei Dateien die in das aktuellen Verezeichnis gelegt werden:
				<programm.orig.tar.gz> --> Original Quellen des Programs
				
				<programm.dsc> 		--> Prüfsummen zu den beiden anderen
							--> Email Adresse
							--> Informationen zum Paketbau
							--> Ist vom Paketbetreuer signiert
				
				<programm.diff.gz>    --> Änderungen zum Original


2) dpkg-source -x <programm.dsc> --> Auspacken und für die Kompilation vorbereiten
				 --> Anwenden der Patches
				 --> Dabei entsteht ein Ordner <programm>/debian

\\ <programm>/debian/README.debian \\ --> Debian betreffende Änderungen und Anmerkungen

\\ <prgramm>/debian/changelog \\ --> vorgenommenen Änderungen des Paket Maintainers
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
<name_programm> (<Versionsnummer) <Codename>; urgency=<level>
  * <Kommantar>
  -- <Name und Email in <> des Maintainers> <Tag der Woche>, <Tag des Jahes> <Monat> <Jahr> <Uhrzeit in HH:MM:SS> <+|-UTC>

quemu (0.7.2-1) unstable; urgency=low
  * Initial release Closes #nnn
  -- Paul Seelig <pseelig@debian.org> Wed, 7 Sep 2005 22:03:21 +0200
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


\\ <programm>/debian/control \\ --> Informationen die zum Bau des Packets benötigt werden
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Source: 		<Source Paket Name> 
Section: 		<Angabe der Application Area für das Paket spezifiziert wurde>
Priority:		<Wie wichtig ist es diese Paket zu installiern> requiered, importend, standard, optional, extra
Maintainer:		<Name und E-Mail Adresse (in <>) des Package Maintainers>
Standard-Version:	<Version des Standards (Policy, Manual) mit denen das Paket gebaut wird>
Build-Depends:		<Abhängigkeiten die erfüllt sein müssen um das Paket zu bauen> (>, <, = Versions), ... 
Recommends: 		das zu installierende Paket empfiehlt dringend auch das hier aufgelistete mitzuinstallieren
Suggests:		das zu installierende Paket ist nützlicher wenn auch dieses Paket installiert
Enhances:		das zu installierende Paket wird durch dieses Paket sinnvoll ergänzt
Conflicts:		Das zu installierende Paket kann nicht gleichzeitig mit diesem installiert sein

Package:		<Name des zu erzeugenden Debian Pakets>
Architecture:		<die Zielarchitektur des Paketes> any,all,i386,am64
Depends:		<Abhängigkeiten zur Laufzeit>
Description:		<Kurze Beschreibung des Paketes>
<Lange Beschreibung des Pakets>

Binary:			<Eine durch Kommata searierte Liste, die auflistet welche Binärpalete ein Quellpaket erzeugt>
Homepage:		<URL von der der Original Qullcode erstanden werden kann>
Uploaders:		<Liste von nbamen udn E-Mail Adressen weiterer Mitautoren
Files:			<md5sum> <Größe> <Section> <Priorität> 

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
										
\\ <programm>/debian/copyright \\ --> Lizens der Software, Autoren der Software

\\ <programm>/debian/dirs \\ --> festlegen von Verzeichnissen dei gebraucht werden aber von make install nicht erkannt
				 werden
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
etc/X11/app-defaults
usr/bin
usr/share/doc/xtartan
usr/share/lintian/overrides
usr/share/menu
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 

\\ <programm>/debian/lintian.overrides \\ --> Regeln und Defintionen die von lintian nicht beachtet werden
					  --> Ausnahmen da sonst das fertige Paket nicht richtig bauen würde	

\\ <programm>/debian/menu \\ --> definieren eines Menus für grafische Oberflächen

\\ <programm>/debian/postinst \\ --> Script dass nach der Installation ausgeführt wird

\\ <programm>/debian/prerm \\  --> Script dass nach dem Entfernen eines Paketes ausgeführt wird

\\ <programm>/debian/rules \\ --> Regeln und Anweisungen die aus dem Quellcode das Kompilat zu erzeugen
                              --> wird als Makefile realisiert
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#!/usr/bin/make -f
config.status:	configure
	dh_testdir
	./configure --cc=gcc-3.4 --preifx=/usr

build: build-stamp
build-stamp:	config.status
	dh_testdir
	$(MAKE)
	touch build-stamp
clean:
	dh_testdir
	dh_testroot
	rm -f build-stamp
	-$(MAKE) distclean
	dh_clean

install: build
	#deb helper scripte befinden sich im paket dh-make
	dh_testdir
	dh_testroot
	dh_clean -k
	dh_installdirs
	$(MAKE) install prefix=$(CURDIR)/debian/quemu/usr

binary-indep: build install

binary-arch: build install
	dh_...

binary:	binary-indep binary-arch #wird zuerst ausgeführt und ruft die verweisenden Sektionen auf
.PHONY:	build clean binary-indep binary-arch binary install
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++                              

**dh-make** --> konvertieren und anpassen des Source Code Pakets an die Debian Regeln
-c <Lizens> --> angeben der Paketlizenz eines Paketes
-e <mail@mail.com> --> angeben einer Email-Adresse
-n --> natives Debian Paket bauen. Keine orig.tar.gz benötigt
-f <file.tar.gz> --> wandelt <file.tar.gz> in ein <file.org.tar.gz> um
-l --> Setzen der Paketklasse auf Bibliothek
-s --> Setzen der Paketklasse auf einzelne binär Datei
-m --> Setzen der Paketklasse auf multiple binär Datei
-p --> Angabe eines alternativen Paketnames abweichende vom Namen der Quellen

**dpkg-builder** --> Programm dass aus einem Debian Konformen Quellpaket das .deb Paket baut
-us --> Quellpaket nicht signieren
-uc --> Changes datei nicht signieren
-b --> nur binäre Dateien bauen /keine Quellpakete erzeugen
-S --> nur Quellpakete bauen / keine Binären .deb erzeugen
-a <Arch> --> explizite Angabe einer Zielarchitektur
-d --> Abhängigkeiten ignorieren
-rfakeroot --> Benutze eine gefälschte Rootumgebung zum Bauen nicht root

**lintian <paket.deb>** --> Untersucht Pakete nach bugs und policy Verletzungen und berichtet diese dann  	
			--> Dabei wird eine Verzeichnis, laboratory angelegt in welche Informationen über das Paket
			    abgelegt werden 

-d --> Anzeigen von debugging Nachrichten
-i|--info --> Anzeigen von detailierten Informationen zu den einzelnen Problemen
-o --> override Policy nicht benutzen
--color --> machs ein bisschen bunter
-l | --lab <Verzeichnis> --> ein ladoratory Verzeichnis angeben
-j N --> Anzahl der Aufträge die gleichzeitig abgewicklet werden dürfen, pro CPU einen Auftrag ist eine gute Wahl

**pbuilder** --> Bauen eines .deb Paketes in einer sicheren Umgebung sauberen Umgebung
	     --> stellt sicher dass die Abhängigkeiten richtig erkannt wurden
             --> es wird eine Chroot Umgebung in einem Tarball erstllt

**pbuilder create** --> erstellt eine Chroot Umgebung für debian sid
--distribution <code> --> erstellt eine Chroot Umgebung für die Distribution <code>

**pbuilder update** --> aktuallisieren der Chroot Umgebung

**pbuilder builder <programm.dsc>** --> baut das Paket aus der <programm.dsc> datei



Workflow:

1) Herunterladen und auspacken des Quellcodes, sowie lesen der Dokumentation um entsprechend fehlende Libraries 
   nachzuinstallieren

2) Aufruf von dh_make im Paket dh-make 
	**cd <programm>**
	**dh_make -f ../<programm.tar.gz> --email noop@noop.de -c gpl**

3) Anpassen und bearbeiten von Dateien im \\ debian/ \\ Unterverzeichnis

3 1) debuggen 

4) Das Paket mit **dpkg-buildpackage** bauen: **dpkg-buildpackage -uc -us -rfakeroot**

5 1) Paket Nach Fehlern durchsuchen mit **lintian** und **pbuilder**





===Linux System Programmierung===

__Ein Shellscript aufrufen__
+ Muss Ausführbar und lesbar (!) sein
+ Shellscripte in $PATH können direkt durch Angabe des Namens aufgerufen werden
+ Shellscripte ausserhalb von $PATH:
					** ./PFAD/script.sh ** --> ausführen auf einer Subshell mit expliziter 
								   Pfadangabe mit Ausführungsrechte
					** bash /PFAD/script.sh ** --> ausführen auf einer Subshell ohne Ausführungsrechte
					** source script** || ** . script ** --> ausführen auf der aktuellen Shell	  

!! Die Endung .sh wird empfohlen ist aber nicht zwingend !!

__Debugen von Shellscripten__
+ Aufrufen von -x aktiviert tracing
** set -x ** --> dauerhaftes tracing in der aktuellen Shell aktiviere__Debugen von Shellscripten__
+ Aufrufen von -x aktiviert tracing
** set -x ** --> dauerhaftes tracing in der aktuellen Shell aktivierenn
** sh -x <script> ** --> Shellscript mit tracing aufrufen
TRICK:tracing nur für einen bestimmten Codeblock aktiveren
++++++++++++++
sh -x
codeblock
sh +x
++++++++++++++
+ Aufruf von -v aktiviert verbosity, die Shell zeigt alel befehle an die es ausführt
** sh -v <script> **

+ Aufrufen von -u warnt vor undefinierten Variablen
** sh -u <script> **

+ Aufruf von echo vor einem Kommando dass eine Substitution enthält gitb alle Substitutionen und Expansionen aus ohne den Befehl tatsächlich auszuführen

__Zuweisung von Variablen__
**VAR=val** --> Weist der Variblen VAR den Wert val zu. Falls die Variable einen Anderen Wert bereits hatte wird sie der alte Wert überschrieben.

**VAR[n]=val** --> Weist dem n-ten Element des Arrays <VAR> den Wert <val> zu. Falls dieser bereits belegt war wird VAR mir einem neuen Wert überschrieben.

**VAR=$(Befehl)** oder **VAR=`Befehl`** --> Weist die Ausgabe von Befehl (Einzelenes Kommando oder Befehlskette) der Variablen VAR zu.

**${VAR:=<val>}** --> Die Variable <VAR> erhält den Wert <val> wenn <VAR> nicht gesetzt oder leer war.

**${VAR=<val>} --> Die Variable <VAR> erhält den Wert <val> falls die Variable undefiniert war. Der Wert NULL bleibt erhalten.

**${VAR:-<val>} --> Nur der Ausdruck von <VAR> wird durch <val> ersetzt. Der alte Wert bleibt aber erhalten.

**${VAR:?<Fehlermeldung>} --> Ist <VAR> leer oder undefiniert wird <Fehlermeldung> ausgegeben

**VAR1=${!VAR2} --> der Wert von VAR2 wird VAR1 zugewiesen

**${VAR:m:n}** --> Alle Werte von VAR bei der m-ten Postion beginnend der Länge n. Startet bei Index 0, m und n können auch Werte sein, die aus
		   Berechnungen entstehen

**${#VAR}** --> evaluiert die Länge des Strings der Variablen VAR

**${STRING#Expr}** --> entfernt den kürztmöglich passenden Ausdruck von Expr von __vorne__ beginnend von STRING

**${STRING##Expr}** --> entfernt den längstmöglichen passenden Ausdruck von Expr von __vorne__ beginnend von STRING

**${STRING%Expr}** --> entfernt den kürztmöglichen Ausdruck von Expr von __hinten__ beginnend von STRING

**${STRING%%Expr}** --> entfernt den längstmöglichen Ausdruck von Expr von __hinten__ beginnend von STRING

**${STRING/Expr/<Ersetzung>}** --> der Ausdruck Expr wird in STRING durch <Ersetzung> ersetzt

**${STRING//Expr//<Ersetzung>} --> alle Ausdrücke die auf Expr passen werden in STRING durch <Ersetzung> ersetzt

**VAR=** --> Weist der Variablen den Wert NULL zu. 

**unset VAR** --> löschen der Variablen VAR

__Arithmetik in Bash__
+EInfache arithmetische Ausdrücke werden durch $((Berechnung)) beschrieben und ausgewertet.

**$((a+b)) (Addition)**; **$((a*b))** (Multiplikation); **$((a/b))** (Division); **$((a%b))** (Modulo); **$((a**b))** (Potenz)

!!Bash rundet seine Werte immer auf !!

__Exit und Exit Status__
+ Der Exit Status ist ein Wert 0-127 der vom zuletzt aufgerufenen Prozess abgefragt wird. 
+ Wird bei der logischen Verknüpfung || && abgefragt
+ exit Status 0 gibt Erfolg zurück
+ exit Status > 0 gibt Misserfolg zurück

!! Misserfolg meint hier auch, wenn zum Beispiel die Programme **find** oder **grep** nichts finden konnten !!

**exit <0-127>** --> setzt einen Wert für den zuletzt aufgerufenen Prozess fest

**exit 1** --> vorzeitiger Ausbruch aus einer Schleife oder Bedingung festlegen

!! Rückgabewerte > 127 lassen geben das Signal an, welches an diese geschickt wurde, und wodurch sie beendet wurden. Beispiel Rückgabewert von
136 lässt auf SIGNAL 9 schließen !!

**echo $?** --> liefert den letzten Rückgabewert

__Der test Befehl__
+ Vergeleich von Zahlen / Zeichenketten
+ Überprüfen von Dateieigenschaften
+ liefert exit Status 0 für wahr, 1 für flasch zurück

**test**; **[  ]**; **[[  ]]**; **((  ))** 

Arithmetische Tests:

**test "$x"** --> 0 falls Variable exitiert und nicht leer
              --> 1 falls Variable leer oder nicht gesetzt

**test $x -gt N** --> 0 falls x größer als N 
		  --> 1 sonst

**test $x -ge N** --> 0 falls x größer oder gleich N
		  --> 1 sonst

**test $x -eq N** --> 0 falls x gleich N 
		  --> 1 sonst

**test $x -lt N** --> 0 falls x kleiner N
		  --> 1 sonst

**test $x -le N** --> 0 fals x kleiner oder gleich N
		  --> 1 sonst

**test $x -ne N** --> 0 falls x ungleich N 
		  --> 1 sonst

TIPP: Arithmetische Testen mit (())
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ #!/bin/bash                                                            +
+ # arith-tests.sh                                                       +
+ # Arithmetic tests.                                                    +
+                                                                        +
+ (( 0 ))                                                                +
+ echo "Exit status von \"(( 0 ))\" ist $?."         # 1                 +
+                                                                        +
+ (( 1 ))                                                                +
+ echo "Exit status von \"(( 1 ))\" ist $?."         # 0                 +
+                                                                        +
+ (( 5 > 4 ))                                      # true                +
+ echo "Exit status von \"(( 5 > 4 ))\" ist $?."   # 0                   +
+                                                                        +
+ (( 5 > 9 ))                                      # false               +
+ echo "Exit status von \"(( 5 > 9 ))\" ist $?."   # 1                   +
+                                                                        +
+ (( 5 == 5 ))                                     # true                +
+ # (( 5 = 5 ))  gibt einen Fehlerwert                                   +
+                                                                        +
+ (( 5 - 5 ))                                      # 0                   +
+                                                                        +
+ (( 5 / 4 ))                                      # Division o.k.       +
+                                                                        +
+ (( 1 / 2 ))                                     # Division result < 1. +
+                                                  # 1                   +
+                                                                        +
+ (( 1 / 0 )) 2>/dev/null                        #Illegal division by 0. +
+ # 1          ^^^^^^^^^^^                                               +
+                                                                        +
+                                                                        +
+ if (( var1 > var2 ))                                                   +
+ then #^      ^      Note: Not $var1, $var2. Why?                       +
+  echo "$var1 ist greater than $var2"                                   +
+ fi     # 5 ist greater than 4                                          +
+                                                                        +
+ exit 0                                                                 +
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


Zeichenketten Tests:

**test -z $STRING** --> 0 falls STRING nicht gesetzt oder die Länge Null hat
		    --> 1 sonst

**test -n $STRING** --> **test ! -z $STRING**

**test ALPHA \> OMEGA** --> 0 falls ALPHA lexiographisch nach OMEGA steht
			--> 1 sonst

**test ALPHA \< OMEGA** --> 0 falls ALPHA lexiographisch vor OMEGA steht
			--> 1 sonst

**test ALPHA > OMEGA** --> 0 falls ALPHA in ASCII Reihenfolge nach OMEGA steht
                       --> 1 sonst

**test ALPHA < OMEGA** --> 0 falls ALPHA in ASCII Reienfolge vor OMEGA steht
		       --> 1 sonst

**test ALPHA == OMEGA** --> 0 falls ALPHA der Zeichenkette OMEGA genau entspricht
			--> 1 sonst

**test ALPHA != OMEGA** --> 0 falls ALPHA der Zeichenkette OMEGA nicht entspricht
			--> 1 sonst

Dateioperatoren Tests:
**test -[a|e|f|s|d|b|c|p|h|L|S|t|r|w|x|g|u|k|O|G|N] <Datei>** überprüft die Eigenschaft von Datei

-a|-e --> 0 falls Datei existiert
      --> 1 sonst

-f --> 0 falls Datei existiert und ist normale Datei
   --> 1 falls Datei nicht existiert oder Datei ein Verzeichnis oder Gerätedatei ist

-s --> 0 falls Dateigröße ist Größer als 0
   --> 1 sonst

-d --> 0 falls Datei existiert und ist ein Verzeichnis
   --> 1 sonst

-b --> 0 falls Datei existiert und eine Blockgerätedatei ist
   --> 1 sonst

-c --> 0 falls Datei existiert und ein zeichenorientiertes Gerät ist
   --> 1 sonst

-p --> 0 falls Datei existiert und ein Pipe ist
   --> 1 sonst

-h --> 0 falls Datei existiert und ein symbolischer Link ist, auch wenn dieser defekt ist
   --> 1 sonst

-S --> 0 falls Datei existiert und ein Socket ist
   --> 1 sonst


-t --> 0 falls Datei mit einem Terminal Gerät assoziiert ist
   --> 1 sonst

-r|-w|-x --> 0 falls Datei existiert und lese|schreib|ausführbahr ist
	 --> 1 sonst

-g --> 0 falls Verzeichnis|Datei das Setgid Bit gesetzt hat
   --> 1 sonst

-u --> 0 falls Datei das Setuid Bit gesetzt hat
   --> 1 sonst

-k --> 0 falls Verzeichnis|Datei das Sticky Bit gesetzt hat
   --> 1 sonst


-O --> 0 der Aufrufende ist Beseitzer der Datei
   --> 1 sonst

-G --> 0 der Aufrufende ist Mitglied der gleichen Gruppe wie Datei
   --> 1 sonst

-N --> 0 Die Datei wurde seit dem letzten lesen geändert
   --> 1 sonst

**test <Datei1> -nt <Datei2>** --> 0 falls <Datei1> neuer als <Datei2> ist
		               --> 1 sonst

**test <Datei1> -ot <Datei2>** --> 0 falls <Datei1> älter als <Datei2> ist
			       --> 1 sonst

**test <Datei1> -ef <Datei2>** --> 0 falls <Datei1> und <Datei2> Hardlinks zur gleichen Datei sind
                               --> 1 sonst

__Bedinungen und Fallunterscheidungen__

**if Konstrukt**
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
if <Test>
	then
		<Test gab Exitstatus 0 zurück>
	else
		<Test gab Exitstaus 1 oder größer zurück>
fi
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

**Elif-Konstrukt**
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
if <Test>
	then
		elif <Test 1>
			then
		elif <Test 2>
	else
fi
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

**if Konstuckt mit Bedingungsverknüpfung**
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
if [[ <Bed1> || <Bed2> && <Bed3> ]]
	then
		<Test gab Exitstatus 0 zurück>
	else
		<Test gab Exitstatus 1 oder größer zurück
fi
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++


**case-Konstrukt** --> Verzweigung mit mehreren Alternativen, vergleich von Werte in Var
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
case $<Var> in
	Wert1) Aktion
	;;
	Wert2) Aktion
	;;
	...
	;;
	Wertn) Aktion
	;;
	\?) Aktion #nichts davon traf zu
esac
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++

__Schleifen__
+ for Schleife zur Iteration über eine Liste von Werten oder Dateien
+ while Schleife zum Testen ob eine Bedinugngn wahr oder falsch ist, bei flasch, wahr abbruch

!! Für die Turingvollständigkeit reicht die while Schleife.
Bw: Setze Bedingung solange nicht alle Werte abgearbeitet sind als True/false Bedingung. q.e.d.
!!

**for-Schleife**
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
for i in <Liste>
	do
		<Aktion> $i
	done
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
TIPP: For Schleife für eine Liste von Dateien im gleichen Verzeichnis:
for f in *
	do
		cp $f $f.sav
	done

TRICK:
for i ; do something; done --> Durchlaufen der Postionsparameter, wie for i in $@

**for-Schleife mit Ranges**
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
for (( i=0; $i<10; i=i+1 ))        for (( i=Startwert ; $i [ < | > | =] Stopwert ; Increment | Decrement ))
	do				do
		<Aktion> $i			<Aktion>
	done				done
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

**while-Schleife**
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
while <Test>
	do
		AKtion
	done
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
dabei kann <Test> ein gültiges Testkommando sein, der entweder
0 oder 1 liefert, eine Befehlsfolge die irgendwann den Wert 1 liefert
oder eine die Werte $$True$$ oder $$False$$ dirket annhemen.

Schleifen können Ein- und Ausgabe Umleitungen in den Schleifenkopf übergeben
bekommen.

TIPP:
while ping; do : ; done || echo "Sie sind offline" --> testet ob ein Server noch läuft

TIPP: --> gibt die Datei /etc/passwd Zeilenweise aus mit -- -- dazwischen
wnhile read LINE
	do
		echo "--$LINE--"
	done < /etc/passwd  

TIPP:
i=0; cat /etc/passwd | while read LINE; do echo "$i $LINE $i"; ((i+=1));done --> jede Zeile beginnend bei 0 nummerieren

**Dekrement und Inkrement**
$((j+=1)) --> inkrementiert j auf 1

$((j-=1)) --> dekrementiert j um 1


**until-Schleife**
Das logische Gegenteil der while Schleife

**break**
--> bricht den Schleifendurchchlauf ab und führt das Script hinter dem Schlüsselwort \\ done \\ ab
+++++++++++++++++++++++++++++++++++++++++++
for i in <Liste>
	do
		<Test> $i || break
	done
+++++++++++++++++++++++++++++++++++++++++++

**continue**
--> bricht den Schleifendurchlauf ab und führt das Script nach der nächsten Iteration weiter fort
++++++++++++++++++++++++++++++++++++++++++++
for i in <Liste>
	do
		<Test> $i || continue
	done
++++++++++++++++++++++++++++++++++++++++++++

**trap "<Befehle>" SIGNAL1,SIGNAL2**
--> <Befehle> ausführen, falls das Script eines der Signale SIGNAL1, SIGNAL2 geschickt bekommt
--> die Signale 9 und 15 (SIGKILL, SIGSTOP) können nicht abgefangen werden

__Funktionen definieren und verwenden__
+ Unterprogramme im aktuellen Script die einen **return** Wert liefern können
+ Häufig genutzt Programmschnipsel brauchen nur einmal zu impelmentirert werden
+ schaffen Übersichtlichkeit und lesbarkeit(!)
+ Positionsparameter innerhalb der Funktion entsprechen denen der Funktion und nicht der des eigentlichen Scripts
++++++++++++++++++++++++++++++++++++++++++++
function_name()
{
Aktionen

return <Wert>
}

function_name #aufruf der Funktion function_name
++++++++++++++++++++++++++++++++++++++++++++
--> Wird kein Funktions **return* Wert zurückgegen, so entsprciht der Rückgabewert der des letzten ausgeführten Befehls


**typeset** --> Informationen über definierte Shellfunktionen in der aktuellen Shell abfragen
-F --> nur die Namen der definierten Funktionen ausgeben
-f --> alle definierten Funktionen vollständig auseben

TRICK: Eine Bibliothek mit Shellfunktionen anlegen
(1) Eine Datei my_lib.sh anlegen die die gewünschten Funktionen enthalten
(2) sourcen der Datei zu Beginn des Scripts
+++++++++++++++++++++++++++++++++++++++++++++++
#!/bin/bash
. my_lib.sh
+++++++++++++++++++++++++++++++++++++++++++++++
Bespiel:
+++++++++++++++++++++++++++++++++++++++++++++++
toupper()
{
echo $* | tr '[:upper:]' '[:lower:]'
}
+++++++++++++++++++++++++++++++++++++++++++++++

__Here Dokumente__
+ bietet einen Codeblock der von einem Kommando anschließende eingelesen und verarbeitet werden kann
+ der Codeblock wird mit einem Schlüsselwort beendet, welches vorher festgelegt wird. Meist EOF oder EOL
+ dem lesenden <Befehl> wird mittels **<Befel> << <Schlüsselwort> ** das <Schlüsselwort zum Ende des lesens mitgeteilt

Beispiel:
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
grep << EOF --line-buffered -f - $fifo | while read LINE
ALARM
WARNING
FAIL
EOF
	do 
		AKTION
	done
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 

__Mit **read** Zeilen von der Standardeingabe__

**read <VAR1> ... <VARn>** --> liest von der Standardausgabe und weist <VAR1> bis <VARn> den übergebenen Wert zu
-a --> weist mehrere Werte der Variable als Array zu
-e --> benutzt readline, verhidnert hässliche Ausgaben beim benutzen der <Backspace> <entf> Taste
-p " Prompt" --> defineire einen Eingabeprompt
-t <Seconds> --> nach <Seconds> read mit einem exit > 0, falls keine Eingabe erfolgt ist
-s --> den Input nicht auf dem Terminal ausgeben sondern nur den Wert in die Variablen einlesen
-n <N> --> nach N Zeichen wird die Eingabe beendet

Beispiel:
--> Dem Benutzer eine Frage stellen
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++
read -e -n 1 -p "Abbrechen? (y/n)" ANSWER
${ANSWER:="y"}

while read -n 1 -p "Abbrechen (y/n)" ANSWER
	do
		case $ANSWER in
			[yY]*) result=0; break
			;;
			[nN]*) result=1; break
			;;
			[jJ]*) result=0; break
			;;
			*) echo "Bitte antworten Sie mit j(y) oder n"
		esac
	done
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Beispiel:
--> in Muster in einer Schlefife verarbeiten 
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++
grep --line-buffered <Muster> <Datei> | while read line
	do
		AKtion mit $line
	done
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++

__Eine Menuauswahl mit select erstellen__
+ Mit dem Shell Schlüsselwort select lassen sich einfache Auswahlmenüs erstellen

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++
select <VARIABLE> in [Liste der Möglichen Antworten]
	do
		<Befehlsliste>
	done
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ Select präsentiert eine Auswahl mit einer Zahl
+ Wird Zahl eingegeben, wird <Befehlsliste> für diese Möglichkeit ausgeführt
+ select versteht ebenfalls **break** und **continue**

__Mit dialog einen grafischen Dialog erstllen__
**dialog <Option> <Boxoption>** --> erstellt ein interaktives grafisches Menu auf Basis von ncurses
--clear --> den Bildschirm vor Anzeige des Menus löschen
--title --> den Titel für die Box festlegen

Beispiele:
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++
**dialog --calendar "Welcher Tag ist heute" 20 20** 
--> erstellt einen Kallendar mit dem Text "Welcher Tag ist heute"
--> liefert den eingestellten Wert in Tag/Monat/Jahr

**dialog --timebox "Wann?" 5 5** 
--> erstellt eine einstellbare Uhr
--> liefert Stunde:Minute:Sekunde


**dialog --checklist "Was möchten Sie gerne?" 12 40 4 "H" "Hamburger" on "C" "Chesseburger" off**	
--> erstellt eine Checkliste in der der Menüeintrag Hamburger bereits ausgewählt ist und der Menueintrag Cheeseburger 
    nicht ausgewählt ist 

**dialog --dselect /home 20 20 **
--> erstellt einen Dialog zur Auswahl eines Verzeichnisses beginnend bei /home

**touch /home/l1uard/emptyfile; dialog --editbox /home/l1zard/emptyfile 20 20**
--> erstellt eine leere Box zum editieren

**dialog --fseclect $HOME/ 20 20 **
--> erstellt einen Dialog zur Auswahl einer Datei beginnend beim Heimatverzeichnis des  Benutzeres

**df |tail -1 |awk '{print $5}'|tr -d % |dialog --gauge used 20 20**
--> erhält die Prozentzahl des letzten von df erfragten Geräts und präsentiert ein grafische Prozentanzeige

**for ((i=0; $i<=100; i=i+5 )); do echo $i; sleep 1;done |dialog --gauge Test 20 20**
--> erstelt einen Fortschrittsbalken der pro Sekunde um 5 Porzent anwächst 

**dialog --infobox '!Programm beendet!' 10 25**
--> erstellt eine leere Box mit der Information "!Programm beendet!"

**dialog --inputbox "Wirklich abbrechen? (Ja eintippen)" 20 30**
--> erstellt eine Box in der Nutzer eine Eingabe eintragen können.

**dialog --inputmenu "Korregieren sie diese Wörter"  40 40 60 "F" Fraege "K" "Komputer"**
--> erstelle eine Menubox in der der Nutzer die Menueinträge bearbeiten kann

**dialog --msgbox '!Programm beendet!' 10 25**
--> erstellt eine Message box dessen lesen mit OK bestätigt werden muss

**dialog --pause "Machmal Pause" 8 200 600**
--> erstellt eine Box in der ein Balken angezeigt wird, der für die Länge von 600 Sekunden rückwärts 

**dialog --passwordbox "Geheim" 8 26** 
--> erstellt eine Box in der Text eingegeben werden kann, der nicht angezeigt wird

**dialog --radiolist Choose 30 30 40 "Mo" Montag off "Di" Dienstag off "Mi" Mittwoch off Do "Donnerstag" off Fr "Freitag" 
off Sa "Samstag" off So "Sonntag" off**
 --> erstelltt eine Liste mit Einträgen, von denen genau eine ausgewählt werden kann

**sudo dialog --tailbox /var/log/messages 30 120**
--> erstellt eine Box mit dem Inhalt der Ausgabe **tail -f /var/log/messages**

**sudo dialog --textbox /var/log/messages 30 120**
--> erstellt eine Box mit dem blätterbaren Inhalt der gesamten Datei /var/log/messages

**dialog --yesno "Kann man diese Frage richtig beantworten?" 6 45**
--> erstellt eine Box mit einer Entscheidungsfrage

!! Das Programm dialog schreibt seine Ausgabe nach Stderr !!

**result=$(dialog --menu "Test" 12 40 4 H "H" A "A"  2>&1 1> $(tty))** 
**result=$(dialog --yesno "Kann man diese Frage richtig beantworten?" 6 45 2>&1 1> $(tty) && echo yes || echo "no")** 
--> schreibt die Ausgabe von dialog in die Variable result

===sed===
+ automatische Maninpulation von Datei-Strömen
+ Manipulation von Datenströmen die keine Interaktion mit einem User erforedern (Shell Scripte)
+ Dabei ist ein Datenstrom die Standartein- und ausgabe bzw. eine/mehrere Dateien (Um jede Datei seperat zu behandeln -s 
  verwenden)
+ Sed liest den Datenstrom der Datei Zeile für Zeile ein und manipuliert Zeile für Zeile nach einem gefundenen Muster

**sed <Optionen> <Skript> <Eingabedatei>** --> Aufruf von sed 

**sed <Optionen> '<Startadresse>,<Stopadresse><Befehl vor Patternsapce>/<Patternspace>/<Holdspace>/<Befehl nach Holdspace>'
-n --> Ausgabe des Patternspace unterdrücken
-e --> Meherer Verarbeitungsbefehle an eine Datei anhängen **sed -e <BEFEHL1> -e <BEFEHL2> <Datei>** 
-i ~<suffix> --> Eingabedatei ist dasselbe wie Ausgabedatei bzw. wenn Suffix angegeben wurde, wird Backup mit
	     --> Dateiname.<suffix> angelegt
-f <Datei> -->  Sed Befehle von Datei einlesen
-r --> Reguläre Expressions einschalten

!! sed ... datei.txt > datei.txt  wird die Datei zerstören !! 

__Pattern Space und Hold Space__
$$Patternspace$$ --> Das ist der Puffer in dem eine Zeile geladen wird, wenn sie ienem bestimmten Muster entsprach

$$Holdspace$$ --> Nach der Bearbeitung der Zeile wird diese von den Pattern in den Holdspace kopiert

**sed '/[Muster]/x'** --> vertaucht Paatern und Holdspace

$$Input Stream$$ --> von hier liest sed. in der Regel eine Datei oder ein Datenstrom

$$Output Stream$$ --> die Ausgabe die nach Stdout geschrieben wird

+++++++++++++++++++++++
#!/bin/sed -f

<Sed-Kommandos>
+++++++++++++++++++++++
--> erstellen eines ausführbaren sed-Scripts

__Möglichkeiten Zeilen in sed zu adressieren__
N --> Eine Zahl als Zieladresse hat die Nummer N von dort wird fortlaufend weitergezählt auch wenn die Eingabe aus 
      mehreren Dateien besteht

/Ausdruck/ --> Reguläre Ausdruck selektiert alle Zeilen die auf Ausdruck passen

N,M --> Zeilen N bis einschließlich M

1,/^$/ --> Alle Zeilen bis zur ersten Leerzeile 

1,$ --> alle Zeilen der Eingabe ($ bezeichnet hier die letzte Zeile der Eingabe)

$ --> Die letzte Zeile der Eingabe

/Starte/,/Stoppe/ --> alles zwischen Muster Starte und Muster Stoppe auswählen

/^BEGIN/,/^END/ --> alle Zeilen zwischen BEGIN am anfang der Zeile beginnen und mit END am Anfang der Zeile aufhören

N! --> adressiert alle Zeilen der Eingabe ausser der N-ten

/^BEGIN/,/^END/! --> adressiert alle Zeilen der Eingabe die nicht Zeil eines BEGIN-END Blocks sind

0,/Regexp/ --> beginnt die Suche nach Regex bereits in der ersten Zeile, falls Regex gefunden wurde Stoppe

__Ausgeben und Löschen von Zeilen__
d --> Patternsapcebefehl --> löschen (delete) von auf Adressierung oder Ausdruck passenden Zeilen
  --> Paarverweis Adressierung
  --> Input Stream
  --> Pattern Space
**sed '11,$d' ** --> löscht die Zeilen 11 bis Endzeile aus dem Patternspace **head**

p --> Ausgeben (print) von auf Adressierung oder Ausdruck passenden Zeilen
  --> Paarverweis Adressierung
  --> Input Stream
**sed '1,10p' --> gibt nur die Zeilen 1,10 aus **head**

q --> Abbrechen des Eingabestrohms nach Adressierung
  --> Einzelverweis Adressierung
**sed -e '10q'** --> Bricht die Ausgabe des Datenstrohm nach den ersten 10 Zeilen ab und unterdrückt mit -n die Ausgabe

= --> gibt die Nummer der Zeien aus die im Patternspace gefunden wurden
  --> Output Stream

__Einfügen und Verändern__
i --> Einfügen (insert) von Zeichen vor Adresse 
  --> Einzelverweis  Adressierung
  --> Output Stream
** sed -e '/ABCD/i <<<' testfile ** 

a --> Anhängen (append) von Zeichen hinter Adresse
  --> Einzelverweis Adressierung 
  --> Output Stream
**sed -e '1~2 worta' testfile**

c --> Austauchen der gefundenen Zeile durch eine selbstdefinierten String
  --> Paarverweis Adressierung
  --> Output Stream
**sed -e '/ABCDEFG/c\123456' testfile** --> Austauchen des Musters ABCDEFG durch 123456

y --> Suchen von Zeichen in Patternspace und ersetzen durch Zeichen in Holdspace
  --> Paarverweis Adressierung
  --> Pattern Space
**sed -e 'y/ABCDEFGH/1234567/' testfile**

w --> Anfügen des Patternspace in an eine Datei
  --> Paarverweisadressierung
  --> Pattern Space
**sed -n '/F/w out.log' Standorte** --> liest aus der Datei Standorte und schreibt alle Zeilen die auf F passen in die 
					Datei out.log

__Suchen und Ersetzen__
s --> suchen nach Muster in Patternspace und ersetzen des ersten Treffer durch String im Holdspace
  --> Paarverweis Adressierung
  --> Pattern Space
TRICK: 
**sed 's/Ausdruck/(&)'**  --> & ist ein sed Special Character der sich auf den Patternspace bezieht und die ()  oder
			      beliebige Zeichen davor oder dahinger anfügt

**sed 's/Ausdruck/&&'** --> fügt den gefunden Ausdruck im Patternspace im Holdspace an  

g --> alle (global) Treffer im Patternspace durch denen im Holdspace ersetzen
  --> Paarverweis Adressierung
  --> Pattern Space
**sed  -e 's/^\<A.*\>/ /g' testfile** --> entfernt aus allen Zeilen die mit A anfangen das erste Wort


__Verschiedene Delimiter einsetzen__
Das erste Zeichen hinter dem Befehl ist ein Delimiter. Konventionell setzt man // als Delimiter ein. Aber man 
kann auch jedes(!) andere Zeichen verwenden, dass nicht im Muster oder im Replacementsstring vorkommt So kann man 
mittels **s_/usr/bin/_/bin_g** sed auch ohne lästiges Quoten der // im Pfadname verwenden.

__Das & Zeichen__
+ Korrespondiert zu dem Muster was gefunden wurde im Hold Space und fügt diesem Zeichen an.
** sed 's/[a-z]*/(&)' Datei** --> schließt jedes durch den Ausdruck [a-z]* gefunden Muster in Klammern ein

**sed '/<Muster>>/& &/ Datei'** --> Jedes <Muster> das gefunden wird, wird an <Muster> in Holdspace angehängt, Wiederholung möglich

__Arbeiten mit meheren gefundenen Mustern__
+ Sed kann sich bis zu 9 Muster merken die dann anschließend adressiert werden können.
+ diese können durch \N im Holdspace und /N im Output Stream adressiert werden

**sed 's/\(Muser1\) \(Muster2\)/\2 \1/'** --> vertauscht das erste vorkommen von Muster1 mit dem von Muster2  

**sed 's/Muster/String/2g'** --> nur jedes 2-te Vorkommen von Muster durch String ersetzen

+----------+------------------------------------------+-------------+-------------+--------------+-------------+----------+
|Befehl    |Beschreibung                              |Adressierung |Input Stream |Output Stream |Pattern Space|Hold Space|
+----------+------------------------------------------+-------------+-------------+--------------+-------------+----------+
| =        | ausgeben der aktuellen Zeilennummer      | -           | -           | -            | -           | -        |
+----------+------------------------------------------+-------------+-------------+--------------+-------------+----------+
|a\ <Text> |anhängen von <Text> nach Adressierung oder| 1           | -           | +            | -           | -        |
|          |Muster                                    |             |             |              |             |          |
+----------+------------------------------------------+-------------+-------------+--------------+-------------+----------+
|b Label   |Verweis auf Label ansonsten auf Ende des  | 2           | -           | -            | -           | -        |
|          |Scripts                                   |             |             |              |             |          |
+----------+------------------------------------------+-------------+-------------+--------------+-------------+----------+
|c\ Text   |ersetzen der passenden Zeile durch Text   | 2           | -           | -            | -           | -        |
+----------+------------------------------------------+-------------+-------------+--------------+-------------+----------+
|d         |löschen des Pattern Space                 | 2           | +           | -            | +           | -        |
-----------+------------------------------------------+-------------+-------------+--------------+-------------+----------+
|D         |löschen des Pattern Space bis zum nächsten| 2           | +           | -            | +           | -        |
|          |Zeichen Nl                                |             |             |              |             |          |
+----------+------------------------------------------+-------------+-------------+--------------+-------------+----------+
|g         |global: ersetzt Pattern Space durch Hold  | 2           | -           | -            | +           | -        |
|          |Space                                     |             |             |              |             |          |
+----------+------------------------------------------+-------------+-------------+--------------+-------------+----------+
|G         |global: anfügen des Hold Space an den     | 2           | -           | -            | +           | -        |
|          |Pattern Space                             |             |             |              |             |          |
+----------+------------------------------------------+-------------+-------------+--------------+-------------+----------+
|h         |global: ersetzen des Hold Space durch den | 2           | -           | -            | -           | +        |
|          |Pattern Space                             |             |             |              |             |          |
+----------+------------------------------------------+-------------+-------------+--------------+-------------+----------+
|H         |global: anfügen des Pattern Space an Hold | 2           | -           | -            | -           | +        |
|          |Space                                     |             |             |              |             |          |
+----------+------------------------------------------+-------------+-------------+--------------+-------------+----------+
|i\ Text   |einfügen von Text vor Adresse  oder Muster| 1           | -           | +            | -           | -        |
+----------+------------------------------------------+-------------+-------------+--------------+-------------+----------+
|l         |ausgeben des Pattern Space, Sonderzeichen | 1           | -           | +            | -           | -        |
|          |werden oktal dargestellt                  |             |             |              |             |          |
+----------+------------------------------------------+-------------+-------------+--------------+-------------+----------+
|n         |ausgeben des Pattern Space, nächste Zeile | 2           | +           | -(+)         | -           | -        |
|          |lesen (-n Inhalt von Pattern Space ausge- |             |             |              |             |          |
|          |ben und durch nächste Zeile ersetzen)     |             |             |              |             |          |
+----------+------------------------------------------+-------------+-------------+--------------+-------------+----------+
|N         |nächste Zeile a Inhalt des Pattern Space  | 2           | +           | -            | +           | -        |
|	   |anfügen, Inkrement                        |             |             |              |             |          |
+----------+------------------------------------------+-------------+-------------+--------------+-------------+----------+
|p         |ausgeben des Pattern Space                | 2           | -           | +            | -           | -        |
+----------+------------------------------------------+-------------+-------------+--------------+-------------+----------+
|P         |ausgeben des ersten Teil des Pattern Space| 2           | -           | +            | -           | -        |
|          |bis zum ersten Nl                         |             |             |              |             |          |
+----------+------------------------------------------+-------------+-------------+--------------+-------------+----------+
|q         |Abbruch eines Befehls falls Adresse oder  | 1           | -           | -            | -           | -        |
|          |Muster erreicht                           |             |             |              |             |          |
+----------+------------------------------------------+-------------+-------------+--------------+-------------+----------+
|r Datei   |anhängen von Datei nach Adresse / Muster  | 1           | -           | +            | -           | -        |
+----------+------------------------------------------+-------------+-------------+--------------+-------------+----------+
|s/R1/T/   |tauscht ein von R1 vorkommenden Regex     | 2           | -           | -            | +           | -        |          
|          |gegen einen String T aus, falls g am Ende |             |             |              |             |          |   
|          |im gesamten Input Stream ansonsten nur    |             |             |              |             |          |
|          |erstes Vorkommen                          |             |             |              |             |          |
+----------+------------------------------------------+-------------+-------------+--------------+-------------+----------+
|t Label   |Verweis auf Label, falls der letzte Befehl| 2           | -           | -            | -           | -        |
|          |den Pattern Space verändert               |             |             |              |             |          |   
+----------+------------------------------------------+-------------+-------------+--------------+-------------+----------+
|w Datei   |schreibe Änderungen in Datei              | 2           | -           | -            | +           | -        |
+----------+------------------------------------------+-------------+-------------+--------------+-------------+----------+
|x         |vertausche Pattern Space und Hold Space   | 2           | -           | -            | +           | +        |
+----------+------------------------------------------+-------------+-------------+--------------+-------------+----------+
|y/a/z     |übersetze alle Vorkommen der Zeichen a    | 2           | -           | -            | +           | -        |
|          |durch z                                   |             |             |              |             |          |
+----------+------------------------------------------+-------------+-------------+--------------+-------------+----------+

===Die Programmiersprache AWK===
+ interptierte Programmiersprache zur verarbeitung von Textdateien
+ Operationen auf Strukturierte Daten durchführen
+ Informationen aus Dateien sammeln und daraus Reports und Logfiles generieren
+ Dateien von einem Format in ein anderes konvertieren
+ erstellen kleinerer Datenbanken
+ mathematische Operationen auf Zahlenbasierten Informationen von Dateien ausführen



**awk <Optionen> '/<Ausdruck>/ <{Anweisungen}>' <Datei>** --> Aufruf von awk von der Kommandozeile
					       --> ein awk Aufruf besteht immer aus einer Anweisung und 
                                                   optional aus einem Ausdruck
                                               --> der komplette Aufruf muss in '' gesetzt sein	

'/Ausdruck/' --> ein regulärer Ausdruck
             --> muss durch die Form /Ausdruck/ kenntlich gemacht werden
             --> muss vor den Anweiseungen stehen

**awk '/^A.*/ {print}' Datei** --> filtert Datei nach allen vorkommen mit A Anfnag der Zeile
-F --> festlegen des Spaltentrenners (wie cut -d)

++++++++++++++++++++++++++++++
#!/usr/bin/awk -f
# Kommentar
/Ausdruck/ {Anweisung} 
++++++++++++++++++++++++++++++
--> erstellen eines ausführbaren Scripts

__Wie awk Dateien sieht__
+Jede Zeile ist ein Record
+Jedes Wort, welches durch den Fieldseperator getrennt wurde, falls nicht ist FS=<leer> ist eine Spalte


__Der Anweisungsblock__
++++++++++++++++++++++++++++++++++++++++++++++++
{
BEGIN {
	Anweisung1 vor dem lesen der Datei; 
	...
	AnweisungN vor dem lesen der Datei;
      }
	{ Anweisung1 während des lesens der Datei;
	 ...
	  AnweisungN während des lesens der Datei;
	}
END  {
	Anweisung1 nach dem kompletten lesen der Datei;
	...
	AnweisungN nach dem kompletten lesen der Datei;
     }
}
++++++++++++++++++++++++++++++++++++++++++++++
--> Anweisungen innerhlalbs eines Blocks werden durch Semikolon getrennt 
--> BEGIN; END werden in extra {} geklammert
BEGIN {} --> Kommandos vor dem lesen der Eingabe
END {} --> Kommandos nach dem lesen des letzten Datensatzes

**ls -l *.txt|awk 'BEGIN {sum=0} {sum = sum + $5} END {print sum}'** --> adieren der Gesamtgröße aller auf .txt 
                                                                         endenten Datien

print --> Ausgeben eines Elements
**awk '{print item1 item2 ...}' Datei**

printf --> Ausgeben und Formatieren der Ausgabe
       --> OFS ORS Variablen haben keine Auswirkung auf printf
       --> einzelne printf Argumente müssen duch , getrennt werden
**awk '{printf Formatierungi, item1, item2, ...}' Datei**

%c --> item wird als ASCII Verweis behandelt
Beispiel:
**awk '{printf "%c", 65}' 

%i --> Ausgabe eines Integers

%N$ --> Ausgabe von Print N mal

%- --> linksbüdnig ausrichtigen

"%Ms" --> die minimale Weite M eines Feldes festlegen und entsprechend einrücken
Beispiel:
**awk {printf "%4s, foobar}**

!! Tipp: Alle Formatierungen lassen sich miteinader kombinieren !!
**awk '{ printf "%-10s %s\n", $1, $2 }' BBS.lst**


__Umleitungen und Spezielle Dateien__
+ prozess basierte Informationen
+ Standard Dateidescriptoren 

> >> | --> steht innerhalb einer print Anweistung so wird der Umleitungsoperator von awk und nicht von der Shell behandelt
**awk ’{ print $2 > "phone-list" print $1 > "name-list" }’ BBS-lis**

/dev/stdin --> 0

/dev/stdout --> 1

/dev/stderr --> 2

/dev/fd/N --> file Descriptor N

\\ Proc tree \\ und \\ Sys tree \\

Spezial Files müssen gequotet werden wie in etwa hier
**awk '{print "Serious error detected!" > "/dev/stderr"}'**


__lange Zeilen maskieren__
Eine ser lange Anweisungszeile kann durch maskieren \ des Nl auf mehrere Zeilen verteilt werden

**awk {print "Diese Zeile wird zulang um sie auf \
eine Zeile zu verteilen."}**

__Variablen in awk__
+ gültig sind abc, abc2, _abc_ _123_
+ ungültig sind 1abc, &abc; #abc, print, printf
+ awk unterscheidet zwischen Integer und String
+ Mit $ wird wie in Bash auf den Wert der Variablen also deren Inhalt zugegriffen
+ Eine Variable wird mit ihrem ersten erscheinen deklariert, muss nicht vorher bekannt gegeben werde+ Eine Variable wird mit ihrem ersten erscheinen deklariert, muss nicht vorher bekannt gegeben werdenn

Var=Wert --> Zuweisung  
         --> durch Zuweisung eines neuen Wertes an eine bestehende Variable, wird der alte Wer überschrieben

+ awk kennt die üblichen Rechenoperationen + - * / % ^

--> var+=wert var*=wert var^=wert inkrementiert
--> var-=wert var/=wert var%=wert dekrementiert

var-- var++ --> nach Durchführung einer Anweisung um 1 dekrementieren / inkrementieren

++var --var --> vor Durchführung einer Anweisung um 1 dekrementieren / inkrementieren

__Buildin Variablen__
+ haben bestimmte Verweuse auf Anweisungne oder Input Stream

$0 --> kompletter Inhalt einer eingelesenen Zeile, Wert wird verändert bei neuer Feld Zuweisung 

$N --> Inhalt der Spalte N in einer Zeile

NF --> Anzahl der Felder pro Record

$NF --> Das letzte Feld eines Records

ARGC --> Anzahlder übergebenen Zeilen

ARGV --> Array, enthält die übergebenen Argumente

CONVFMT --> Formatierung von Zahlenwerten in Strings **CONVFMT="%.15g"** (15 Nachkommastellen) 

ENVIRON --> Array, enthätl die Shellvariablenumgebung

FILENMAE --> Inputdatei, beim Wechseln der Inputdatei wird eder Wert neu eingelesen

FNR --> Anzahl der bereits verarbeiteten Zeilen

FS (field Seperator) --> der durch -F gesetzte Spaltentrenner, kann entweder ein Zeichen oder eine Regex sein

Beispiel:
**FS=", \t"** --> Komma gefolg von einem Leerzeichen mit einem Tab wird als Spaltentrenner gesehen
**FS=""** --> Leerer Feldseperator, jeder Buchstabe wird als einzelner Record behandelt

IGNORECASE --> Regel für das Behandeln von Sensitiver Schreibung festlegen, falls Wert auf 1 gesetz wird groß und kleinschreibung ignoriert
	   --> beeinflußt den Wert von FS nur wenn FS als Regex angegben wurde

NF (Number Fields) --> Spalten pro Zeile, $NF evaluiert nach dem Inhalt der letzten Spalte,  Variable wird nach Zeile neu eingelesen
		   --> Wert wird nicht verändert bei neuer Feld Zuweisung
		   --> falls NF dekrementiert wird ändert sich der Wert von $0

OFMT --> Output Format

OFS --> Separierung der Ausgabezeilen; Trenner für Output Stream

ORS --> Separator für einzelne Zeilen (/n) Output Stream

RLENGTH --> Länge die durch die Funktion math()  gefunden wurde

RS --> Sperator der Eingabzeilen (/n) Eingabe, kanne entweder ein Zeichen oder eine Regex sein

Beispiel:
**RS="\n\n+"** --> matched ein Newline gefolgt von einer oder mehereren Zeilen

RSTART --> Anfangsposition des regulärer Azsdruck der Funktion math()

SUBSEP --> Separierungszeichen der einzelenen Aray-Elemente
 

__Arrays__
+ Arrays können mehrere Werte an eine Variable übergeben

Array[Index] --> zugreifen auf ein Element eines Arrays 

if(<String> in Array) --> testet ob es einen Index M in Array gibt

delete Array[Index] --> löscht das Array mit dem Index

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
**awk 'BEGIN {Array[1]=3; Array[2]=4; Array[3]=5} {print Array[1] Array[2] Array[3]}'** --> Zuweisung und ausgeben von Arrays
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

+ awk unterstützt assoziative Arrays. die es erlauben statt eines numerischen Wertes Zahlen zu übergeben kann man
  die Elemente benennen und bereits benannte Arrays assoziativ verknüpfen

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
use[$NF] = use[$NF] " " $1 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
--> der Variable mit dem Index NF werden auf alle Felder $NF assoziert und dann das Feld $1 hinzugefügt

+ Mit delete entfernen eines ELements von einem Array
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
**awk '{delete Array[1]}'**                                                         --> ein bestehendes Array löschen
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

__Bedingte Anweisung__
+ zur Laufzeit einen Wert prüfen. Ist der Wert vorhanden soll eine Anweisung asugeführt werden
++++++++++++++++++++++++++++++++++++++++++++
if(Bedingung) {
   Anweisungen1
} else {
   Anweisungen2
}
+++++++++++++++++++++++++++++++++++++++++++

__Vergleichsoperatoren__
x <y               Kleiner
x <= y             Kleiner oder gleich
x >y               Größer
x >= y             Größer oder gleich
x == y             genau gleich
x != y             ungleich
x ~y               x entspricht der Regex y
x !~ y             x entspricht nícht der Regex y

TRICK:
++++++++++++++++++++++++++
if (data[$0]++ == 0)  --> genau dann Wahr wenn der Wert von $0 zum ersten mal gesehen wird.
++++++++++++++++++++++++++

__Schleifen__
**while Schleifen**
+ Eine Anweisung wird solange asugeführt, wie eiene Bedingung erfüllt ist

+++++++++++++++++++
while (Bedinung){
	Anweisung
}
++++++++++++++++++

**do-while-Schleifen**
+ while Schleife mit mehreren Anweisungen
+ führe die erste Anweisung auf jeden Fall aus
+ führe alle weiteren nur, falls Bedingung

+++++++++++++++++++++++++++++
do {
    Anweisungsblock1
   } while (Bedingung) {
	Anweisungsblock2
     }
++++++++++++++++++++++++++++   

**break** --> Abbruch der Schleife, Anweisung

**continue** --> Abbruch des aktuellen Schleifendruchlaufs, danach Fortsetzunh beim nächsten Durchlauf

**for Schleifen**
+ Für jedes Element innerhalb eines bestimmten Definitionsintervall wird eine Aktion ausgeführt
+++++++++++++++++++++++++++++++++++++++++++++++++++
for (Beginn=wert; Beginn < Bedingung; Beginn++){
	ANWEISUNGSBLOCK
	}
+++++++++++++++++++++++++++++++++++++++++++++++++++


__Funktionen__
+ implementierte und buildin Funktionen unterschieden
+ erhalten Parameter zur Verarbeitung die einen Wert zurückliefern
+++++++++++++++++++++++++++++++++++++++++++
function Name (Parmeter1,...,ParameterN) {
	ANWEISUNGSBLOCK
}
+++++++++++++++++++++++++++++++++++++++++++
Beispiel: 
++++++++++++++++++++++++++++++++++++++++++
awk '
function mittel(a, b, c) {
mittelwert=(a+b+c)/3
print mittelwert
}

BEGIN {
 mittel(1, 2, 3)
}'
++++++++++++++++++++++++++++++++++++++++++

**return** 
Übergeben von Werten an eine Funktion oder Variable

__Buildin Funktionen__
atan2(y,x); cos(x); exp(x); int(x); log(x); rand(); sin(x); sqrt(x);

print; lenth; range(x,y);

system(cmd) --> Ausführen des Kommandos und Rückgabe des Exitstatus 

match (s, r[,a]) --> gibt die Position in s aus in der die Regex erschreint

sub --> wie sed 's/a/b/g'

next --> Stoppe das Einlesen des aktullen Records und mache beim nächsten Record weiter

nextfile --> Stoppe das Einlesen der aktuellen Datie, der nächste Record wird aus der nächsten Datei gelesen

__1 Zeiler__
**awk 'END{print NR}' Datei** --> Anzahl der Zeilen einer Datei

**awk 'NR == 10' Datei** --> Ausgabe der 10. Zeile von Datei

**awk 'NF > 4' Datei** --> AUsgabe aller Zeilen mit mehr als 4 Felder / Wörter von Datei

**awk '{nw+=NF} END{print nw}' Datei** --> Gesamtzahl der Wörter / Felder von Datei

**awk '/Ausdruck/ {++cnt} END {print cnt}' Datei** --> Anzahl der Zeilen von Datei die auf Ausdruck passt

**awk 'NF > 0' Datei** --> Jede Zeile ausgeben, die mindestens 1 Feld / Wort enthält

**awk 'length($0) > 80' Datei** --> gibt alle Zeilen aus, die mehr als 80 Zeichen haben

**awk '{tmp=$1; $1=$2; $2=tmp; print' Datei** --> vertauscht die ersten beiden Felder

**awk '{print NR, $0}' Datei** --> gibt jede Zeile von Datei mit Zeilennummer aus

**awk '{$2=""; print}' Datei** --> Jede Zeile ausgeben und vorher das zweite Feld löschen

**awk { if (data($0)++ == 0); print } Data** --> Ausgabe nur wenn die Eingabezeile zum ersten mal gesehen wurde, ein verbessertes uniq

===SQL (Structured Query Language)===

__Mysql einrichten__
(1) Installieren mysql mysql-client
(2) **chkconfig --add mysqld
(3) **/etc/init.d/mysql start
(4) **/usr/bin/mysql_secure_installation**
(5) An Mysql anmelden **mysql -u root -p** meldet den rootbenutzer am Mysql Datenbank Server an und fragt nach Passwort


+ zur Abfrage und Manipulation relationaler Datenbanken

**sqlite3 Datenbank.db** --> erstelle eine neue Datenbank für sqlite3
**CREATE DATABASE <Name> CHARACTER SET <Zeichensatz>;** --> in mysql eine Datenbank <Name> basierent auf <Zeichensatz> erstellen 

__Relationale Datenbanken__
+ bestehen aus einer / mehrerer zueinander in Beziehung stehender Tabellen
+ Spaltenköpfe stehen Feldnamen, beschreibt ein Attribut
+ Zellen enthalten eindeutig verifizierbare Werte 
+ Jede Zeile definiert einen Datensatz(Record) bestehnde aus mehreren zu einander in Beziehung stehenden Feldnamen und deren Werte
+ Tabellen (tables) enthalten dauerhaft gespeicherte Zeilen


__Konzepte__
+ Schema --> Die Struktur der Datenbank inklusive der zulässigen Datenfelder und Datentypen, auch complete logical view

+ Domain --> Der endliche Wertebereich für die zulässigen Datentypen eines Attributes

+ Constraints --> Zeiger auf Schlüsselwerte (Primär Schlüssel, Fremdschlüssel)
	      --> Festlegen von Bedingungen die ein Wert erfüllen muss 
	      --> Verhindern das Eingeben nicht zulässiger Daten
	      --> Festegen eines Primärschlüssels (Mysql)	

+ Primärschlüssel (PRIMARY KEY) --> Ein Attribut, dass eine Zeile __eundeutig__ identifiziert 
				--> Es ist statisch und kann nicht verändert werden
				--> Es können Primärschlüssel aus meherern Tabellenattribute genutzt werden 
					(Zusammengesetzer Primärschlüssel) 
				--> Autoinkementirend wird empfeholen durch **AUTOINCREMENT**  

+ Fremdschlüssel --> verweist auf den Primärschlüssel einer Tabelle oder eine Relation 
                 --> ermöglicht die Vereinigung von Relationen
                 --> muss nicht eindutig sein, so kann ein Kunde mehrere Fremdchlüsselverweise haben, weil er möglicherweise    		  mehere Produkte Produkte gekauft hat auf die der Fremdschlüssel verweist 

+ Views --> ein gespeicherter Query der aus einen oder meheren Teiltabellen bestehen kann. dynamische virtuelle 
            Tabelle
**CREATE VIEW** --> erstellen eines Views
**CREATE VIEW <name> AS <Auswahl Anweisung>** --> erstellen eines Views


+ Anweisung werden mit ; abgeschlossen

__Schema Anweisungen__
+ Zum erstellen der Datenbank wird ein Schema angegeben welches zur Definition der Datenstrukturen
+ kann in einem Texteditor definiert werden
+ es empfiehlt sich die Endung .sql zu verwenden

Definieren einer Tabelle:
++++++++++++++++++++++++++++++++++++++++++++++++++++++
CREATE TABLE Tabellenname
(
	ID(PRIMÄRSCHLÜSSEL) INTEGER PRIMARY KEY,
	ITEM1		    DATENTYP,
	ITEM2		    DATENTYP,
	...
	ITEMn		   DATENTYP,
	CONSTRAINT <Name_des_Constraint> PRIMARY KEY ( Name Bezugsspalte für Primary Key)
);
++++++++++++++++++++++++++++++++++++++++++++++++++++++
Einlesen des Schemas in eine Datebank
**sqlite3 datenbank.db < Schema.sql**

__Datentypen__
**Zeichenbasiert**
+ bestehen aus Strings fester oder variabler Größe
	CHAR(n)	    --> Eine Zeichenkette fester Größe mit der Länge n (64-Kbyte)

	VARCHAR(n)  --> Eine Zeichenkette varibalen Größe der maximallänge n (64-Kybet)

	TinyText    --> Mehreere Zeichenketten (255 Zeichen)
	
	Text	    --> Meherere Zeichenketten (65.535 Zeichen)

	Mediumtext  --> Meherere Zeichenketten (16.777.215 Zeichen)

	Longtext    --> Mehrere Zeichenketten (4.294.967.295 Zeichen)
	
**Zahlenbasiert**
	Tinyint     --> Wertebereich -128 - 127 | ohne Vorzeichen 0 - 255
	
	Smallint | Mediumint | Int | Bigint

	Double(p,s) | Float(p,s) --> Fließkommazahlen mit Präzsion nahe p der Länge s festlegen

**Datums/Zeitbasiert**
	Date    |   Datetime        | Timestamp              | Year |    Time    | --> Datums und Uhrzeitsabfragen
	YY-MM-DD  YY-MM-DD:hh:mm:ss   Unixtime like Datetime   YYYY   hhh:mmm:ss

	Bool --> Datenwert true, false oder unknown
	
	ARRAY [n] --> ein Array definieren, wenn ein Attribut meherer Werte haben kann (zum Beispiel kann ein Mensch 
	mehrere Telefonnummern haben) Speichere bis zu n verschienden Elemente im Array 
	
	ROW  --> Datentyp der eine Zeile innerhalb einer Zeile definiert
	+++++++++++++++++++++++++++++++++++++++++++++++++++
	+	CREATE ROW CUSTOMER (                     +
 	+   CustID        INTEGER      PRIMARY KEY,       +
	+   LastName      CHARACTER VARYING (25),         +
	+   FirstName     CHARACTER VARYING (20),         +
	+   Address       addr_typ,                       +
	+   Phone         CHARACTER VARYING (15)          +
 	+	  ) ;                                     +
 	+++++++++++++++++++++++++++++++++++++++++++++++++++
**Andere**
	ENUM --> Fetslegen einer eingegrenzten Menge von Zeichen im Werte und Definitionsbereich
	++++++++++++++++++++++++++++
	gender ENUM('m','f') --> Nur m oder f dürfen für den Eintrag in gender verwendet werden
	
	AUTO_INCREMENT --> Der Zähler wird selbständig inkrementiert, nützlich für Primärschlüssel

__TransaktionsAnweisungen__
DESC   --> Anzeigen der Tabellenfrm mit ihren zulässigen Zeichenklassen

**desc <tabellenanme>** --> gibt die Beschreibung für die Tabelle <tabellennamne> aus
**describe <tabellenname>**

USE --> zu einer Datenbank verbinden
**use <database>** --> vorhandene Datenbank <database> laden

SHOW --> Vorhandene Mysql Eelemente auflisten
**show databases** --> alle vorhandenen Datenbanken anzeigen
**show tables** --> alle vorhandenen Tabellen anzeigen
**show character set** --> alle gültigen verfügbaren character sets anzeigen lassen

__Daten Anweisungen__

**Grundlegene Befehle**
ALTER --> Die Tabelle Verändern bzw. der Tabelle neue Spalten hinzufügen

**ALTER TABLE alt RENAME TO neu** --> Tablle mit Namen alt in neu umbenennen
**ALTER TABLE tabelle ADD COLUMN id_horst <Datentype>** --> Das Attribut id_horst zur Tabelle hinzufügen
**ALTER TABLE tabelle modify person_id SMALLINT UNSIGNED AUTO_INCREMENT** --> setzen eines selbst inkrementierenden Primärschlüssels
 
INSERT --> Schreiben von Daten in eine Tabelle
**INSERT INTO <table> (Atrribute,...) VALUES (Werte,...)** --> Fügt in <table> die Attribut mit den Werten ein

**INSERT INTO <table> (Attribute,...) VALUES (Werte_Z1,...),(Werte_Z2,...),...(Werte_Zn)
							   --> Fügt in <table> meherer Attribute mit den Werten ein 

**INSERT INTO <table> SELECT <spalte> FROM <table>** --> Werte von einer Tabelle in eine andere übertragen, falls
							 Dimensionen und Atrribte übereinstimmen

DELETE --> Löschen von Daten aus einer Tabelle
**DELETE FROM <table> WHERE <Bedinugung> --> entfernt alle Werte aus der Tabelle die der <Bedinungung> entsprechen 

DROP --> löschen einer Tabelle
**DROP TABLE <table>** --> entfernt die Tabelle <table> 

UPDATE --> Verändern von Daten in einer Tabelle
**UPDATE <table> SET Atribute=value WHERE <Bedinung>; --> setzt ändert die Atrribute von <table>
						      --> meherere Atribute müssen durch Kommata getrennt sein
__Abfrage Klauseln__
--> Abfragen von Werten aus Tabellen und Views
* --> PLatzhalter / Wildcard entspricht ALL


SELECT --> Auswahl von Daten aus einer Tabelle bzw. aus mehreren Tabellen
**SELECT <Spalte> FROM <Table> WHERE <Bedingung>**
**SELECT version(), user(), database** --> anzeigen der Version von mysql, des angemeldeten Benutzers und der
					   aktuellen Datenbank

**SELECT <Spalte> INTO OUTFILE <Datei> FROM <table>** --> Die Ausgabe in die Datei schreiben, dabei muss der User mysql zugriff auf das Verzeichnis haben


DISTINCT --> festlegen, dass jeder Wert nur einmal angezeigt werden soll
**SELECT DISTINCT <Spalte> from <Table>** --> eindeeutige zuordnungseinheiten
					  --> muss vorher sotiert sein

FROM --> Festlegen der Tabelle

WHERE --> definieren einer Bedinugung, die auf ein item zutreffen soll 
      --> Bedingungen liefern True wenn die Bedinung stimmen soll

$$logische Operatoren$$
=,!=, >, < --> der Wert entspricht, entspricht nicht, ist kleiner, ist größer
<> --> between, Angabe eines inklusiven Intervalls

**SELECT <Attribute,...> FROM <Table> WHERE <Variable> BETWEEN <Untere Schranke> AND <Obere Schranke>**


AND --> logisches Und
OR --> logisches Oder
NOT --> logisches nicht
IS NULL --> testet ob ein Attribut den Wert NULL hat
IN --> enthaltensein von Attributen in einer festgelegten Menge
NOT IN --> nicht enthaltensein von Attributen in einer festgelegten Menge
**WHERE prod_id IN (bal, ball, gabel)**

!!! Verknüpfung von Ausssagen ist mÖglich durch Klammerung !!!
!!! NOT verlangt immer Klammerung!!!
**WHERE end_date IS NOT (NULL) AND (title = 'Teller' OR start_date < '2007-01-01')**

$$Der Ausdruck NULL$$
--> bezeichnet einen Wert der nicht vergeben, leer oder nicht genutzt wurde.
--> nicht zutreffend
--> nicht bekannt
--> nicht definiert

!! Ein Ausdruck kann NULL sein aber nicht gleich NULL !!

$$Arithmetische Operatoren$$
+, - , *, / 

$$Verwenden von Wildcards$$
Wildcards benötigen die Zusatzklausel LIKE
_	matcht gegen ein Zeichen entspricht dem ? bei bash

%	matcht gegen belibig viele Zeichen auch keines entspricht dem * bei bash
**SELECT * from employee WHERE lname LIKE 'M%';**

$$Regualäre Ausdrücke$$
benötigen die Zusatzklausel REGEX

GROUP BY --> Fasst Zeilen mit nach gemeinesamen Spaltenwerten zusammen

HAVING -->  Filtert unerwünschte Ergebnisse heraus

ORDER BY --> Sortieren die Abfrage nach mit Bezug auf dieses Attribut, meist mit SELECT verwendet
**SELECT <values> FROM <table> WHERE <Bedingung> ORDER BY <value> ASC/DESC** 

__Abfragen verbinden__

JOIN --> Relationales Verbinden von Attributen zu einer Abfrage, liefert eine Tabelle zurück
     --> Eine Datenbnak ist umso mächtiger je mehr verknüpfungen sie bilden kann	

$$inner join$$
**SELECT a.<var1_tab1>,a.<var2_tab1>,.., <varN_tab1>, b.<var1_tab2>,...,b.<varM_tab2> FROM <table1> a INNER JOIN b <table2>
ON a.Fremdschlussel = b.Primärschlüssel** --> Falls Fremdschlüssel und Primärschlüssel verschiedene Attributnamen

**SELECT a.<var1_tab1>,a.<var2_tab1>,...,<varN_tab1>,b.<var1_tab2>,...,b.<varM_tab2> FROM <table1> a INNER JOIN b <table2>
USING(Schlüssel)** --> Falls Fremdschlüssel und Primärschlüssel gleiche Attributnamen haben

**SELECT a.<var_tab1>, a.<var2_tab1>,...,<varN_tab1>,b.<var1_tab2>,...,b.<varM_tab2> FROM <table1> a INNER JOIN b <table2>
WHERE <Primärschlüssel> = <Fremdschlüssel>** --> ANSI-SQL Standard JOIN

$$Mehrere Abfragen verbinden$$
+ mehrere Abfrage können durch einen INNER JOIN festgelegt werden

--> erfolgt durch Verschachtelung in mehreren FROM Klauseln
--> Die Reihenfolge der Verknüpfungen spielt dabei keine Rolle
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Besipiel:
mysql> SELECT a.account_id, c.fed_id, e.fname, e.lname
    ->   FROM employee e INNER JOIN account a
    ->   ON e.emp_id = a.open_emp_id
    ->   INNER JOIN customer c
    ->   ON a.cust_id = c.cust_id
    -> WHERE c.cust_type_cd = 'B';
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

--> Durch definieren von Untertabllen und direkten JOIN der daraus resultierenden Tabellen

$$Self Join$$
--> Eine Tabelel mit sich selbst verknüpfen
--> benutzen des von ihm verwendeten Fremd- und Primärschlüssel
--> Um Elemente innerhalb einer Tabelle aufeinenader zu beziehen

**SELECT a.<variable1>,..,<variableN>, <identifier>.<variable1> <alias_var1>,...,<identifier>.<variableN> <alias_varN> FROM
<table> a INNER JOIN <table> <indetifier> ON FREMDSCHLÜSSEL = PRIMÄRSCHLÜSSEL**


$$Equi Joins und NON Equi Joins$$
--> beim Equi Join müssen die beiden Referenzschlüssel miteinander übereinstimmen, werden druch = verknüpft

--> Beim Non Equi Join werden druch die Angabe der beiden Schlüssel ein Wertebereich definiert

===Zeitgesteuerte Vorgänge===
+ Jobs und Aufgaben zu einen bestimmten Zeitpunkt einmalig oder periodisch ausführen

__Mit at Jobs einmalig ausführen__
+ Die Gruppe trusted muss (unter $SUSE$) dem Nutzer 
+ Der at Daemon muss dazu  gestartet sein 
+ at ist beides ein Tool zur Verwaltung von Jobs und eine eventuelle Subshell
+ falls eine Datei \\ /etc/at.allow \\ existiert dürfen nur user die in dieser datei aufgeführt werden at benutzen
  andernfalls existiert \\ /etc/at.deny \\ dürfen alle user die nicht in dieser datei stehen at benutzen
+ \\ /var/spool/atjobs \\ abgelegt

**at <HH:MM> <TIME>** --> einen Job für die gegebene Zeit anlegen
			  --> startet die at-Shell, in der Jobs angegeben werden können
			  --> **Strg-d** beendet die at shell und speichert den entsprechenden job
			  --> sendet eine mail, falls fehler beim ausführen des jobs auftraten
			  --> at wird in der Umgenung ausgeführt in der es aufgerufen wird
			  --> Ausgabemail gehen an den Besitzer der Elternshell 
 
		<TIME> --> absolute oder relative Zeitangaben
		HH:MM tt.mm.jj | HH:MM mm/tt/jj
		now --> jetzt
		midnight --> 0 bzw. 24 Uhr 
		noon --> 12 Uhr Mittags
		teatime	--> 16 Uhnoon --> 12 Uhr Mittags
		teatime	--> 16 Uhr    
		now + N minutes/hours/days/ --> von jetzt an in N /Minuten/Stunden/Tage/

		\\  /usr/share/doc/packages/at/timespec \\

-f <Datei> --> lese den at-Job von der <Datei>, dabei enthält <Datei> mehrere Shellbefehle oder ganzes Shellscript
-l --> alias auf atq
-d | -r N --> zeigt auf atrm und löscht den Job mit der entsprechenden Jobnummer N
-m --> schicke dem Nutzer der at ausgeführt hat eine mail auch dann wenn der Job erfolgreich war
-c N --> ruft cat für den entprechenden at job N auf

!!TRICK: Mit su eine andere Identität annehmen um einen zeitgesteuerten Job als dieser Benutzer auszuführen
	 aber eine Mail an den Besitzer der Elternshell zu schicken

!!TRICK
**echo "<Befehl>"|at <Time>** --> fügt den at job mit dem <Befehl> hinzu und 
			      --> als einzeiler in einer Zeile verwendet

Beispiel mit **logger** zu einem gegeben Zeitpunkt in die logddatei schreiben 
+++++++++++++++++++++++++++++++++++++
at now + 3 minutes
>logger -f /var/log/messages "Zeit für einen Kaffe"
>^D
++++++++++++++++++++++++++++++++++++

**batch <TIME>** --> Einen Prozess in Abhängigkeit der durchschnittlichen Systemlast (unter 0,8) durchführen
	         --> wird <TIME> angegeben wird der Befehl erst frühestens nach ablauf der gegebenen Zeit abgerufen 
		 --> batch kennt die gleichen Optionen wie at

**atq** --> auflisten der Momentan von at eingreihten Jobs:
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
<Jobnummer> <Datum der Ausführung> <Auftragsklasse> <Nutzer>
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	<Auftragsklasse>
		= --> wird gerade ausgeführt
		a-z --> Priorität je höher die Auftragsklasse desto höher der nice Wert 
 		    --> für **at** Standard ist a 
		    --> für **batch** Standard ist b

**atrm <Jobnummer>** --> löschen eines Auftrages

**atd** --> Der at Daemon
-b --> festlegen des Intervalls zwischen den einzelnen batsch Jobs
-l --> festlegen des von batch verwendeten Grenzwertes 

__Zeitgesteuerte Jobkontrolle mit cron__
+ Wiederholtes ausführen von Zeit gesteuerten Jobs
+ falls vor dem  Cronbefehl kein - folgt, wird ausgeführte cronjob von syslogd protokolliert
+ Der cron Daemon muss dazu gestartet sein
+ falls eine Datei \\ /etc/cron.allow \\ existiert dürfen nur user die in dieser datei aufgeführt werden cron benutzen
  andernfalls existiert \\ /etc/cron.deny \\ dürfen alle user die nicht in dieser datei stehen cron benutzen
+ Jeder Nutzer hat seine eigene Crontab in einem der folgenden Verzeichnisse auf die er nur mittels **crontab** Zugriff hat
	$$SuSE$$ \\ /var/spool/cron/tabs \\
	$$Fedora$$ \\ /var/spool/cron/ \\
	$$Debian / Ubuntu$$ \\ /var/spool/cron/crontabs \\

!! Achtung: es gibt verschiedene cron implementierungen !!

**crontab [-u <User>] [<Datei>]** --> anlegen, verwalten und auflisten von cronjobs für Nutzer <User>
			--> wird -u nicht angegeben, dann wird der aktuelle Nutzer benutzt
			--> wird <Datei> angegeben, wird dies als crontab installiert, kann nicht mit -e verwendet werden		
	
-e --> die aktuelle crontan editiren in $EDITOR
-l --> die aktuelle crontab für den Benutzer nach StdOut schreiben
-r --> entferne die aktuelle crontab

+++++++++++++++++++++++++++++++++++++++++++++++
#Dies ist ein Kommentar
VARS=value
...
* * * * * <Befehl> <Zeilentrennerzeichen oder %> 
#Miunten (0-59)
#Stunden (0-23)
#Tag des Monats (1-31)
#Monat des Jahres (1-12)
#Tag der Woche (0-7) #0 und 7 = Sonntag
#Wichtig, falls mail verwendet wird ist % als zeilertrenner anzugeben
+++++++++++++++++++++++++++++++++++++++++++++++
!!! Das Kommando wird ausgeführt wenn Stunde, Minute und Monat genau stimmen und mindestens eines
    der beiden Tageskommandos Tag des MOonats oder Tag der Woche) !!!

$$Angabe von Zeitintervallen$$
	N --> wird dem Feld gemäß zum Zeitpunkt N ausgeführt
	Beispiel:
	** 0 16 * * 5 shutdown -h now ** --> fährt den Rechner jeden Freitag um 16 Uhr herunter
 	
	N-M --> Befehl im Zeitbereich  N und M durchgeführt
	Beispiel:
	**0 1 * * 1-5 mail -s "Ab ins bett" $USER%$USER, %%user go to bed%
	
	N,M --> Angabe von Zeit Grenzbereichen, wobei N und M die obere bzw untere Grenze ist

	N/M --> Angabe einer Schritweite N beginnend beim Zeitpunkt M
	Beispiel:
	** 0 */2 * * * sh -x /root/checkscript** --> führt das Script Checkscript alle Zweistunden zur vollen Stunde aus

$$Angabe von Cronvariablen$$
	SHELL --> die Shell die das Cronkommando ausführt, falls SHELL nicht gesetzt wurde, wird /bin/sh angenommen
	
	LOGNAME --> wird zur laufzeit \\ /etc/passwd \\ entnommen 
		    Ist der Nutzer der die crontab ausführt uns kann nicht geändert werden
	
	HOME --> wird zur Laufzeit aus \\ /etc/passwd \\ entnommen
		 Das Heimatverzeichnis des ausführenden Benutzers,kann geändert werden	
	
	MAILTO="user@Host" --> Die Adresse an die Cron seine Mail sendet

$$Systemweite Aufgabenlisten$$
	\\ /etc/crontab \\ --> vom System auszuführenden Dienste, periodisch auftauchende Systemdienste,zum Beispiel
				aktualliesieren der updatedb
			   --> unter $SuSE$ enthält es ein Script was Systematisch die anderen Ordner abklappert	
	\\ /etc/cron.d/ \\ --> alles was zu einem nicht bestimmten Zeitpunkt ausgeführt wird
	
	\\ /etc/cron.daily \\ --> Shellscripte werden einmal täglich vom System asugeführt

	\\ /etc/cron.hourly \\ --> Shellscripte werden einmal stündlich vom System ausgeführt

	\\ /etc/cron.monthly \\ --> Shellscripte werden einmal monatlich vom System ausgeführt

	\\ /etc/cron.weekly \\ --> Shellscripte werden einmal wöchentlich vom System auasgeführt
 

===Lokalisierung===
+ Anpassung eines internationalisierten System an einen Kulturkreis
+ Tastturlayout 
+ Spracheinstellungen
+ Zeiteinstellungen

__ISO IEC-8859__
ISO-8859-1	LATIN-1		vorwiegende Westeuropa (Dänisch, Deutsch, Englisch, Finnisch, Niederländisch)
						       (Norwegisch, Portugiesisch, Spanisch, Schwedisch, Afrikaans)
						       (Swahili, Gällisch)

ISO-8859-2	LATIN-2		vorwiegendend Mitteleuropa (Bosnisch, Koratisch, Polnisch, Tschechisch, Slowenisch) 

ISO 8859-3	LATIN-3		vorwiegende Südeuropa (Maltesisch, Türkischm Esperanto)

ISO 8859-4	LATIN-4		vorwiegend Nordeuropa (Estnisch, Lettich, Grönländeisch Sami)

ISO-8859-5	Latin/Cyrillic	vorwiegende slwaisch

ISO-8859-6	Latin/Arabic	vorwiegend arbische Zeichen

ISO-8859-7	Latin/Greek	modernes Griechisch

ISO-8859-8	Latin/Hebrew	modernes Hebräisch

ISO-8859-9	LATIN-5		Türkisch

ISO-8859-10	LATIN-6		Eine andere Anordnung von LATIN-4

ISO-8859-11	LATIN/Thai	Für Thai

ISO-8859-12	Latin/Devanagari bisher nicht fertiggestellt

ISO-8859-13	LATIN-7		erweiterung zu LATIN-4 und LATIN-6

ISO-8859-14	LATIN-8		Keltisch

ISO-8859-15	LATIN-9		erweiteres LATIN-1 um € und den im französischen gebrächlichen 

ISO-8859-16	LATIN-10	(Albanisch, Italienisch, Polnisch, Kroatisch, Rumänisch, Slowenisch)


__UTF-8 und ISO 10646__
ISO-10646 	chinesische, japanische, mathematische Formelzeichen
		--> Jedes Zeichen wird ein eindeutig durch die Relation Name ~ Codepunkt (U+xxxx) identifziert, 
		    wobei jedes x eine Hexadezimale Zahl darstellt
		
UCS-2		--> !!! impliziert den doppelten Speicherplatz !!!

UTF-8		--> rückwärtskompatibel mit ASCII und ISO-8859-1

__Mit iconv zwischen den verschiedenen Zeichenkodeirungen konvertiren__
**iconv <Datei>** --> konvertiert zwischen Codesets in <Datei>
	          --> liest von <Datei> und schreibt nach StdOut

-c --> überspringe Zeichen die in der Ausgabe ungültig sind und zeige sie nicht an
-f <Inputcodierung> --> Identifiziere den Codeset der Eingabedatei
	+ UTF-8,LATIN{1,..,10},ASCII,

-t <Outputcodierung> --> Die Ausgabecodierung festlegen
	+ //IGNORE(irgnoriere) und //TRANSLIT(aproximiere) Flag kann an die <Outputtcodierung> angehängt werden		
	z.B. ASCII//IGNORE ASCII//TRANSLIT

-o <Ausagebdatei> --> festelgen der Ausgabedatei

**iconv -f <Inputcodierung> <Input> > <Output> ** --> konvertiert die Datei <Input> unter der Annahme dass
						      <Inputcodierung> genutzt wurde in die aktuell gültige

**iconv -f <Inputcodierung> -t <Zielcodierung> <Input> > <Output>** --> konvertiert die <Datei> <Input> unter der
	Annahme dass <Inputcodierung> genutzt wurde in die <Zielcodierung> und schreibt nach <Output>

**iconv -l** --> Ausgabe aller von iconv unterstützten Codesets

__Umgebungsvariablen zur Steuerung der Ineternationalisierung__
LANG --> Besteht aus einem Sprachencode (ISO 639) und dem dazugehörigen Ländercode (ISO 3166)
de_DE,de_AT,en_US,en_GB

LANG --> wird nur von Programmen verwendet, die GNU gettext verwenden
	 --> zum überweigernden Teil Shells und Shelltools
	 --> erlaubt es mehrere Sprachen durch : getrennt anzugeben, um eine Preferenzliste anzugeben	
	 --> die erste Sprache, die von dem Programm mitgebracht wird, ist dann die gewählte


LC_ALL  --> überschreibt alle LC_* Variablen wie LC_MESSAGES, LC_CTYPE, LC_COLLATE, LC_MONETARRY, LC_NUMERIC, LC_TIME
	--> falls diese Variable gestetzt ist, werden alle andern Wete ignoriert

LC_ADRESSES --> Formatierung von Adressen und Ortsangaben

LC_COLLATE --> Zeichensortierung (**sort**, **grep**) (Character Collation)
	   --> kommt ä nach a oder nach z

LC_CTYPE --> Zeichenklassifizierung und Groß und Kleinschreibung
	 --> legt die Interpreation von Squnzen von Bytes als Character fest
	 --> **tolower()**, **toupper()**, **isalpha()**

LC_MONETARY --> Formatierung von Geldbeträgen

LC_MEASUREMENT --> Formatierung von Maßeineheiten

LC_MESSAGES --> Nachrichtng und Medlungen die ein Programm ausgibt inklusive kulturellen Konventionen

LC_NAME -->  Formatierung von Eigennamen 

LC_NUMERIC --> Formatierung von Zahlen 
		Beispiel: 0.1 und 0,1

LC_PAPER --> Papierformat (Us-Letter, A4)
 
LC_TELEPHONE --> Formatierung von Telfonnummer (0307777, 030/77777, 030.77777)	

LC_TIME --> Formatierung von Datums und Zeitangaben entsprechend der kulturellen Konventionen

!!!Die Reihenfolge in der die Variablen eingelesen werden ist: 
LANG --> (falls LANG nich gesetzt, aber eine der LC_* Variable) --> LC_* --> (falls LC_* nicht gesetzt) --> LC_ALL 
--> (falls nichts gesetzt) Der vom Programm definierte Standardwert gilt!!!


__Mit dem Befehl locale Loakliesierungsspezifische Inormationen erhalten__
**locale [<LC_VAR>]** --> Lokalisierungsinformationen erhalten
-a --> alle Verfügbaren Lokaliseringswerte ausgeben
-k <LC_VAR> --> zeige die tatsächlichen Einstellungen für <LC_VAR>

__Definitionsdateien kompillieren mit localedef__
**localedef <Outpath>** --> kompillieren der Definitionsdateien die zur Lokalisierung verwendet werden
-f <Charmapfile> --> spezifizieren der Charmapdatei falls diese nicht unter \\ /usr/share/i18n/locales \\ ist
		 --> in $$SuSE$$ befinden sich diese in \\ /usr/share/locale \\

-i <Inputfile> --> Definierre eine Eingeabedatei die kompilliert werden soll

__Der Wert C__
+ kann einem Programm immer übergeben werden
+ beschreibt den gültigen Standard den Programme verqwenden, wenn Sie keine anderen gültigen Einstllungen finden
+ Für Scripte empfiehlt sich die Verwendeung von **LANG=C** um die Ausgabe zu vereinheitlichen 

__Wichtige Verzeichnisse__

\\ /usr/share/locale \\


===X11===
+ stellt die grafische Betriebsumgebung zur Verfügung
+ Im Gegensatz zum Windowskernel ist das grafische System nicht Teil des Kernels bei Linux Systemen
+ X.Org(X11R6, X11R7) und XFree86(X11R5) sind Implementierungen des X11 Systems
+ Wesentliche Unterschiede gibt es zwischen X11R6, X11R7 in der Verwaltung der Konfigurationsdateien
+ X11 ist ein Client Server-System 
+ X11 Protokoll bietet eine Methode zur Übertragung grafischer Grundoperationen
+ X-Server stellt Schnittstellen für Eingabegeräte zur Verfügung
+ X-Clients-Anwenderprogramme schicken X-Server Grundbefehle über das X11 Protokoll Steuerungsbefehle
+ X-Server schickt Ereignisse an die X-Clients zurück
+ X-Server und X-Clients können dabei auf verschiedenen Rechnern laufen und über Netzwerk kommunizieren
+ X-Server sendet seine Ereignisse auf tty7 bis tty12 (bei $SUSE$ ist tty10 für die Ausgabe von Kernelmedlungen reserviert)
+ Accessellartet X ist eine kommerzielle Implementierung des X-Servers

__Verwalten von Xhosts__
**xhost +|- [<Family>:<HOSTNAME>:<User>]** --> verwalten der X11-Clients-Host

**xhost + ** --> aktivieren aller Nutzer | deaktivieren der Zugangsbeschränkung

**xhost - ** --> deaktiveren aller Nutzer | aktivieren der Zugangsbeschränkung für X-Host

**xhost -SI:localhost:root** --> deaktivieren des Zugangs für root

**xhost +nis:user@host** --> aktivieren des Nutzers user auf Host via NIS Protokoll
<Family>
NIS, Kerberos, Ipv4, Ipv6


!! Vorsicht:
Wenn root der Zugang zum X-Server verwehrt wird, muss der Displaymanager mit anderen Rechten gestartet werden (nobody) !!


**xauth**

__Fenstermanager__
+ X-Clients öffnen Fenster über die Sie mit dem X-Server kommunizieren
+ Hierarchie von Fenstern beginnent bei dem $$top-level-window$$$
+ Diese Aufgabe wird von einem Fenstermanager übernommen 

__Systemanforderungen für einfache Fenstermanager__
+ mind- 12 MIB RAM
+ mind 800 x 600 VGA Grafikkarte
+ eine 2 Tastenmaus (die dritte wird durch herunterdrücken beider gleichzeitig Emuliert wichtig für Laptops)

__Steuerung von Displaynamen und DISPLAY-Variable__
**<strg>-<alt>-[<F1> - <F12> ] --> Umschalten zwischen den einzelenen ttys und somit zwischen mehreren Bildschirmen

DISPLAY --> Umgebungsvariable zum Setzen des Displaynamnes
**export DISPLAY= [<Rechnername>]:<Servername>.Bildschirmnummer>**
	[<Rechnername>] kann zum Beispiel IP-Adresse oder Hostname des Rechners sein

**echo $DISPLAY**
>> :0.0 --> Server 1, Bildschirm 1 (tty7)

>> :1.0 --> Server 2, Bildschirm 1 (tty8)

>> :0.1 -> Server 1, Bildschirm 2 (tty7) impliziert zwei Harwaremonitore oder Virtuelle Bildscirme

!!! X-Client-Programme verwenden meistens die Option -display um ein gülitges Display anzugeben !!!


__Starten der grafischen Oberfläche__
+ Das Zusammenspiel zwischen X-Server und X-Clients bezeichnet eine X-Session

**startx** --> manuelles Starten des X-Servers
           --> initalisieren des X-Servers über **xinit**

   |
   v

**xinit** --> Start des X-Servers --> einlesen der Dateien \\ /etc/X11/xinit/xinitrc \\ (global) 
								\\ ~/.xinitrc \\ (Nutzerspezifisch)
                                          | 
                                          --> Start des ersten X-Clients --> Starten des Displaymanagers

Beispiel:
**sudo startx -- :1** --> mal schnell eine X11-Session als root starten 


__X-Server über einen Displaymanager starten__
\\ /etc/X11/xdm/ \\
            \\ Xresources \\ --> Einstellungen für LOGO (xlogin*logoFileName) und Begrüßung (xlogin*greeting)

	    \\ Xsetup \\ --> Shellscript zum Festlegen von zusätzlich zu startende Programme
	
	    \\ Xservers \\ --> Festlegen der Xserver Displays

            \\ Xsession \\ --> Konfiguartionsdatei für eine X-Session die von einem X-Server gestarteet wird

\\ /etc/X11/kdm \\ | \\ /etc/kdm \\ --> Konfigurationsdateien für KDM **kcontrol**

\\ /etc/X11/xdm \\ | \\ /etc/gdm \\ --> Konfigurationsdateien für den GDM **gdmconfig**

\\ /etc/X11/twm \\ | \\ /etc/twm \\ --> Konfigurationsdateien für den TWM (Tiny Windows Manager) LXDE 

\\ ~/.xsession \\ --> Konfigurationsdatei für Nutzerspezifischen Start des X Servers 

\\ ~/.xsession-errors \\ --> Fehlerlog für die X-Session des aktullen Nutzers

__Konfiguration von X Resourcen__
+Einstellungen die der X-Server speichert und bereitstellt werden
+werden bei Bedrarf vom X-Client abgeholt und ausgewertet

**xrdb** --> Tool zum Verwalten der X resourcen
         --> wird von \\ ~/.xsession \\ aufgerufen und lädt meist mittels **xrdb /etc/X11/Xresourcese** die
             entsprechenden Resourcen in den X-Server

\\ /etc/X11/apps-default/<Name> \\ --> Stellt X Resourcen für das Programm <Name> zur Verfügung 
                                   --> Systemweite Standardeinstellungen festlegen


__Konfiguration der Tatstatur__
\\ /etc/X11/Xmodmap \\ --> Konfiguration des Tastaturmappings


__Virtuelle Bildschirme mit Xnest erstellen und ansteuern__
+ ermöglicht es zum Beispiel KDE/Gnome parallel laufen zu lassen

**Xnest <DISPLAY>** --> eine Virtuelle Xserver umgebung starten

__Konfiguration des X-Servers__
(1) **init 3** oder **/etc/init.d/xdm stop** --> Stoppen der X-Session Umgebung 

(2) **Xorg -configure** --> erstellt eine Konfigurationsdatei /root/xorg.conf.new

(3) **Xorg -configure /root/xorg.conf.new** --> testen der neuen Konfiguration

(4) **mv /root/xorg.conf.new /etc/X11/xorg.conf** --> verschieben der Konfigurationsdatei an die richtige Stelle

\\ /etc/X11/xorg.conf \\ --> Konfigurationsdatei für X11 bis X11R6
\\ /etc/X11/xorg.conf.d \\ --> Konfigurationsdateien im X11R6 Stil aufgesplittet nach Section und Device
\\ /etc/X11/Xsession.d \\ --> Konfigurationsdateien für X11 ab X11R7 
			  --> enthält eine Reihe von Scripten die beim Starten einer X-Session ausgeführt werden

	$$Aufbau$$
	+ Unterteilung in Sektionen
	+ jede Section wird mit Section "NAME" eingeleitet
	+ EndSection teilt der X mit das Section hier beendet wird
	+ Identifier ist ein Label der von der Section ServerLayout aufgerufen wird
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Section "Modules"
	Load "glx"			#Die von X zu ladenden Module
	Load "freetype" 		#Stellen Treiber und Spezielle Features zur Verfügung
EndSection

Section "Input Device"
	Identifier "Keyboard"   	#Die von X verwendete Tastatur 
  	Driver "kbd"			#Treiber, Standardlayout, Model, Verhalten der Tastatur
	Option "XkbModel" "pc105" 	#Model
	Option "XkbLayout" "de" 	#Layout für die Tastatur
	Option "AutoRepeat" "500 200"	#automatische Wiederholung falls Taste wird gehalten in Sekunden wie oft
EndSection


Section "Input Device"
	Identifier "Mouse"		#Die von X verwendetet Maus ist das zweite Inputgerät
	Driver "mouse"			#Der verwendete Treiber
	Option "Protocol" "IMPS/2"	#Das verwendetet Protokoll mit der die Mouse und der X-Server kommunizieren
	Option "Device" "/dev/input/mice" #Das Device File
	Option "Emulate3Buttons" "no"	#Auf "yes" setzen falls man durch herunterdrücken beider Tasten die Maus emul. will
	Option "ZAxisMapping" "4 5"	#mapp das Scrollen der Maus auf die virtuellen Tasten 4 und 5
EndSection
	
Section "Monitor"			#Die Monitor Section
    Identifier "Monitor0"		#Identifier für ServerLayout
    ModelName "VisionMaster Pro 450"	#Name des Monitors
    HorizSync 27.0-115.0		#Horizontale Synchronisationsrate (Handbuch des Monitors)
    VertRefresh 50.0-160.0		#Vertiakle Synchronisationsrate (Handbuch des Monitors)
    # My custom 1360x1024 mode
    Modeline "1360x1024" 197.8 \	#Auflösung des Monitors
              1360 1370 1480 1752 \
              1024 1031 1046 1072 -HSync -VSync
EndSection

Section "Device"
    Identifier "Videocard0" 		#Identifier für die Grafikkarte
    Driver       "nv"	    		#Der verwendete Treiber	
    VendorName "nVidia"			#Der Hersteller der Karte
    BoardName    "GeForce 8900gs"	#Name der Karte
    VideoRam     512M			#Verfügbarer Ram
EndSection

Section	"Screen"			#Kombination von Monitor und Grafikkarte, Zweck: zur Konfiguration mehrerer Mon
    Identifier "Screen0"		#Der erste von X angesprochene Bildschirm
    Device     "Videocard0"		#Über Videocard0 Geforce 8900gs
    Monitor    "Monitor0"		#auf Monitor0 VisionMaster Pro 450
    DefaultDepth 24			#Mit Farbtiefe 24
    SubSection "Display"		#Untersection zum Festlegen verschiedener Displays
        Depth     24					
        Modes    "1024x768" "1024x600" "800x600" "640x480" #Reihenfolge der zu Probierenden Auflösung bie 24 bit Farbtiefe
    EndSubSection
    SubSection "Display"				
        Depth      8
        Modes     "1024x768" "800x600" "640x480" #Reihenfolge der zu probierenden Auflösung bei 8 bit Farbtiefe
    EndSubSection
EndSection

Section "ServerLayout"			
    Identifier     "single head configuration" 
    Screen         "Screen0" 0 0		#Der Screen auf dem X-Client gestartet wird, auf X-Server 1 Display 1 
    InputDevice    "Mouse0" "CorePointer"	#Starten der ersten und einzigen Maus
    InputDevice    "Keyboard0" "CoreKeyboard"	#Starten der ersten und einzigen Tastatur
EndSection

Section "Files" 				#Definieren von X Fonts
	FontPath "/usr/share/fonts/100dpi:unscaled"
	FontPath "/usr/share/fonts/Type1"
	FontPath "/usr/share/fonts/truetype"
	FontPath "/usr/share/fonts/URW"
	FontPath "/usr/share/fonts/Speedo"
	FontPath "/usr/share/fonts/100dpi"
EndSection
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++	
!!! Nividia kommt mit einem eigenen Konfigarationstool **nvidia-settings** und kann nicht über Xorg konfiguriert werden!!!

**xset <Option>** --> Setzen von Nutzereinstellungen
b --> setzen der Bell (Dauer , Pitch, Volume) on|off

fp --> setzen des Font Pfades

led --> setzen der Tastatur LED

s --> Einstellungen für den Screensaver 

__Informationen über X__
**xwininfo** --> Zeigt Informationen über Auflösung und Farbtiefe des X-Clients
-root --> Zeige die Informationen für das root-window

**xdpyinfo** --> Zeigt Informationen über den X-Server
	     --> Ermittele die Fähigkeiten eines Servers
	     --> damit lässt sich Auswerten welche Einstellungen vom X-Server unterstützt werden		    

__Wieviel Video RAM benötigen meine Einstellungen__
R=(x*y*bpp)/8.388.608 

Beispiel: (1024*768*24/8.388.608)=2,25 MB Pro X Anwendung !!! 


__Konfigurieren von Fonts__
+ Setup erfolgt entweder über das Konfigurationsfile in der Section "Files" oder durch Konfiguation eines zentralen 
  Font-Servers
+ Verzeichnisse \\ /usr/share/fonts \\ \\ /usr/share/X11/fonts \\ \\ /opt/fonts \\ \\ /usr/local/fonts \\
+ .pfa .pfb

**xset fp+ <FONTPATH>** --> Anhängen von <FONTPATH>
**xset +fp <FONTPATH>** --> Vorne Anstellen von <FONTPATH> 
**xset fp rehash** --> neu Einlesen der Font Konfiguration

__Remote X Clients nutzen__
(1) Login und Start X
(2) **xhost +<Remote-Host>**
(3) Via ssh auf <Remote-Host> einloggen
(4) auf dem <Remote-Host> **export DISPLAY=<Client>:0.0
(5) Starten des Programms
(6) **xhost -<Remote-Host>** um die Sicherheit des Systems zu Gewährleisten

===Linux für Behinderte===
+ Klebende Tasten (stickey keys) --> Wird die Strg einmal gedrückt, wird sie als gedrückt gehalten interpretiert
				 --> ein weiterer Druck auf Strg löst die Taste wieder

+ Langsame Tasten (slow keys) --> ignorieren von Tastendrücken innerhalb eines Zeitlichen Intervalls

+ Zurückschnellende Tasten (bounce keys) --> überzählige Tastendrücke derselben Taste werden ignoriert

+ Wiederholungstatsten (repeat keys) --> sollen festgehaltene Tasten wiederhold oder nur einmal zurückgegeben werden

+ Maustasten (mouse keys) --> gestatet die Steuerung eines Mauszeigers über den Nummernblock

+ Visuelle Keyboards --> Bildschirmtastatur die mit der Maus gesteuert werden kann **GOK** **xkbd**


===Systemprotokollierung===
+ Ausgeben und Schreiben von Systemmeldungen
+ Zum Auswerten kritischer Fehler
+ Aufsprüren von Einbrüchen


$$SUSE$$ 
	\\ /var/log/messages \\
	\\ /var/log/firewall \\
	\\ /var/log/warn \\
	\\ /var/log/NetworkManager \\

$$Debian$$ $$Ubuntu$$
	\\ /var/log/syslog \\
	\\ /var/log/debug
	\\ /var/log/messages \\

$$Fedora$$
	\\ /var/log/messages \\
	\\ /var/log/cron \\
	\\ /var/log/secure \\
	\\ /var/log/maillog \\

!!! Auf größeren Systemen bietet sich an \\ /var/log \\ oder \\ /var \\ auf einer anderen Partition oder gar
anderen Rechner aufzubewahren !!!

__Der Syslogdaemon__
+ **syslogd** Daemon erhält Nachrichten über das Socket \\ /dev/log \\
+ wird über \\ /etc/syslog.conf \\ oder \\ /etc/rsyslog.conf \\

$$ Aufbau der \\ /etc/syslog.conf \\$$
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# <Kategorie>.<Priorität>[;<Kategorie>.<Priorität>] <Ziel>
# * Platzhalter für alle

kern.warn;*.err;authpriv.none /dev/tty10
kern.warn;*.err;authpriv.none |/dev/xconsole
*.emerg				*
*.=warn;*.=err		      -/var/log/warn 
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	<Kategorie>
		authpriv --> Vertrauliche Meldungen der Sicherheitsdienste
	
		cron --> Meldungen von cron und at
	
		daemon --> Meldungen von Daemon-Programmen ohne eigene Kategorie

		ftp --> Meldungen des FTP-Daemons

		kern --> Systemmeldungn aus dem Betriebssystemkern
	
		lpr --> Meldungen des Druckersystems
	
		mail --> Meldungen des Mailsystems

		news --> Medlungen des Usenet-News-System
	
		syslog --> Meldungen des syslogd

		user --> Meldungen, die mit Benutzern zu tun haben

		uucp --> Meldungen des UUCP-Systems

		localR --> (0 <= R <= 7) Frei verwendbar für lokale Nachrichten

	<Priorität>
		none --> Keiner, Alle Nachrichten einer Herkunftskategorie ausschließen
	
		debug --> Mitteilungen innerer Programmzustände, Fehlermeldungen von Programmen auf Userlevel

		info --> Protokollierung des normalen Betriebssystemgeschehen

		notice --> bemerkenswerte Situation im Rahmen des normalen Betriebs

		warn --> nicht gravierende Warnungen, die aber nicht zum normalen Betrieb gehören

		err --> Fehlermeldungen

		crit --> Kritische Fehlermeldungen
	
		alert --> Alarmierende Nachrichten, die soforites Engreifen unbedingt erfordern

		emerg --> Meldungen vor dem Absturz

	<Ziel>
		+ Datei meist \\ /var/log/ \\
		+ named Pipe FIFO **| <FIFO>** zum Beispiel \\ /dev/xconsole \\ und könnn
		+ können über das Netz via syslogd an einen andere IP-Adresse weitergeben **@<Zieladresse>
			--> kritische Systemzustände werden an eine anderen Rechner gesandt
			--> Einsbruchspuren können nicht ohne weiterres verwischt werden
			--> Auf dem Zielrechner muss syslogd mit -r gestartet sein 
				$$SUSE$$
				SYSLOGD_PARAMS \\ /etc/sysconfig/syslog \\
				
				$$DEBIAN$$
				RSYSLOGD_OPTIONS \\ /etc/init.d/rsyslog \\

!!! Nach dem Editieren der Konfigurationsdatei muss der syslogd die Konfigurationsdatei neu lesen !!!
**kill -1 rsyslogd** bzw. **kill -1 syslogd** --> Den Syslogdaemon zwingen die Konfiguration neu zu lesen


__Mit logger Meldungen an den Syslog Daemon senden__
**logger <Nachricht>** --> <Nachricht> via syslogdaemon an das System
-p <Kategorie.Priorität> --> Fetslegen der Kategorie und Priorität

-t <Label> --> Ein Label zu Identifikation senden, sinnvoll zum späteren Parsen der Errorlog Datei 

-f <Datei> --> den Syslogdemon zwingen die Nachricht in Datei anstelle von /var/log/messaes zu schreiben

-u <Socket> --> den Syslogdaemon zwingen die Nachricht in den angegebenen <Socket> zu schreiben

__Mit logrotate Systemnachrichten rotieren__
+ überwacht Größe und Alter im System befindlicher Logdateien
+ bei Gelegenheit können Sie entsprechenden Kriterien entsprechend gekürzt, archiviert oder gelöscht werden
+ Zum Platzsparen (Damit logdateien nicht irgendwann die gesamte Platte eines Systems vollmüllen)
+ **logrotate** wird einmal täglich von **cron** gestartet bei $$SUSE$$ \\ /etc/cron.daily/logrotate \\
+ **logrotate** wird in \\ /etc/logrotate.conf \\ /etc/logrotate.d \\ konfiguriert

\\ /etc/logrotate.conf \\ --> setzen allgemeiner Parmater

\\ /etc/logrotate.d \\ --> Konfigurationsdateien die für das rotieren bestimmter Dienste verantwortlich sind
		       --> Hier wird das rorieren bestimmter Nachrichten festgelegt
!!! man logrotate !!!

__Protokollierung des Systemkerns__
+ Kernel stellt einen eigenen internen Ringpuffer für das Logging zur Verfügung 
+ \\ /proc/kmsg \\ enthält die Nachrichten die vom Kernel ausgegeben werden 
+ Der Daemon **klogd** kümmert sich um die Weiterleitung an den Daemon **syslogd**
+ Mit **dmesg** kann man sich alle Meldungen des Kernels seit dem Booten anschauen

**dmesg** --> Rückverfolgung von Kernelnachrichten
-c --> den Inhalt des Kernel Ringbuffers nach der Ausgabe löschen
-r --> Unterdrücke Kernel Loglevel angaben
-n N --> Angeben welche Loglevel von dmesg fortan angezeigt werden soll (0-7)


===Netzwerk und Tools===

__Netzwerk Klassen und Ihre IP-Ranges__
Klasse		Netzanteil	Anzahl Netze	Anzahl Hosts	Adressen
Class A		8 Bit		128-126		2^34 - 2	0.0.0.0 - 127.255.255.255.255

Class B		16 Bit		16.384		65.534		128.0.0.0 - 191.255.255.255

Class C		24 Bit 		2^21		254		192.0.0.0 - 223.255.255.255

Class D		-		-		-		224.0.0.0 - 239.255.255.255

Class E		-		-		-		240.0.0.0 - 254.255.255.255	

__Privater IP Adressbereich__
Class A	10.0.0.0 - 10.255.255.255
Class B 127.16.0.0 - 172.31.255.255
Class C 192.168.0.0 - 192.168.255.255



__Wichtige Ports__
+ well known Ports: 0-1023
+ registered Ports: 1024 - 49151
+ private Ports: 49152 -65535

echo		Port 7 		tcp/udp
netstat		Port 15		tcp
ftp		Port 20		tcp/udp
ftp		Port 21 	tcp/udp
ssh		Port 22		tcp/udp
telnet 		Port 23		tcp/udp
smtp		Port 25		tcp/udp
dns		Port 53		tcp/udp
http		Port 80		tcp/udp
pop3		Port 110	tcp/udp
nntp		Port 119	tcp
netbios		Port 137-139	tcp/udp
imap		Port 143	tcp/udp
snmp		Port 161	udp
ldap		Port 389	tcp
https		Port 443	tcp/udp
rsync		Port 873	tcp/udp
ftps		Port 990	tcp/udp
imaps 		Port 993	tcp/udp
pop3s		Port 995	tcp/udp
irc		Port 6668	udp


\\ /etc/services \\ mappt die Ports an **inetd** oder **xinitd** oder von getserverbyname() syscall verwendet

!!! Neu Entwickelte Dienste können in \\ /etc/services \\ eingetragen werden !!!
!!! Bei aktuallisierungen muss die Datei dann vorher gesichert werden !!!

!!!Achtung: Ports 0-1023 kann nur von root geöffnet werden !!!



__Mit arp den Arp Cache manipullieren und dumpen__
BUZZWORD: ARP == Adress Resolution Protocol


**arp** --> Manipuliieren und überwachen des arp caches im Kernelspace

**arp** --> Ausgabe des Arpcaches auslesen aus \\ /proc/net/arp \\
<Address>                <HWtype>  <HWaddress>           <Flags Mask>          < Iface>
192.168.1.1              ether   00:19:cb:55:4e:34         C                     eth1

<Flags Mask> C  Complete
	     M  Permanent
	     P Published

-a Ausgabe in BSD Format <Broadcast> at <MAC>            HWTYPE  on <Gerätename>
                       ? 192.168.1.1 at 00:11:22:33:44:55  ether on   eth1

**arp -d <Hostname> | <IP-Adresse>** --> löschen von Rechner aus dem arp cache
      --delete

**arp -s <Hostname> <Mac-Adresse>** --> manuelles hinzufügen zum arp cache
      --set

**arp -f <Datei>** --> setzen des arp cahes aus der <Datei>
      --file       --> wird <Datei> nicht angegeben, so wird \\ /etc/ethers \\ verwendet

__Mit arpwatch den Netzwerkverkehr auf gespoofte arp Pakete überwachen__
**arpwatch** --> Die Datei \\ /var/lib/arpwatch/arp.dat \\ muss existieren
	     --> Daemon zum Überwachen des Netzwerktraffic auf gefälschte arp Pakete
-m <User> --> Mail an den <User> schicken> 


__Netzwerkkarten und Treiber Konfigurieren__
+ \\ /etc/udev/rules.d/70-persistent-net-rules \\ hält informationen und Regeln über die von udev
                                                  gesteuerten Netzwerkkarten wird erzugt von 
                                                  \\ /lib/udev/write_net_rules \\

Besipiel:
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
SUBSYSTEM=="net", ACTION=="add", DRIVERS=="?*", ATTR{address}=="00:13:ce:b4:9f:57", ATTR{type}=="1", KERNEL=="eth*", NAME="eth1"
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

+ Ist kein udev vorhanden wird nach der alten Methode in \\ /etc/modules.conf \\ Einträge für Regeln zum laden von Kernel-
  modulen

**/sbin/ifconfig** --> anzeigen der konfigurierten Netzwerkschnittstellen
		   --> konfigurieren von Netzwerkschnittstellen
		   --> aktuelle IP, Hardwaretyp, MAC, Broadcast, Netzmaske, die IPv6 Adresse

**/sbin/ip addr show** --> anzeigen aller Netzwerkschnittstellen

**ifconfig <eth0> <IP-Adresse> up --> weist dem Gerät <eth0> die <Ipadresse> zu und aktiviert die Karte zur Benutzung

**ifconfig <eth0> <Ip-Adresse> netmask <Netzmaske> broadcast <Broadcast-Adresse>** 
--> zuweisen einer neuen Netzmaske und Broadcastadresse

**ifconfig eth0:1 <Ip Adresse>** --> vergeben eines Aliases für eth0 auf eth1 mit einer neuen IP Adresse
				 --> Kerneloption Ip-Alliassing muss aktiviert sein

__Routing konfigurieren mit route__
+ statisches und dynamisches Routing

satisches Routing: Der Rechner folgt immer einer fest vorgegebenen Route.

dynamisches Routing: Der Router kommuniziert mit anderen in seiner Nähe befindlichen Routern (minmal hopps) und kann so 
anahnd bestimmter Parameter den für sich günstigen Weg herausssuchen. Erfordert die Installation und Konfiguration von
Routing Daemons wie **gated** oder **routed**


**route** --> Anzeigen der im Kernelspace verwalteten Routing-Tabelle
	  --> ist äquivalent zu **netstat -r[n]**	
-n --> Numerische Adressen anzeigen

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
>> Ziel            Router          Genmask         Flags Metric Ref    Use Iface
192.168.128.0   *               255.255.255.0       U     1      0        0 eth0
loopback        *               255.0.0.0           U     0      0        0 lo
default         192.168.128.1   0.0.0.0             UG    0      0        0 eth0
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Ziel (Destination): Zieladresse (Netzadresse, Stationsadresse, _default_ für alle für die keine der üblichen gilt) 

Router(Gateway): Router für Paketweitervermittlunng, falls * werden Pakete nicht an anderen Rechner weitergeleitet

Genmask: Netzmaske zur Zieladresse

Flags: Beschreibung der Route
	U Die Route ist aktiv (up)
	G ist ein Gatewate
	H Hostroute Zieladresse bezeichnet einen einzelenen Rechner
	! diese Route wird vom Kernel zurückgewiesen

Metric: Anzahl Hops

Use: Wie oft wurde die Route schon verwendet

IFace: Das Interface über denen Datagramme weitergeleitet werden sollen
**route add [-net|-host] <Ziel> [netmask <Netzmaske>] [gw <Gateway] [dev <Interface>]** --> hinzufügen einer Route
**route del [-net|-host] <Ziel> [netmask <Netzmaske>] [gw <Gateway>] [dev <Interface>]** --> löschen einer Route


**route add|del -net <IP-Adresse> netmask <Netzmaske> dev <ethN>** --> Setzen|löschen einer Netzroute

**route add|del -net <IP-Adresse> netmask <Netzmaske> gw <Ip-Adresse Gateway> --> Setzen|löscchen einer Gateway Route 

**route add|del -host <Ip-Adresse> netmask dev <ethN> --> Setzen|löschen einer Hostroute

**route add default dev <ethN>** --> Setzen einer Default Gateway Route

__IP Forwarding aktivieren__
**echo <0|1> > /proc/sys/net/ipv4/ip_forward** --> deaktiveren|aktivieren von IP Forwarding

$$SUSE$$ \\ /etc/sysconfig/sysctl \\ IP_FORWARD=yes eintragen

$$Debian$$ \\ /etc/network/options \\ ip_forward=yes eintragen

__Netzwerkkonfiguration mit ip__
+ erlaubt das Anzeigen von 
+ erlaubt das setzen von Routen
+ erlaubt das Konfigurieren vn Netzwerkschnittstellen
+ erlaubt das Verwalten von arp Tabellen
+ Setzen von Routing Policy Database Management
+ Ip Tunnel konfiguration


**ip [<Option>] <Objekt> [<Kommando> <Parameter>|help]**
-V --> Versions informationen
-s --> ausführliche Informationen zu Objekt
-f --> festlegen der Protokollfamile (inet inet6)
-o --> Alle Ausgaben in einer Zeile (oneline)
-r --> Namensauflösung einschalten

<Objekt>
link --> physikalische oder logisches Netzwerkinterface
addr --> ipv4 oder ipv6 Adresse
neighbour --> Kernel arp Cache
route --> Routing Tabellen
rule --> Regel in der Routing Tabelle 
madress --> MUlticast Adressen
mroute --> Multicast ROuting Tabellen
tunnel --> IP in IP Tunnel 

<Kommando>
add --> hinzufügen von Objekten
delete --> entfernen von Objekten
show --> Anzeigen
set up --> anschalten
set down --> ausschalten

**ip addr add local <IP>/<CIDR> dev <ethN> brd + [label <ethN:r>]** 
--> Netzwerkkarte <ethN> die IP mit der entsprechenden Netzmaske zuweisen mit Broadcastadresse entsprechend der NetzID
--> Optional kann mit labeö noch ein Alias gesetzt werden

**ip link set up dev <ethN>** --> <Netzwerkinterface <ethN> hochfahren

**ip link set down dev <ethN>** --> Netzwewrkinterface <ethN> herunterfahren 

**ip a** --> auflisten aller Interfaces

**ifup [<ethN>]** **ifdown <ethN>** --> Das Netzwerkinterface kurzfristig an und ausschalten
                                    --> schaltet das Interface wirklich ab, es wird dann auch von ifconfig oder ip nicht
					mehr gesehen
-a --> alle nur $$Debian$$, $$Ubuntu$$, falls kein spezielles Interface spezififziert wurde

**service network stop** --> hält alle Interfaces komplett an und verwirft ihre Konfigurtion


$$SUSE$$
**rcnetwork start|stop** --> entspricht **ifup -a** 

__Konfigurationsdateien für Netzwerkeinstellungen__
$$Debian$$ \\ /etc/network/interfaces \\ --> dauerhafte Konfiguration die vom Kernel beim Starten geladen werden

$$SUSE$$ \\ /etc/sysconfig/network/ \\
		\\ ifcg-<ethN> \\ -->  Konfigurationsdatei enthält Variablen die dann von **SuSEconfig** ausgelesen werden

\\ /etc/init.d/network \\ --> Initscript dass beim die Netzwerkinterfaces beim Starten des Kernels aktiviert und 
			      entsprechend seiner Konfigurationsdatei konfiguriert

$$SUSE$$ \\ /etc/sysconfig/network \\ --> Scripte und Konfigurationsdateien für Netzwerke

===DHCP===
+ Dynamic Host Configuration Protocol
+ Netzparameter werden zentral vergeben 
+ IP-Adresse, default Router, meherere DNS Server usw. werden auf einem entfernten Server eingerichtet und von dort vergeben

__DHCP für die Vergabe von Netzwerkadressen verwenden__
$$Debian$$, $$Ubuntu$$ 

\\ /etc/network/interfaces \\ --> eintragen von "iface <ethN> inet dhcp" --> DHCP verwenden
                              --> eintragen von "iface <ethN> inet static" --> DHCP nicht verwenden

$$SUSE$$ 

\\ /etc/sysconfig/network \\ --> eintragen von "BOOTPROTO='dhcp'" --> DHCP verwenden
			     --> eintragen von "BOOTPROTO='static'" --> DHCP nicht verwenden


===Namensauflösung und DNS===
+ Umwandlung von IP-Adressen in Namen und umgekehrt

\\ /etc/resolv.conf \\ --> Konfigrationsdatei für den Resolver der für die Konfiguration von 

Beispiel:
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
nameserver 192.168.10.1
nameserver 192.168.0.99

search foo.example.com bar.example.com example.com
sortlist 172.16.0.0 10.10.19.10
options rotate
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
nameserer: --> IP-Adressen der Nameserver die vom Resolver befragt werden
	   --> Die Nameserver werden in der gelisteten Reihenfolge befragt bis zu 3
	   --> ist die Datei \\ /etc/resolv.conf \\ nicht vorhanden oder enthält er keine gültigen Einträge wird der
	       lokale Host befragt
	   --> Eine reine Reslover Datei enthält keine Einträge die auf den lokalen Host verweisen

domain:    --> definiert den Standarddomainnamen
	   --> Der Resolver hängt den Standarddomainnamen an den Hostnamen an, der keinen Punkt enthält
	   --> domainname: wird an den domainnamen angehängt <domainname>.foo.com

search:    --> Reihe von Domainanmen die vom Resolver durchsucht werden ein Hostnamen keinen Punkt enthält
  	   --> search: wird vom Resolver angehängt <search>.foo.com
	   --> <search> und <domain> schließen einander aus. Der erste Eintrag gewinnt

sortlist:  --> Adressen die vom sortlist Befehl aufgelöst werden, werden bevorzugt behandelt
	   --> werden meherer Adressen empfangen, werden diese vom Resolver so umsortiert, so dass 
	       diese zuerst sortiert werden
	   --> kann genztzt werden, um Adressen in einem gemeinsamen Netzwerk zu bevorzugen

options: <Options>
		debug Debugging Modus Fehler werden an die Standardausgabe geschrieben
		
		timeout:n Setzt den Timeout für den Resolver
		
		attempts:n Wie oft soll eine Anfrage wiederholt werden

		rotate Verteile die Last der Nameserver gleichzeitig auf die eingetragenen nameserver
		       frage nicht jeden einzeln ab
		
		no-check-names dekaitviert Interet Host Table Specification

		inet6 benutze ipv6 Adressen anstelle von ipv4

		ndots:n Die minimale Anzahl der Punkte im Domainnamen  	


\\ /etc/hosts \\ --> lokale Auflösung von Rechnernamen und IP-Adressen
		 --> Tabellenförmige Datei die IP-Adresen mit Hostnamen verbindet
		 --> # Kommentare
		 -->  <Ip-Adresse> <Domanin Name (FQDN)> <kurzname>
Beispiel:
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
127.0.0.1       localhost

# special IPv6 addresses
::1             localhost ipv6-localhost ipv6-loopback

fe00::0         ipv6-localnet
130.57.5.70 	opensue.org suse
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

**netconfig update -f** --> erhalte eine neue Liste vom DHCP Server

**dnsmasq** --> macht den Inhalt der datei \\ /etc/hosts \\ lokal über DNS verfügbar und leitet andere Anfragen ans 
		Internet DNS weiter
	    --> kleiner DNS / DHCP Server

--test --> nur testen ob die KOnfigurationdateien in Ordnung sind. kein Start des Dienstes

-h | --no-hosts --> Die Datei \\ /etc/hosts \\ wird nicht gelesen
		
-H --addn-hosts=<Datei> --> Angabe einer zusätzlichen <Datei> als /etc/hosts

-d | --debug --> Debug Modus

-u | --user=<Name> --> UserID mit der dnsmasq gestartet wird

-g | --group=<Group> --> GroupID mit der dnsmasq gestartet wird


\\ /etc/nsswitch.conf \\ --> festlegen der Reihenflge in der Abfragen druchgeführt werden (Name Service Switch)
			 --> NIS Datenbanken
++++++++++++++++++
hosts: files dns
++++++++++++++++++
benutzt erst \\ /etc/hosts \\ für die Namensauflösung und dann DNS

+++++++++++++++++
hosts: dns files
+++++++++++++++++
benutzt erst DNS und dann \\ /etc/hosts \\

===Fehlerbehebung im Netz===

**ping <URL> | <IP-Adresse>** --> testet die Erreichbarkeit 
			      --> sendet einen ICMP Echo Reply
-a --> akkustischer Ping

-c --> Die Anzahl der zu senedenten ICMP Pakete festlegen

-b --> Eine Broadcast Adresse anpingen

-f --> Flooding

-i --> Intervall zwischen den einzelnen Pings festlegen

-s --> festlegen der Größe der ICMP Pakete

-I --> Ein Inteface anpingen

-l N --> es werden N pakete auf einmal gesendet ohne auf den reply zu warten, ist N > 3 muss der ping als root abgeschickt
	  werden

**traceroute <URL> | <IP-Adresse>** --> schickt UDP Pakete mit einem Time to live exceed

				    --> und ermöglicht eine Rückverfolgung der route

-6 | -4 --> setzen der ipv4 oder ipv6

-f N -->  Mit welcher TTL (Time to Live) soll gestartet werden

-i <ethN> --> Angabe des Interfaces durch das die udp Pakete geschikt werden sollen
	  --> Standard ist die Benutzung des Gerätes welches in der Routing Tabelle eingetragen ist

-m N --> Anzahl der Hopps 
     --> Standard ist 30

-n  --> IP Adresssen nicht in Hostnamen auflösen, beschleunigt den traceroute Vorgang

-p M --> Festlegen eines anderen Ports
     --> Standard ist 80

-I --> Nutze ICMP anstelle von UDP Paketen

-T --> Nutze TCP anstelle von UDP Paketen
  	
-w <Sekunden> --> <Sekunden> warten bevor das nächste Paket gesendet wird.

-V --> Versionsnummer abfragen

**tracepath <URL> | <IP-Adresse>** --> Userlevel Programm
				   --> bestimmt die Pfad-MTU 
				   --> spürt asysmmetrische Antwortverhalten auf

>> 
1?: [LOCALHOST]                              pmtu 1500
  	1:  dust.inr.ac.ru                   0.411ms
        2:  dust.inr.ac.ru        asymm  1   0.390ms pmtu 1480
        2:  3ffe:2400:0:109::2               463.514ms reached
            Resume: pmtu 1480 hops 2 back 2

#TTL #Network Hop #MTU

__Dienste und offene Sockets überprüfen__
**netstat <Optionen>** --> Statistiken und Informationen über das Netzwerk abfragen  
		       --> ohne Optionen zeigt Netstat Informationen über den Zustand von offenen Sockets an	
		       --> alle Adressfamilien ohne Option

-a  alle Sockets einschließlich der auf Verbindung wartenden Serversockets

-e zusätzlliche Informationen über die User ID

-l lauschenende Sockets

-n Keine Auflösung in Namen

-p PID und Porgrammname des betreffenden Prozesses anzeigen

-t tcp Verbindungen anzeigen

-u udp Verbindungn anzeigen

**nestat -tulpen**
>>Proto Recv-Q 	Send-Q 	"Local Adress"	"Foreign Adress" State Benutzer Inode PID/Programm Name

Proto --> Das benutzte Protokoll (tcp, udp, raw) das vom Socket benutzt wird

Recv-Q --> Die Anzahl der empfangenen aber (noch) nicht vom Programm abgeholten Bytes auf diesem Socket

Send-Q --> Dies Anzahl der versendeten Bytes, die von der Gegenstelle noch nicht bestäigt wurden

Local Adress --> Lokale Adresse und Portnummer des Sockets, * bedeutet hier alle

Forein Adres --> Ziel Adresse und Portnummer des Ziels des Sockets, * bedeut hier alle

State --> ESTABLISHED, SYN_SENT, SYN_RECV, FIN_WAIT{1,2}, TIME_WAIT, CLOSE, CLOSE_WAIT, LISTEN

Benutzer --> UID des Nutzers 

Inode --> Inode des Sockets

**netstat -patune**

__Portscanner__
**nmap <[255].[255].[255].[255]/[32]> | <scanme.org>** 
--> Portscanner der nach offenen Ports in einem bestimmten Ip-Adressbetrreich sucht
--> zur Analyse von Netzwerken
--> ohne Option werden die 1000 am häufigsten Ports gescannt
--> Ip-Adressbereich kann durch CIDR Notation beschränscanme.org wobei /0 (Alle Adresen) /32 Nur den Host
	+UDP- TCP Connects
	+TCP Syn Scans
	+Ftp Bounce 
	+Reverse ident
	+FIN Scans
	+ACK Schleifen
	+X-Mas
	+SYN-Schleifen
	+NullScan


>> offen: 
--> ein Programm horcht auf diesem Port und ist bereit TCP/UDP Pakete entgegenzunehemn

>> geschlossen:
--> Port ist erreichbar
--> er empfängt und antwortet auf nmap Testpakete

>> gefiltert:
--> Port ist nicht zugänglich
--> nmap kann nicht feststellen ob ein Port offen oder geschlossen ist

>> ungefiltert:
--> Port ist zugänglich
--> nmap kann nicht feststellen ob er offen oder geschlossen ist
--> nur von ACK Scan geliefert

>> offen | gefilter:
--> Der Port ist entweder offen oder gefiltert

>> geschlossen | gefiltert 
--> Der Port ist entweder geschlossen oder gefiltert

-sL --> durchführen eines List Scans
	+Auflisten der Hosts ohne Pakete an Zielhosts zu senden
	+Auflösung von Hostnamen
	+Liste der Ip-Adressen
	+nicht mit Portscanning oder OS-detection kombinierbar

-sP --> durchführen eines Ping Scans
	+ermitteln der aktiv am Netzwerk teilnehmenden Hosts
	+sendet ein ICMP echo Request und ein TCP ACK an Port 80
	+nicht mit OS-detecction aktivert aber kann aktiviert werden 

-sS --> Stealth Scan durchführen
	+führt keinen kompletten Handshake durch
	+halboffener Scan
	+es wird ein SYN paket an den Zielport gesendet und ein SYN/ACK empfangen, danach wird die Verbindugn mit einem
	 Reset Paket geschlossen
	+funktioniert nur auf unixoiden TCP Stacks 	

-sF --> Stealth FIN Scan durchführen
	+Übertragung eines FIN Datagramms an den Port, alle geschlossenen Ports müssen mit RST antworten
	+sehr zeitaufwendig

-sX --> Stealth X-Mas Scans 
	+sendet eine TCP-Verbindung URG, FIN und PUSH zum Zielport
	+ein bestehendes Datagramm wird verworfen (URG) und es wird sofort auf eine Antwort auf dem Zielhost
	 mittles (PUSH) geschickt
	+root Rechte sind zwingend erforderlich, weil neue Sockets erstellt werden müssen

-p U:N|T:N|N -->  einen bestimmten Port N scannen, UDP [U:] und TCP [T:] sind möglich
	     --> Portbereiche können so [-N], [M-], [M-N] angegeben werden !!! Die [] sind notwendig !!!

-F --> sehr schnell,  beschränkt das Portscannen auf 100 wichtigsten Ports

-r --> ohne Randomisierung, Scanne sequentiell

-iL <Datei> --> Eine Liste mit Hosts angeben die gescannt werden soll

-PN --> No Ping (Ping deaktivieren)

-PR --> Scannen mittels ARP Request eines lokalen Netzwekres

--exclude <host1> ... <hostN> --> Hosts vom Scannen ausschließen 

--excludefile <Datei> --> Eine Liste mit Hosts anegben die beim Scannen ausschließen

--traceroute --> durchführen eines traceroutings nach dem Ping

-n --> keine DNS Auflösung

-R <Ziele> --> DNS Auflösung für <Ziele> 

-O --> OS Detection

-A --> Erkennung vonb Diensten und details zu diesen 

--systm-dns --> DNS Auflösung des scannenden Systems verwenden

--dns-servers <Server> --> der folgende Server wird für DNS reverse Lookup genutzt 

--scanflags --> festlegen Benutzerdefinierter TCP-Scans

\\ /usr/share/nmap/nmap-services \\ --> von nmap definierte Portnamen die bei Angabe von -p berücksichtigt werden
				    --> nmap nutzt diese Datei um bestimmte Ports wieder in Namen aufzulösen

\\ /usr/share/nmap-service-probes \\ --> Metainformationen für das Parsen verschiedener Dienste nach Detailierten Angaben


**zenmap** --> grafisches Nmap frontend



__DNS testen__
**nslookup <URL> | <IP>** --> Auflösen von Adressen und IP-Nummern
			  --> Testen von DNS Vorwärts und -rückwärtsauflösung
			  --> durchführen von DNS Lookups	

**host <URL> | <IP>** --> durchführen von DNS Lookups

-C --> zeige SOA Records

-v | -d --> Verbose 

-l --> gibt NS Records, PTR und Adress Records wieder

-4 |-6 --> benutze IPv4 oder IPv6

-s --> falls ein ServFail geliefert wird, breche die Ausgabe an dieser Stelle ab

-t <mx> | <soa> --> Den Record bestimmen

**dig <URL> |-x <IP> <RecordTyp>** --> durchführen von DNS Lookups
		      		   --> Detaillierte Ausgabe

-x --> Reverselookup verpflichtende Option

-4 |-6 --> benutze IPv4 oder IPv6


__weiter Diagnosewerkzeuge__
**telnet <Adresse> <Dienst>** --> Aufbau einer Telnetverbindung zu einer <Adresse> auf Portnummer des <Dienstes> 
                	      --> Kontaktaufnahme mit einem TCP Port
                              --> Datenübertragung findet in der Regel unverschlüsselt statt


**tcpdump -i <ethN>** --> Netzwerk Sniffer 
            	    --> Netzwerkkarte wird in den $$Promiscuous Mode$$ versetzt 
	            --> erfordert root Rechte

-A --> darstellung jedes Paketes ohne Linklayer Level Overhead

-c N --> nach N Paketen wird das Programm abgebrochen

-D --> Eine Liste von Netzwerkinterfaces ausgeben auf denen tcpdump lauschen kann

-i --> Angabe des Interfaces, verpflichtende Option

-n --> Abschalten der Portauflösung und Namensdarstellung

-L --> Auflisten der bekannten Linklayer Optionen 

-w <Datei> --> schreibe den Dump in <Datei>

-r <Datei> --> lese den Dump aus <Datei>

-t --> benutze keine TimeStamps

-tt --> benutze TimeStamps

-ttt --> Ein delta zwischen jeden gesendeten Paket ausgeben -tttt -ttttt geben nochmehr Details

-v --> erhöhe die Gesprächigkeit -vv, -vvv  geben mehr Details

-Z <UID> <GID> --> Angabe eines Nutzers der den tump druchführt, ändern der UID GID des Programms 

**tcpdump -c 3  -n any** --> fängt 3 Pakete ab, dabei horscht es auf jeder verfügbaren Schnittstelle und verwendet keine
			      Namensauflösung oder Portnummerndarstellung

**wireshark**,**ethereal** --> grafischer Netzwerksniffer
	 		
**iptraf** --> Überwachung und Statistiken über das Netzwerk

**iftop** --> top für Netzwerkverkehr

===inetd und xinetd===

__inetd__
+Internetdaemon
+lauscht auf verschiedenen Ports und startet daraufhin den auf diesen Port gemappten Dienst
+Es wird nur ein Daemon benötigt der auf bestimmte Ports horscht und des muss nicht jeder Dienst extra lauschen
	--> spart UTTCMS 
	--> spart RAM


\\ /etc/inetd.conf \\ --> Konfigurationsdatei des inetd
		      --> nach Konfiguration des Daemons muss dieser mit SIGHUP Signal dazu veranlasst werden
			  Konfiguration neu einzulesen **kill -1 inetd** **service inetd restart**
Beispiel
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
<Dienstname>	<Sockettyp>	<Protokoll>	<Parallelität>	<User>	<Kommando mit Pfadangabe> <Argumente>
ntalk   	dgram   	udp     	wait    	root    	/usr/sbin/tcpd     in.talkd
ftp     	stream  	tcp     	nowait 		root    	/usr/sbin/tcpd     in.ftpd		
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
<Dienstname>
--> identifiziert den Dienst 
--> Angabe der Portnummer oder Name
--> Bei Angabe des Namnes muss dieser in der Datei \\ /etc/services \\ definiert sein		

<Sockettyp>
--> beschreibt den Dienst Typ des geöffneten Sockets
--> Mögliche Werte sind: dgram --> Verbindungsloser Socket für UDP
			 raw  --> ICMP; IGMP; Packet inklusive Header 
			 stream  --> Verbindungsorientierter Socket wird von TCP genutzt 
			 rdm (reliably delivered message)--> Zuverlässiger Datagramm layer der Pakete auch unsortiert 
							     aufnimmt
			 seqpacket --> sequentiller, verblässichlicher in zwei Richtungen Verbindungsorientiert 

<Protokoll>
--> verwendetes Protocoll der den Dienst anspricht
--> Protokollnamen müssen in \\ /etc/protocols \\ definiert sein

<Parallelität>
--> bezieht sich nur auf UDP, muss aber immer angegeben werden
--> wait: neue Anforderungen wird erst engegen genommen wenn UDP seine Dienst beendet hat
--> nowait: unverzüglich auf neue Anforderungen reagiert
--> nowait.N --> Angabe von N maximalen gleichzeitigen Anforderungen

<User>
--> Name des Bnutzers in dessen Auftrag der Dienst gestartet werden soll

<Kommando mit Pfadangabe>
--> vollständiger Befehl inklusive Pfadangabe

<Argumente>
--> Angabe des Namens des Dienstes mit zusätzlichen Argumenten und Optionen 


__tcpd TCP-Wrapper__
+Dienst zur Steuerung von Zugriffsberechtigungen bestimmter Dienste
+erfolgt eine Zugriffsversuch auf einen Dienst, startet der **inetd** den **tcpd**
+Prüft ob ein Rechner berechtigt ist einen bestimmten Dienst zu nutzen

\\ /etc/hosts.allow \\ --> explizit erlaubter Dienst, erste Datei die angeschaut wird
		       --> Dienst für diesen Rechner wird gestattet
		       --> \\ /etc/hosts.deny \\ wird nicht mehr befragt

\\ /etc/hosts.deny \\ --> explizit verbotener Dienst, wird immer als zweites angeschaut
		      --> Dienst für diesen Rechner wird verboten

!!! Ist keine der beiden Dateien vorhanden gelten beide Dateien als leer und es dürfen alle alles !!!
!!! und der Zugriff wird dann Protokolliert !!!
	
\\ /etc/hosts.allow \\ | \\ /etc/hosts.deny \\ 
Beispiel:
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
<Dienstliste> : <Hosts> : <weitere Einträge> [:<Option1>] [:<Option2> [:<shell-befehl>]
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
<Dienstliste> 
--> durch kommata getrennte Liste von Diensten die in /etc/inetd.conf spezifiziert
--> ALL alle bekannten Dienste

<Hosts>
--> durch Kommata getrennte Liste mit Hostnamen, Domain-Namen und Internet-Adressen 
--> ALL für alle denkbaren Rechner
--> KNOWN für alle von tcpd ermittlelbaren Rechner
--> LOCAL alle Hosts deren Namen keinen Punkt enthalten
--> UNKNOWN für alle von tcpd nicht ermittelabren Rechner
--> PARANOID für alle deren Adressauflösung via dhcp widersprüchliche Angaben ergibt 


<Optionen>
--> im Makefile muss PROCESS_OPTIONS kompilliert wurden sein
	allow --> gewährt den angeforderten Dienst und muss am Ende einer Regel auftauchen
	
	deny --> Verweigert den angeforderten Dienst muss am Ende einer Regel autauchen
	
	spawn <ShellBefehl> Führt den angegebenen Shellbefel anstelle des angeforderten Dienstes aus
	
	keepalive --> Sendet keppealive-Nachrichten an den entsprechenden Host. Falls keine Antwort wird Verbindung
		 	getrennt
	
	linger N --> gibt an wie lange nach Verbindungstrennung Daten versucht werden weiter zu übertragen
	
	banners <Pfad> --> sendet den unter zu <Pfad> führende Datei als Nachricht

	nice N --> setzen des Nicewertes für den Netzwerkdienst
	
	user <benutzer>.<gruppe> --> festlegen des Netzwerkdienstprozesses Nutzer und Gruppen id

	setenv <Variable> <Wert> --> zuweisen einer Umgebungsvariable für die Laufzeitumgebung des Prozesses

	twist --> Programm das statt des angeforderten Dienstes aufgerufen wird und beim Client ausgeführt wird

<Shell-Befehl>(optional) 
--> Anhängen eines Shellbefehls
--> folgende mit % eingeleiteten Variablen können dafür verwendet werden:
	
	%a --> IP-Adresse Client
	%A --> IP-Adresse Server
	%c --> Alle verfügbaren Client Informationen einschließlich des Benutzernamens
	%d --> Prozessname des Netzwerkdaemons
	%h --> Hostname des Clients
	%H --> Hostname des Servers
	%n --> wie %h steht Hostname nicht zur Verfügung wird UNKNOWN gesetzt, steht auch IP-Adresse PARANOID
	%N --> Hostnae des Servers
	%p --> PID des Netzwerkdaemons
	%s --> Alle verfügbaren Server Informationen einschließlich des Benutzernamens
	%u --> Clientbenutzername bzw UNKNOWN falls nicht verfügbar
	%% --> %

Beispiele:
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
ALL : ALL : twist (safe_finger -l @%h|usr/sbin/mail -s %d %h root ) &
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ könnte in /etc/hosts.deny stehen  und verweigert allen die nicht explizit erlaubt wurden den Zugriff
+ Anschließend wird mittels safe_finger herasuzufinden wer auf den Rechner zugriffen hat und eine Mail an root geschickt
+ dabei wird eine Subshell verwendet

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
in.ftpd  : ALL : twist /bin/echo 421 FTP not allowed from %h: DENY
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ der ftpd wird für alle verboten, es wird eine Nachricht an den Client und ein Errorcode gesendet

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
in.telnetd@172.16.2.2 : allow 
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+der Dienst telnet wird nur vomn der Adresse 172.16.2.2 aus zugelassen

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
ALL : .example.com EXCEPT private.example.com deny
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+alle Dienste werden verboten, ausser die von der Domaine private.example.com kommen

!!! Die Dienste für die die Regeln gelten sollen, müssen in der \\ /etc/inetd.conf \\ fesgelegt werden !!!

**tcpdchk** --> die Konfiguration des inetd auf logische Fehler und Konsistenz prüfen
-i <Datei> --> eine alternative inetd.conf Datei übergeben

-v --> Die momentan geltenden Regeln auflisten

__xinetd__
+ vereint tcp wrapper und inetd
+ aufteilen einzelner Dateien im Ordnder \\ /etc/xinetd.d \\ oder in \\ /etc/xinetd.conf \\
+ eigene Protokollierung 

Aufbau einer xinetd.conf
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#Kommentar zum Beispiel Name des Dienstes
defaults 
	{
		<Attribut> <Operator> 	<Parameter> [<Parameter> ...]
	}

service <Dienst>
	{
		<Attribut> <Operator>	<Parameter> [<Parameter> ...]

	}

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
default --> Einstellungen die für alle Dienste grundsätzlich gelten
	--> wenn es mehere Konfigurationsdateien gibt steht dieser Wert meistens in \\ /etc/xinetd.conf \\

service <Dienst> --> Einstellungen für den service <Dienst> 
		 --> Dieser muss in der Datei \\ /etc/services \\ definiert sein

<Attribut> --> hängt vom konfigurierten Dienst ab

Attribute die den Dienst näher beschreiben:

type
	Werte:
		INTERNAL --> Dienst wird durch en xinetd zur Verfügung gestellt
		UNLISTED --> Dienst ist nicht in der \\ /etc/services \\ verzeichnet
		RPC --> ist ein RPC Service

socket_type
		Werte:
			stream, dgram, raw, seqpacket

protocol --> Der definierte Wert muss in \\ /etc/protocols \\ stehen

wait
	Werte:
		yes --> Dienst wird nur einmal gestartet (Single threated)
		no --> Dienst darf mehrmals aufgerufen werden (multi threadet)

user --> gibt den Nutzernamen des Bneutzers an unter denen der Dienst laufen soll

instances --> impliziert wait = no
	  --> Maximal gleichzeitig erlaubter Instanzen

server --> Absoluter Pfad zum Server

server_args --> Argumente und Optionen die dem Server Programm mit übergeben werden

interface  --> Netzwerkgerät auf dem der Dienst kommuniziert


Attribute die das logging steuern:
log_on_success 
		Werte:
			USERID --> vermerkt die Benutzer-ID
			HOST --> Adresse des entfernten Hosts
			PID --> Protokolliert die PID des Servers
			DURATION --> Die Dauer die dieser Dinest gelaufen ist
			EXIT --> exit Status des Servers

log_on_failure
		Werte:
			USERID --> vermerkt die Benutzer-ID
			HOST --> Adresse des entfernten Hosts
			ATTEMPT --> Protokollieren erfolgloser Anmeldeversuche
			RECORD --> Vermerkt die Verbindungsversuche die vom entfernten Server entgegengenommen wurde
			       --> nicht überall implementiert

<Operator> --> = Zuweisung eines Wertes
	   --> += Hinzufügen eines Wertes
	   --> -= Entfernen eines Wertes	
	
Attribute die die Zugriffskontrolle steuern:

only_from --> Liste von Hosts denen es erlaubt ist eine Verbindung zum Rechner herzustellen
	  --> 172.16.12.5 definiert einen bestimmten Host 137.42.0.0 alle Hosts deren IP mit 137.42 beginnen
	  --> 0.0.0.0 definiert alle bekannten Hosts
	  --> einen Netzwerknamen der in der Datei \\ /etc/networks \\ definiert ist	
	  --> einen Adressbereich wird wie folgt definiert: a.b.c.{1,3,45} 
	  --> einen Hostnamen der in der \\ /etc/hosts \\ steht
	  --> IP-Adresse mit einer dazugehörigen Netzmaske in CIDR 187.43.212.128/24

no_access --> liste von Hosts denen der Zugriff auf diesen Dienst Grundsätzlich nicht gestattet wird
	  --> Beschreibeung der Hosts erfolggt wie bei only_from

access_times --> Tageszeit zu denen ein bestimmter Dienst verfügbar ist
	     --> <stunde>:<minute>-<stunde>:<minute>

disable --> Verhindert das Starten des Dienstes
	--> kann gesetzt werden um einen Dienst kurzristig das Starten zu verbieten

disabled --> nur in defaults Abschnitt der \\ /ect/xinetd.conf \\
	 --> Angabe einer Liste von Diensten die beim Start des xinetd nicht aktiviert werden

**service xinetd** --> Starten des xinetd als Systemdienst

**xinetd** --> einmaliges manuelles Starten des xinetd \\ /usr/sbin/xinetd \\
-syslog <Kategorie> --> Protokollnachrichten werden an den Syslog bzw. rsyslog daemon gesendet
		    --> Kategorie siehe rsyslog

-filelog <Dateiname> --> Alle Protokollnachrichten werden in diese <Datei> eingetragen
		     	
-f <Daei.conf> --> Verwende <Datei.conf> als Konfigurationsdatei

-inetd_ompat --> liest neben der xinetd.conf auch die Konfiguration des inetd die inetd.conf

+ Anpassen sollte man diese Optionen Datei in \\ /etc/init.d/xinetd \\

**itox < /etc/inetd.conf > /etc/xinetd.conf** --> konvertieren der Einträge in inetd.conf in xinetd.conf

===Einrichten der Systemzeit===

__Anzeigen und setzen der Hardwareuhr mit **hwclock**__

**hwclock** --> anzeigen und einstellen der Hardwareuhr
	    --> kann nur von root ausgeführt werden da dazu auf einen Interrupt zugegriffen werden muss

-r | --show --> anzeigen der aktuellenb Zeit auf der Hardwareuhr

-s | --hctosys --> setzen der Sytemzeit von der Hardwarezeit

--systohc --> setzen der Hardwarezeit aus der Systemzeit

-u --> die CMOS-Uhr in UTC

--set --date="<Datumsstring>" --> setzen der Uhrzeit mittels Datumsstring

__Zeitzone einstellen__
\\ /etc/timezone \\ --> beinhaltet die Zeitzone die bei der Intsallation festagelegt wurde

\\ /etc/sysconfig/clock \\ --> beinhaltet die Zeitzone die bei der Installation festgelegt wurde $$SUSE$$ $$Fedora$$

\\ /etc/localtime \\ --> ist ein symbolischer link auf die Datei \\ /etc/timezone \\ 

\\ /usr/share/zoneinfo/<COUNTRY>/<TIME_ZONE> \\ --> beinhaltet in Unterordner die entsprechenden Zeitzonen
			
__Die Variable TZ__
+ kann gesetzt werden um die Zeitzone kurzfrisitg zu setzen
+ Beschreibung von Zeitzonen

**export TZ=MEZ-1** --> Mitteleuropäische Zeit - 1 Stunde
**export TZ=Zulu+7** --> Zulu-Zeit + 7 Stunden

+ affektiert **date**

**tzselect** --> auswählen der Zeitzone
	     --> Gibt einen gültigen String aus, der in der Variable TZ gesetzt werden kann

1) **tzselect**

2) >> <TIMEZONE>

3) **export TZ=<TIMEZONE>**

**zdump <TIMEZONE>** --> gibt Informationen über die <TIMEZONE> (Uhrzeit, Datum, Formatierung) aus

**zdump /etc/timezzone** --> liest die Datei und gibt sie auf dem Bildschrim aus ebenso kann damit dementsprchend
			     der link \\ /etc/localtime \\ gelesen werden


!!! Wird eine Zeitzone gesetzt die das System nicht kennt, wird CET verwendet. !!!

__Datum und Uhrzeit verwalten__
TZ --> Umgebungsvaribale die auf die aktuelle Zeitzone verweist 

\\ /usr/share/zoneinfo \\

**date MMTThhmm [CCYY] [.ss]**
--> setzt das Datum auf Monat:TagedesMonats:Stunde:Minute:Jahrhuntert:Jahr:Sekunde
-u --> UTC

**date +%Format**
--> gibt das Datum im entsprechenden Fomrat aus
%F Volles Datum. %Y-%m-%d
%Y Jahr
%m Monat
%H Stunde
%M Miunte
%S Sekunden
%m Monat
%d Tag des Monats

TRICK: Mit **date** die Zeit seit 01.01.1970 berechnen
**date -d "UTC 1970-01-01" <Unix-Seconds> seconds | <Unix-days> days**

**date --set --date="2010-18-11 18:03:13 +0100" --> explizites setzen des Datums und der Uhrzeit

__Zeit Synchroniesieren mit ntp__
+Das Network Time Protocoll kann zur Zeitsynchronisierung eingesetzt werden
+Dazu wird der **ntpd** gefragt 

**service ntpd start** || **/etc/init.d/ntpd start** --> startet den ntp Server

\\ /etc/ntp.conf \\ --> Konfigurationsdatei für den ntpd oder andere Zeitsynchronisationsdämonen die ntp sprechen

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# Abweichungen zur CMOS Zeit
driftfile /var/lib/ntp/ntp.drift
 
# NTP-Server
server ptbtime1.ptb.de
server ptbtime2.ptb.de
 
# Zugriff durch NTP-Server gestatten
restrict ptbtime1.ptb.de
restrict ptbtime2.ptb.de
 
# Zugriff vom localhost gestatten (ntpq -p)
restrict 127.0.0.1
 
# Zugriff aus dem internen Netz gestatten
restrict 192.168.1.0 mask 255.255.255.0
 
# allen anderen Rechnern Zugriff verwehren
restrict default notrust nomodify nopeer
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
pool.ntp.org --> Server Pool die Ntp Dienste bereit stellen


**ntpdate <Zeitserver>** --> Einen einmaligen (harten) Zeitabgleich
			 --> veraltet

**ntptrace <Zeitserver** --> Nachvollziehen einer Zeitsynchronisation
			 --> Zurückverfolgen der Zeitsynchronisation vom Server zum Client

**ntpq** --> Porgramm zum Abfragen des ntp Servers

-p --> die Liste von Peers Abfragen

-i --> Zeigt einen Prompt und liest von der Standardeingabe
-n --> Zeigt die IP-Adresse anstelle des Namens des Zeitservers an

**sntp** --> simple time protocol verwalten
-a --> (adjust) zeit manuell einstellen
-v --> Verbose

===Drucken und Druckserver===
+ \\ /dev/lpX \\ --> Gerätedatei die auf den Drucker verweist
+ Jedes Druckauftrag der an einen Drucker gesendet wird ist ein Job und werden mit einer eindeutigen Nummer bei 1
  beginnend durchnummerriert
+ Jobs können in Klassen aufgeteilt werden, jede Klasse kann einem oder mehreren speziellen Druckern zugeordnet werden


__Spooler__
SPOOL == Simultaneous Peripherial Operation On Line

+ sorgt dafür dass Dateien für den Drucker aufbereitet, in die Warteschlange gestellt werden und
  dann an den Drucker zur Jobverarbeitung geschickt werden

+ Nach der Verarbeitung des Jobs wird der Job aus der Warteschlange gelöscht



___Der Line Printer Daemon lpd__
+Bsd Überbleibsel 
+ Ansteuerun von Lokal (parallel oder seriell) angeschlossener Drucker
+ nur geeignet für einfach Druckertypen

\\ /etc/printcap \\ --> definiert die auf einem Rechner verfügbaren Warteschlangen und Drucker

\\ /var/spool/lpd \\ --> die Druckerwarteschlange

__CUPS ( common unix printing system)__
+ zum lpd kompatibel
+ basiert auf dem IPP (Internet Printing Protocol), RFC 1179
+ wird über HTTP transsportiert und bietet daher SSl Extensions, Proxy-Fähigkeit, Benutzerauthentifizierung
+ CUPS bietet einen eigenen zu BSD kompatiplen lpd, den cups-lpd
+CUPS wird durch einen HTTP-Server (CUPS Scheduler)
	+ sprcht IPP
	+ stellt Dokumentation bereit
	+ stellt Online Dokumentation bereit
	+ unter http://localhost:631 anprechbar

\\ /usr/share/cups/model \\ --> enthält die Druckerbeschreibungsdateien ppd

**cups-lpd** --> der cups kompatible lpd
	     --> wird über xinetd.conf bzw. inetd.conf konfiguriert	

-n --> kein reverse DNS lookup der Clients

-o <name>=<wert> --> zusätzliche Optionen für Drucker Queues 

__Befehle zum Drucken__
**cat <Datei> > /dev/lpX** --> die Datei wird an das Gerät \\ /dev/lpX \\
			   --> setzt Formatierung vorraus die der Drucker versteht
			   --> kein Programm oder User kann gleichzeitig drucken
			   --> kann zur Hardwarediagnose herangezogen werden

**lpr <Datei>** --> arbeitet wie ein Filterporgramm auch mit Pipes und Dateiumleitung zusammen

-H <Server>:<Port> --> einen anderen DruckerServer spezifizieren

-E --> verschlüssleung explizit verlangen

-C | -J | -T <Name> --> setzen eines Jobnamens

-# N --> N Anzahl der Kopien

-h --> keine Banner drucken

-l --> Datei ohne Formatierung an den Drucker senden 

-o <Druckeroption> --> Angeben einer <Druckeroption>, **man lp** zeigt alle möglichen Druckeroptionen

-r --> nachdem die Datei ausgedruckt wurde wird sie gelöscht

-m --> Eine Mail an den Nutzer senden sobald der Job beendet wurde

-P<Printer> --> einen Drucker <Printer> für den Auftrag angeben

PRINTER --> Umgebungsvariable die wenn gesetzt 

Beispiele:
**pr -l50 handbuch.txt|lpr** --> die Ausagbe einer Datei wird durch eine Pipe an den Drucker gesendet

**diff datei1 datei2|lpr**

**lpr datei1.txt datei2.txt** --> die Ausgabe mehrerer Dateien an den Drucker

**lpr -#3 -Plaser datei1.txt**  --> Die Ausagbe 3 mal auf den Drucker laser drucken

**lpr -o sides=two-sides-long-edge manual.pdf** --> Angabe einer Druckerformatierung


**lp <Datei>** --> zu System V kompatibler Druckerbefehl
	       --> wird von CUPS emulliert um rückwärtsportabilität zu grantieren
 
-h <Server>:<Port> --> einen alternativen Server bestimmen

-E --> Verschlüsselung explizit verlangen

-t "<Jobname>" --> Setzen eines Jobnamens

-n N --> N Anzahl der Kopien 

-d <Printer> --> einen Drucker <Printer fpr den Auftrag angeben

Einige Parameter bei -o:
media=<typ> --> Papiergröße 
	    --> gültige Werte sind zum Beispiel A4, letter
	    --> genaue Werte für den Drucker ergeben sich aus den ppd Dateien

landscape --> drucken in Querformat

sides={one,two-sided-short-edge,two-sided-long-edge} --> beidseitg formatiertes Drucken, querformat, hochformat

page-ranges=<liste> --> Angabe eines bestimmten Brecihs von Seiten die gedurckt werden soll, erlaubt ist
			N
			N,M
			N-M
			und vergelichbare kombibationen dieser Schreibweise

page-set={odd,even} --> drucke nur ungerade, gerade Seiten

outputorder={normal,reverse} --> in normaler, rückwärtiger Reihenfolge beim Drucker ausgeben

number-up={n1,...,nn} --> druckt die Seiten n1 bis nn auf eine Seite verkleinert

page-border={none,single,single-thick,double,double-thick} --> Option setzt mehrfavchdruk vorraus und gibt Rahmendicke von 
							       none (keinen) bis double-thick (extra dicker rand)

number-up-layout={btrl,btrlr, lrbt, lrtb, rltb,tblr,tbrl} --> Anordung der Seiten
							     b=bottom
							     t=top
							     r=right
							     l=left
							({btrl}to{btrl}{btrl}to{btrl}) 

prettyprint --> Kopfzeile mit Seitennummer und Auftragsnamen
	    --> Syntaxhervorhebung bei Programmiersprachen


__Anzeigen der Standardoptionen__
**lpoptions** --> Anzeigen und bearbeiten der Standardoptionen des Druckers
	      --> wenn ohne Optione aufgerufen werden nur die festeglegten Standardoptionen aufgerufen
	
-r --> entfernen der Standardoptionen

-o --> neue Optionen festlegen  

\\ ~/.cups/lpoptions \\  --> Eintragen der Standardoptionen
\\ ~/.lpoptions \\ 


__Einsehen der Druckerwarteschlange__
**lpq** --> Inhalt der Standardwarteschlange auflisten

-E --> Verschlüsselung bei der Kommunikation mit dem Server verlangen

-P <Printer> --> Angabe einer Warteschlange auf dem Drucker <Printer>

-l --> zusätzliche Informationen zum Drucker 

-h <Server>:<Port> --> einen alternativen Server ansprechen


__CUPS Statusinformationen anzeigen__
**lpstat** --> CUPS Statusinforamtionen abfragen

-E --> Verschlüsselung bei der Kommunkikation mit dem Server verlangen

-R --> Zeigt die Rangliste von Druckjobs

-a --> zeigt ob die Warteschlangen Aufträge akzeptieren

-c --> Druckerklassen und dazugehörige Drucker anzeigen

-d --> Auflistung des aktuellen Standarddrucker

-o --> Zeigt den Inhalt der Warteschlangen an

-p --> Zeigt die Druckerwarteschlangen an

-r --> Zeigt an ob der Scheduler läuft

-t --> äquivalent zu -rdcvapo

-u --> Nutzerinformationen für die Printerqueue anzeigen

__löschen von Druckeraufträgen aus der Queue__
**lprm** --> storniert den letzten Druckauftrag
         --> nur Aufträge die noch nicht an den Drucker geschickt wurden

-P <Printer> --> Angabe eines Jobs für den Drucker <Printer>

-a all --> Storniert alle Jobs in der Druckerwarteschlange

Beispiele:
**lprm 333** --> löschen des Jibs mit der Auftragsnummer 333

**lprm -** --> löscht alle Druckaufträge zu denen man als Nutzer die Berechtigung hat

**cancel <Warteshlange>-<Auftragsnummer>** --> System V kompatibel
					   --> storniert die Jobs mit de Auftragsnummer in der Warteschlange
					   --> 	
-a --> Alle Jobs

-u <User> --> nur der Job des Nutzers <User>

**enable <Printer>** | **disable <Printer>**  --> Drucker einschalten|anhalten

**accept <Printer>** | **reject <Printer>** --> Druckerauftrag akzeptieren | ablehnen


__Drucker kontrollieren mit lpc__
**lpc** --> Programm zum Kontrollieren diverser Druckoptionen, line printer control


__CUPS einrichten__

\\ /etc/hosts.lpd \\ --> Eine Liste von Hosts die über diesen DruckerServer mit Druckern kommunizieren dürfen

\\ /etc/cups/mime.types \\ --> Bestimmung des Datentyps der gedruckt werden soll
			   --> Informationen die zur Umwandlung von Formatten in druckbares Format enthält

\\ /etc/classes.conf \\ --> Konfigurationsdatein für jede Klasse von Druckern

\\ /etc/cups/mime.convs \\ --> Bestimmung der Filterprogramme zur Umwandlung verschiedener Formate

\\ /etc/cups/printers.conf \\ --> Informationen über installierte Drucker

\\ /etc/cups/ppd/ \\ --> Hier wird für jeden Drucker eine ppd Datei aus der \\ /usr/share/cups/model \\ kopiert

\\ /etc/cups/cupsd.conf \\ --> algemeine Konfigurationseinstellungen des CUPS Scheduler 
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
<Location /printers>
	Order Deny,Allow
	Deny from all
	Allow from 127.0.0.1
	Allow from 192.168.123.0/24
</Location>

<Location /printers/newlp>
	Order Allow,Deny
	Allow from 127.0.0.1
	Allow from 192.168.123.0/24
	Deny from 192.168.123.45
	</Location>
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\\ /usr/share/cups/model \\ --> die ppd Dateien, die einen Drucker beschreiben

\\ /var/log/cups/access_log \\ --> Logdatei der Zugriffe auf den eingerichteten Drucker protokolliert

\\ /var/log/cups/error_log \\ --> Logdatei die mögliche Fehler protokolliert

$$www.linuxprinting.org$$

http://localhost:631/ --> ruft das Konfigrationsprogramm zu CUPS in einem Browser auf

**lpadmin** --> Tool zur Verwaltung des Druckerservers CUPS an der Kommandozeile

-p <Name> --> Name der neuen Warteschlange setzen

-E --> die Warteschlange für Aufträge freischalten, das gleiche wie **cupsenable** 

-v <Anschuss> ---> Anschlussdescriptor und Art des Druckers
	<Anschluss> = <Anschlussdiscriptor:/dev/lpX> --> siehe **lpinfo -v**

-m <ppd> --> spezifiziert die ppd Datei

-D --> (Description)Angabe einer Druckerbeschreibung

-L --> (Localisation) Angabe einer Örtlichkeit

-d <Printer> --> Angabe eines Standarddruckers

-c --> Drucker einer Klasse hinzufügen

-r --> Drucker aus einer Klasse entfernen

-x <Printer> --> löschen eines nicht mehr benötigten Druckers


Beispiel:
**lpadmin -p LaserJet4000 -E -v socket://192.168.128.31 -m laserjed4000.ppd** 
--> fügt einen verschlüsselt kommunizierenden Drucker Laserjet4000 hinzu der über das Netzwerk auf der IP 192.168.128.31
    horscht

**lpadmin -p LaserJet4000 -u allow:all** --> allen den Zugriff auf den Drucker Laserjet4000 erlauben

**lpadmin -p LaserJet4000 -u deny:peter,paul --> Den Nutzern Peter,Paul das Drucken auf den Drucker LaserJet4000 verbieten

**lpinfo** --> Liste der unterstützen (nicht zwingend instllierten) Druckergeräte
-v --> verfügbare Anschlusstypen aufzeigen die mit **lpadmin -v** angegeben werden können 

-m --> verfügbare ppd Dateien aufzeigen die mit **lpadmin -m** angegeben werden können

-l --> Statusinformationen über momentan verfügbare Drucker

Beispiel:
**/usr/sbin/lpinfo -m|grep LaserJet_4000** --> Anzeigen aller für den LaserJet 4000 verfügbaren ppd Dateien

===Dies Secure Shell ssh===
+ Netzwerkprotokoll der TCP/IP Familie
+ Datenübertragung mit sicherer Authentifizierung und Verschlüsselung
+ interaktive Anmeldevorgänge
+ gesicherte Weitereitung an andere Protokolle (tunneling)
+ ersetzt die unsicheren Protokolle TELNET, RLOGIN und RSH

__Openssh__
+ bietet Schutz gegen diese Angriffe aus dem Netz:
	*DNS Spoofing
	*IP Spoofing
	*IP Source Routing
	*Ausspähen von Klartextwörtern und Nutzerdaten
	*Manipulation von Daten
	*Angriffe auf den X Server durch vorgetäuschte Verbindungen zum X11-Server
 
!!! Version 1 sollte nicht mehr eingesetzt werden, da sie verschiedene Sicherheitslücken aufweist !!!

__Anmelden auf einem entfernten Rechner__
**ssh [<User>@]<Host>** --> Anmelden als Nutzer <User> auf <Host>
		      --> Wird kein Nutzernamen angegeben geht ssh davon aus, dass die <User> lokal und remote
			  übereinstimmen

-4|-6 --> IPv4|IPv6  bei der Übertragung verwenden 

-o --> Eine Option **man 5 ssh_config** übergeben

-X --> X Session Porgramme ausführen (Aktiviert X Forwarding)

-Y --> Trusted X Session Programme ausführen (aktiviert Trusted X Forwarding)

**exit** | <Strg>+D --> Verbindung zum Server schließen

!!!Nur das Überprüfen des Hostkeys gewährleistet dass keiner die Verbindung belauscht !!!

**ssh-keygen -l -f /etc/ssh/ssh_host_rsa_key** --> verifizieren des Host Keys zu dem dei Verbingung stattfindet

\\ ~/.ssh/known_hosts \\ --> öffentliche Schlüssel die vom Nutzer akzeptiert werden

\\ /etc/ssh/ssh_known_hosts \\ --> Systemweite Liste der bekannten HostKeys
			       --> Sollte Konfigurtiert sein, Public Keys der Vertrauenswürdigen Hosts eingetragen werden

\\ /etc/ssh/ssh_host_rsa_key.pub \\ \\ /etc/ssh/ssh_host_dsa_key.pub \\ --> öffentlicher Schlüssel auf dem Host
									--> rsa bzw. dsa verschlüsselt

\\ /etc/ssh/ssh_host_rsa_key \\ \\ /etc/ssh/ssh_host_dsa_key \\ --> privater Schlüssel
								--> rsa bzw. dsa verschlüsselt

\\ ~/.ssh/autorized_keys \\ --> Schlüssel der Hosts, die sih am System des Benutzers anmelden dürfen
			    --> existiert die Datei nicht, dürfen alle Hosts

\\ ~/.ssh/config \\ --> Konfigurationsdatei die das Verhalten von ssh für den Nutzer kontrolliert
		    --> Clientseitig
	
\\ /etc/ssh/ssh_config \\ --> Systemweite Konfigurationsdatei die das Verhalten von ssh für Nutzer kontrolliert
			  --> Clientseitig

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#Falls keine Optionen angegen wurden lies ~/.ssh/config
#Falls keine Optionen angegeben wurden und keine ~/.ssh/config vorhanden nutze /etc/ssh/ssh_config

Host * #Die Restriktionen gelten nur für diese Hosts, * meint alle Restriktionen gelten für alle Hosts
AdressFamily (any, inet,inet6) #nur Verbindungen dieses Typs zulassen (belibige, IPv4, IPv6)
BatchMode (yes,no) #Passwortabfrage einschalten (yes), ausschalten (no)

ForwardAgent (yes,no) #Authentification wird zur Remotstelle weitergeleitet (yes), nicht weitergeleitet (no)
ForwardX11 (yes,no) #X11 Verbindungen werden zugelassen (yes), nicht zugelassen (no)
ForwardX11Trusted (yes,no) #X11 Verbindungen zum originalen X11 Server werden zugelassen (yes), nicht zugelassen (no) 

RSAAuthentication (yes,no) #RSA Authentifikation zulassen (yes), (nicht zulasen)
PasswordAuthentication (yes,no) #Passwort Authentifikation nutzen (yes), nicht nutzen (no)
HostbasedAuthentication (yes,no) #rhosts Authetifikation mit Public Key zulassen (yes), nicht zulassen (no)
CheckHostIP (yes,no) #die Datei known_hosts wird bei Verbindungen überprüft (yes), nicht überprüft (no)
ConnectTimeout (N) #Anzahl der Sekunden die der Client bei fehlgeschlagenen Verbindungne warten soll
SrictHostKeyChecking (ask,no,yes) #nachfragen, alle Verbindungen zulassen, nur Verbindugnen in known_hosts zulassen

IdentityFile ~/.ssh/identity
IdentityFile ~/.ssh/id_rsa
IdentityFile ~/.ssh/id_dsa
Port 22
Protocol 2
Cipher 3des,aes128-ctr,aes192-ctr,aes256-ctr,arcfour256,arcfour128,aes128-cbc,3des-cbc
#   EscapeChar ~
Tunnel (yes,no) #Point to Point Tunneling aktivieren (yes), nicht aktivieren (no)
TunnelDevice any:any
PermitLocalCommand (yes,no) #Nutzen von lokalen Befehlen (yes), nicht nutzen (no)

# Senden lokaler Umgebungsvariablen bei der Verbindung
SendEnv LANG LC_CTYPE LC_NUMERIC LC_TIME LC_COLLATE LC_MONETARY LC_MESSAGES 
SendEnv LC_PAPER LC_NAME LC_ADDRESS LC_TELEPHONE LC_MEASUREMENT 
SendEnv LC_IDENTIFICATION LC_ALL
VisualHostKey (yes,no) #Ascii Art Repräsentation des ssh Schlüssel aktivieren 
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\\ /etc/ssh/sshd_config \\ --> Konfiguration von ssh Serverseitig
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
AllowTcpForwarding (yes,no) #Tcp Verbindungen auf diesen Server erlauben|verbieten

AuthorizedKeysFile %h/.ssh/authorized_keys #spezifiezieren der Datei der PublicKeys fpr erlaubte Nutzer

ChrootDirectory #Verzeichnis zum Chroot Jail

MaxSessions #Maximale Anzahl erlaubter Netzzugriffe

PermitRootLogin (yes,no) #Nutzer root darf sich anmelden|nicht anmelden

PermitTunnel (yes,no) #Tunneling erlauben|nicht erlauben

SyslogFacility #Festlegen der Syslog Facility

X11Forwarding (yes,no) X11 Forwarind ein|aus

Port --> gibt den Port an auf dem der sshd lauschen soll
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

__Escape Zeichen die das Verhalten der ssh Steuern__
~. --> beenden der Verbindung

~^Z --> ssh in den Hintergrund schieben wie <strg>-Z

~# --> liste der geforwardten Vernindungen

~& --> ssh in den Hintergrund schieben

~R --> Den Keyring abfragen

__scp und sftp__
**scp <Datei.lokal> [<user>@]<host>** --> kopieren einer Datei auf den entfernten Rechner über ssh
**scp [<user>@]<host> <Datei.lokal>** --> kopieren der Datei von einem entfernten Rechner

-r --> rekursiv

-p --> berechtigungen und Timestamps auf dem Ziel erhalten

-q --> keinen Fortschrittsbalken anzeigen (quiet)

-4|-6 --> IPv4|6 für die Übertragung nutzen

-c <cipher> --> Den Chefrieralgothmus angeben der bei der Übertragung verwendet werden soll

-l <limit> --> Die Benutzte Bandbreite auf Kbits/s beschränken

-P <N> --> Den Port <N> auf dem entfernten Host angeben

**sftp [<user>@]<host>** --> Aufbauen einer ssh Verbindung der das ftp Protokoll nutzt
	*pwd* --> das Arbeitsverzeichnis auf dem ftp server ausgeben
	*lpwd* --> Das Arbeitsverzeichnis auf dem lokalen Rechner ausgeben
	*ls* --> auflisten der Dateien auf dem ftp server
	*lls* --> Verzeichnis der Dateien auf dem lokalen Rechner auflisten
	*cd* --> Verzeichnis wechseln auf dem ftp server
	*lcd* --> Verezichnis wechseln auf dem lokalen Rechner
	*mkdir* --> Verzeichnis auf dem ftp server anlegen
	*lmkdir* --> Verzeichnis auf dem lokalen Rechner anlegen
	*get* --> eine Datei herunterladen, Wildcards werden verstanden
	*put* --> eine Datei hochladen, Wildcards werden werden verstanden
	*bye* --> die Verbindung beenden
	? --> Hilfe anzeigen

__Client-Authentifizierung über Schlüsselpaare__
+ Authentifizierung erfolgt nur über angelegte Schlüsselpaare und nicht mehr über \\ /etc/passwd \\

**ssh-keygen rsa** --> erstellen eines ssh Schlüsselpaares 
		      --> dabei wird der rsa Verschlüsselungsalgorithmus verwendet
		      --> Es werden ein Private und ein Publickey erzeugt

-t <Cipher> --> einen anderen Verschlüsselungalgorithmus verewnden rsa oder dsa

-b <Lenght> --> Die bitlänge des verwendeten Schlüssels spezifizieren, die default länge beträgt 2048
	    --> Ein dsa Schlüssel muss genau 1024 Bits lang sein
	    --> bei schnelleren Rechner sollte eine Länge von 4096 Bits verwendet werden

-f <Datei> --> Die <Datei> in der der Schlüssel angelgt werden soll

-D <Reader> --> downloaden des verwendeten Schlüssels im Smartcard Lesegerätes

-R <Reader> --> uploaden des verwendeten Schlüssels zum Smartcard Lesegerät

!!! ssh Schlüssel ohne Passwort wird nicht empfohlen muss aber für unbeaufsichtigte cron-Jobs angelegt werden !!!

Beispiel:
**ssh-keygen -t rsa -b 8146 -f test** --> Einen rsa Key mit Schlüssellänge 8146 bytes in test erzeugen
**ssh-copy-id <user>@<host>** --> ablegen des öffentlichen Schlüssels im entfernten Benutzerkonto

Workflow:
(1) Erstellen des Schlüsselpaares
(2) kopieren des Öffentlichen Schlüssels in die \\ ~/.ssh/authorized_keys \\ **ssh-copy-id**
(3) in \\ /etc/ssh/ssh_config \\ "PasswordAuthentification no" und "PubkeyAuthentification yes" stellen
    erfolgt die Authentifizierung nur noch über Schlüsselpaare

__Benutzen dess ssh Agents__
**ssh-add** --> starten des ssh-Agents und hinzufügen des Passworts
-l --> Auflisten der momentan vom Agent bekannten keys

-d <User> --> löscht die gespeichete Identität von <User>

-D --> löschen der gespeicherten Identitäten

-x |-X --> sperren|entsperren des ssh Agenten


__Portweiterleitung über SSH__

a) Weiterleitng auf X11
+ ermöglicht das Ausfürhen von grafischen Programmen auf dem entfernten Rechner wobei Bedienung und Anzeige lokal erfolgen

**ssh -X [<user>@]<host>** --> alle X-Programme werden auf dem Server ausgeführt aber lokal angezeigt
			   --> \\ /etc/ssh/sshd_config \\
			   --> die DISPLAY Variable wird entsprechend des Proxy-X-Servers gesetzt
			   --> Änderungen werden an den lokalen Clients vorgenommen !!!vorsicht Sicherheit!!!	

b) Beliebige TCP-Ports weiterleiten
**ssh {-L|-R} [loacalhost]:<lokalerPort>:<example.com>:<Port> [<nutzer>@]<host> [{-N|-f sleep n}] **
--> etabliert eine lokale Verbindung auf <lokalen Port> und öffnet auf <host> einen Port der zur Kommunikation mit
    dem Rechner <exmple.com> verwendent wird
--> wird localhost weggelassen dürfen sich auch andere Rechner im Netzwerk über diesen Port verbinden
--> wird -N verwendet wird keine interaktive Session aufgebaut sondern nur mit dem ssh-Server gesprochen
--> wird -R anstelle von -L verwendet funktioniert die Portweiterleitung anders herum
--> mit -f sleep N kann bestimmt werden dass die Verbindung nur n Sekunden lang offen bleibt
-T --> Auschalten von Pseudo /dev/ttys Zuweisungen

===E-Mail konfigurieren und anwenden===
MUA: + Mail User Agent ermöglicht das schreiben, empfangen, und verwalten von EMails
MTA: + Mail Transfer Agent organisiertn die Weiterleitung im Netz
MDA: + Werden von MTAS verwendent um Nachrichten abzulegen, diese werden dann vom MUA abgeholt


__MTAs__
+ MTA = Mail Transfer Agent
+ verwenden das SMTP / IMAP Protokoll
+ **sendmail** **postfix** **exim** **qmail** sind MTAs die unter Linux installiert werden können
+ Grundsätzlich kann nur ein solcher MTA installiert und verwenden werden
+ die meisten Distributione weisen bei der installation mehrerre darauf hin bzw. erlauben dessen Installation nicht

!!!Postfix ist der MTA der empfohlen wird !!!

MTA --> lauscht auf Port 25 auf Verbindungen von anderen MTAs auf Nachrichten von anderen Empfängern
    --> Nachrichten werden dann über einen MDA (Mail Delivery Agent) an die Postfächer der Benutzer weitergeleitet
    --> muss als freistehender Dienst oder via inetd /xinetd aufrufbar sein	
    --> der MTA muss mindestens auf dem lokalen Host lauschen um lokal Nachrichten zum Beispiel an root senden und
	empfangen zu können

**sendmail** **postfix** **exim**
\\ /var/spool/mail \\  \\ /var/mail \\ --> Nachrichten für lokale Benutzer werden von sendmail hierher geschrieben
				       --> \\ /var/mail \\ ist eine sybolischer link der auf \\ /var/spool/mail \\
					   verweist
				       --> von hier können MUAs (Mail User Agents) auf die Mail zugreifen
				       --> Jedem Postfach ist hier eine Datei <User> für den entsprchenden User zugeordnet

\\ /var/spool/mqueue \\ --> zwischenspeichern für in der Wartenschlange befindliche Mails **sendmail**
\\ /var/spool/exim \\ **exim**
\\ /var/spool/postfix \\ **postfix**

**qmail**
--> verwendet Maildir eigenes Format im Heimatverzeichnis des Benutzers
--> Verwendet eine Verzeichnisstrukur anstelle einer einzigen Datei
--> Vereinfachung von Kontigentsverwaltung

\\ /var/qmail \\ --> Warteschlange für qmail

!!! Verezichnisse \\ /var/spool \\ /var/spool/mqueue \\ sollten sich auf einer seperaten Partition befinden!!!
!!!damit Nutzer nicht mit Mails die Platte vollmüllen!!!

__Verwalten der Wateschlange__
**mailq** --> Abfragen der Warteschlange für Mails äquivalent zu **sendmail -bp**
>> Status (*,!)
		* --> Message ist für den Versand aktiviert
		! --> Message wird nicht versendet bis der Hold Status wieder entfernt wird

**qmail -qread** --> Abfragen der Warteschlange bei qmail

**sendmail -q[Rm]** --> veranlasst sendmail die Warteschlange alle R Minuten abzuarbeiten
		    --> wird keine Zeitangabe angehängt wird die Warteschlange direkt abgearbeitet

**qmail** --> Um Qmail zu veranlassen muss dem Daemon qmail-send ein SIGALRM **kill -14** gechickt werden

__Lokale Zustellung, Aliasadressen und benutzerspezifische Weiterleitung__

\\ /etc/aliases \\ --> Konfigurieren der lokalen Auslieferung
		   --> Wer erhält Mail von wem 
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
root: joe #Mails werden an joe Weitergeleitet, die Mail für root wird gelöscht

root: joe, \root #Mails an root werden an joe weitergelitet aber root 
		 #behält seine Mails

root: joe, \joe@example.net #Mails werden an root und an joe@example.com weitergeleitet
			    #root behält seine Mails

#Restriktionen können für Realexistierende Benutzer und für Pseudoaccounts angelegt werden

#Nachrichten an datei werden einfach an diese angehängt
datei: /tmp/mailbeispiel.txt
#Nachrichten werden dem Programm /usr/local/bin/foo übergeben
program: "|/usr/local/bin/foo"
#Für Nachrichten an 
liste:   :include:/var/lib/list.lst

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\\ ~/.forward \\ --> Einstellungen zur lokalen Auslieferung für jeden einzelenen Benutzer
Beispiel:
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\tux "|/usr/bin/vacation tux" #Weiterleitung der NAchricht an den Automatischen Mailbeantworter
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
**vacation** --> Mail wird bei Abwesenheit an vacation weitergeleitet, dessen Nachricht 
		 sich in \\ ~/.vacation.msg \\ befindet

__Eine Mail senden__
**mail <User>** --> Eine Mail an User schicken
-s "Subject" --> Subject an die Mail anhängen


__Das SMTP Protokoll__
+ Simple Mail Transfer Protocol 
+ Protokoll zur Übertragung von Mails zwischen zwei Rechnern

>> HELO DONTPANIC.com --> der Client stellt sich vor
>> 250 mail.DONTPANIC2.de
>> MAIL FROM: <beeblebrox@DONTPANIC.de> --> Absenderadresse
>> 250 Ok
RCPT TO: <arthur@dontpanic2.de> --> Empfängeradresse
>> 250 Ok
>> DATA                        --> Beginn der Nachricht
>> 354 End >data with <CR><LF>.<CR><LF>
>>QUIT --> Beenden und senden

>> VRFY Marvin@dontpanic.de --> verifizierren des Nutzers
>> EXPN <verteiler@milliways.de> --> liefert sämliche Informationen aus der Verteilerlite zurück
>> NOOP --> wird benutzt um dem Server zu signalissieren, dass er seine Verbindung nicht abbauen soll
>> RSET --> setzt eine angefangene Mailübertragung zurück auf HELO

__Sendmail__
+ alle Mailprozesse laufen in einem Prozess ab
+ es wird nur ein Daemon gestartet
+ Iist auch in sendmail als Programm dabei

**service sendmail start**

\\ /etc/mail/sendmail.cf \\ --> Konfigurtationsdatei für Sendmail



**sendmail -bd -q30m** --> startet den Sendmail Daemin
		       --> arbeitet alle 30 Minuten -q seine Mail ab
-b --> Nachricht nicht von StdtIn lesen
-d --> als Daemon starten
-q <TIME> --> Zeit nach der die Queue abgearbeitet werden soll
-t lesen Adressdaten aus dem Kopfteil der Nachricht, diese muss dann einen Header To:- , BCC:-, CCC:- haben
-i --> Alias Datei schreien

**sendmail marvin@erde.de bebblebrox@erde.de <mail.txt** --> Eine Mail mail.txt von sendmail an marvin und beeblebrox senden


__Postfix__
+ basierte darauf dass jeder Service als eigener Prozess läuft
+ es werden mehrerre Daemons gestarte

\\ /etc/postfix/master.cf \\ --> Konfigurationsdateien für den Postfix Master Server
			     --> wird vom Master Posftox Daemon gelesen
			     --> master(5)
			     --> muss dem User Root gehören
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#
# Postfix master process configuration file.  For details on the format
# of the file, see the Postfix master(5) manual page.
#
# ==========================================================================
# service type  private unpriv  chroot  wakeup  maxproc command + args
#               (yes)   (yes)   (yes)   (never) (100)
# ==========================================================================
pickup	fifo	n	-	-	60	1	pickup
smtp	inet	n	-	-	6000	10	smtp
cleanup	unix	n	-	-	-	1	cleanup

<Service> definiert den zu nutzenden Dienst
	

<type> definiert die Art wie der Service kommunizieren soll
	inet --> TCP Socket
	unix --> Unix Domain Socket (Kommunikation auf demselben Rechner)
	fifo --> named PIPE FIFO
	pass --> Spezialfall von unix

<private> definiert ob der Dienst nur für das Posfix System zugänglich ist, Werte sind - und n, wobei - für den Standard y Steht
          <typ> inet kann nicht private sein

<unpriv> definiert ob der Dienst als root Starten soll oder als Eigentümer des Postfix Systems, Were sind - und n
	 Zustellmechanismen local,vitual, pipe können nicht unpriv sein

<chroot> definiert ob der Dienst im chroot /var/spool/postfix läuft 

<wakeup> gibt die Zeit in N Sekunden an nach der der Dienst aufgewcht werden soll
         pickup, qmgr, flush 
	? signalisiert dass der Dienst nur bei Verwendeung aufgeweckt wird

<maxproc> Anzahl maximal gleichzeitig zu startender Prozesse

<command + args> Programm das zur Verwendung des Dienstes ausgeführt wird entsprechende Parameter und Optionen
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


\\ /etc/postfix/main.cf \\ --> Allgemeine globale Konfiguration
			   --> muss dem User Root gehören
			   --> Konfigurtation gilt für alle Server Daemons
			   --> postconf(5)
			   --> editerien mit **postconf -e**
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
<Parameter> = <Wert>,...
<Anderere Parameter> = $<Parameter>
myhostname = Beeblbrox
myorigin = $myhostname

#Einige Parameter
myorigin 		Spezifiziert die Domain für Mail die an diesen Rechner aus gesendet werden
myhostname		Der Name des Rechners
mydomain		Spezifziert die Elterndomäne, von der dieser Rechner Teil ist
mydestination		Dieer Rechner stellt Mail lokal zu dieser Zieladresse zu, anstellle sie weiterzuleiten
mynetworks		Für Forwarding authorisierte Netzwerke, diese werden in CIDR Notation und durch Komata getrenn angegeben	 
mynetworks style	#genauere Einstellungen für my networks
			<Wert>
				host 	Mails nur vom loaklen Rechner aus Forwarden
				subnet	Mails nur vom gleichen Subnetz forwarden, von dem auch diese Maschine Teil ist
				class	Mails von gleichen IP-Klassen Netz forwarden

relay domains		konfigurieren der authorisierten Zieladressen
			<Wert>
				<blank> 	Mails von unbekannten niemals forwarden
				$mydomain 	Mails forwarden an die lokale Domain forwarden
				$mydesitnation	standard

relayhost		Einstellen der Zustellmethode
			<Wert>
				<blank>		direkt an das Internet ausliefern
				$mydomain	Mail über den lokalen MailHub asuliefern
				mail.isp.tld	Mail über den Provider ausliefern

alias_maps		Speicherort für Aliastabellen
allow_mail_to_commands	Für wen soll eine Weiterleitung von mails an ein Kommando funktionieren
			<Wert>
				alias Weiteleitung nur in \\ /etc/aliases \\ gestattet
	
allow_mail_to_files	Für wen soll eine Weiterleitung von mails an Dateien funktionieren

masquerade_domains	Entferne Subdomains vom Domainname
masquerade_exeptions	Nutzer von der masquerade ausschließen
relocated_maps		Eingeben einer map Datei für Nutzer die umgezogen sind
always_bcc		festlegen einer Speziellen Adresse, an die Kopien geschickt werden können			
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\\ /etc/aliases \\ --> Email an bestimmete Personen ausliefern
		   --> benötigt den Eintrag postmaster
		   --> meherere Aliasstabllen möglich, siehe alias_maps
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

postmaster: root
root:Marvin, /var/log/marvinsmail

#weiterleitung an ein Programm
spammer: "/usr/sbin/spamkiller.sh"

#hinzufügen von includes
list: :include: /var/lib/mail/lists
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


\\ /etc/postfix/<tabelle> \\ --> kann eine Liste von Domains enthalten, die abgelehnt oder angenommer werden soll
			     --> nach ändern der <tabellen Datei wird diese mit **postmap <Datei>** bekanntgemacht
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
the.evil.spammer.de		REJECT
mybestfriend.org		OK
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

+ relocated map
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
marvin@magrathea.de	matvin@milliways
marvin@erde.de		"...@milliways"
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\\ /var/log/mail.log \\ --> Logdateien für Postfix und EMail spezifische Dienste


**postfix <Befehl>** --> steuert den Master Daemon
<Befehl>
	start --> Startet den Postfix Daemon
	stop  --> Anhalten des Postfix Daemons, laufende Prozesse werden erst beendet
	abbort --> Anhalten des Postfix, laufende Prozesse werden sofort ohne Nachfrage beendet
	reload --> neu einlesen der Konfigurationsdatei
	check --> überprüft die Konfigruationsdatei des Postfix Systems,
	      --> überprüft Zugrffsrechte auf Verzeichnisse, fehlende werden angezeigt
	flush --> alle aufgestauten Nachrichten ausliefern
	status --> Anzeigen ob der Postfix Master Daemon läuft
	upgrade-configuration <VAR=wert> --> Konfiguration von Postfix erweitern

**newaliases** --> neu einlesen der \\ /etc/aliases \\ Map Datei

**postmap <Datei> --> Lookkup Tabellen verwalten

**postconf [<Parameter>]** --> editieren und verwalten der Datei \\ /etc/postfix/main.cf \\
-c <DIR> --> Verzeichnis spezifizieren, in der die \\ main.cf \\ liegt
-d --> gib die Standardwerte aus
-e --> editieren der Konfigurationsdatei

**postconf mydomain** --> diese Werte ist für mydomain momentan gesetzt
**postconf -d mydomain** --> dies wäre der Standardwert für mydomain
**psotconf -e mydomain=horst** --> direktes Ädneren des Parameters mydomain

**postqueue** --> ansehen unausgelieferter Nachrichten in \\ /var/spool/mqueue \\

**postcat** --> Anzeigen von Nachrichten in einer Warteschlange

**postsuper** --> Adminstration von Postfix
-c <DIR> --> Verzeichnis spezifizieren, in der die \\ main.cf \\ liegt
-d <Queue-ID>|- --> löschen der Nachricht mit der <Queue-ID> aus der Queue, falls - werden Queue-Ids vom Stdin entgegen genommen
-h <Queue-ID> --> Mail anhalten, wird nicht ausgeliefert (hold)
-H <Queue-ID> --> Mail fortsetzetzen, halt lösen
-r <Queue-ID> --> Mail neu einreihen
-p --> reinigen der Mailqueue


__Procmail__
+ ist ein MDA
+ wird gerne häufig mit sendmail eingesetzt
+ unterstüzzt die Mail Formate mbox, maildir/
+ gezielte Weiterleitung bestimmter Nachrichten an bestimmte Adressen
+ vorsortieren von Mails
+ aussortieren von Mails
+ entfernen von von Mail Duplikaten
+ Mailbeantowrter

Procmail und Postfix:
+ in die \\ /etc/postfix/main.cf \\ eintragen: 

++++++++++++++++++++++++++++++++++++++++
mailbox_command = /usr/bin/procmail
++++++++++++++++++++++++++++++++++++++++

+ Transport im für den Master Postfix Daemon definieren
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
procmail unix	- n n - - pipe flags=DRhu user=mail argv=/usr/bin/procmail -a "${extension}" -d ${recipent}
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

+ als Benutzer den MTA verwenden \\ ~/.forward \\
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#wird <User> nicht angegeben und haben merhere Benutzer procmail für ihren MUA weitergeleitet
# so wird sendmail die Mail nur an einen der User zustellen
"|exec /usr/bin/procmail #<User>" 
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


\\ /etc/procmailrc \\ --> Systemweite Einstellungen
		      --> siehe procmailex(5)

\\ ~/.procmailrc \\ --> Benutzerspezifische Einstellungen
		    --> siehe procmailex(5), procmailrc(5)
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#Das Standardmailverzeichnis festlegen
#Arbeitsverzeichnis von Procmail
MAILDIR=$HOME/Mail

#Nachrichten die direkt vom Serverprozess Procmail kommen
LOGFILE=$HOME/.procmail.log

#Bericht über zugestellete Mails 
LOGABSTRACT=no|yes

#Programm zur Weiterleitung der Mail
SENDMAIL=/usr/bin/postfix

#erweiterte Protokolldaten einschalten
VERBOSE=no|yes

#Recepies
#werden nacheinander in der Reihenfolge ihres Auftretens abgearbeitet
:0 [<Optionen>]
* <Bedingung>,...
	[{<Unterrezept>
		}]
<Aktion>

<Optionen>
	H Bedigungen prüfen den Kopf der Email
	c nachricht kopieren
	A bei Verkettung von mehreren Recepies nur dann ausführen wenn die vorangeganegen Bedinung zutraf
	a Filter nur dann ausführen wenn der vorherige Filter korrekt beended wurde
	e Filter nur dann ausführen, wenn der vorherige Filter einen Fehler meldete
	B Bedingungen prüfen den Body der Email
	f Die Pipe in der <Aktion> wird als Filter interpretiert
	h nur den Kopf der Nachricht in <Aktion> mit einbeziehen	
	w Warten auf das Ende eiens in <Aktion> festelegten Programms, dabei werden Fehler nach StdOut geschrieben
	W Warten auf das Ende eines in <Aktion> festlegten Programms, dabei werden Fehler unterdrückt
	i Inoriere Fehler, die beim Schreiben in eine Pipe auftreten
	r keine Optimierungen an Emails wie das löschen unnötiger Leerzeichen durchführen	

<Bedingung>
	+ ist ein regulärer Ausdruck im Sinne von grep
	+ wird auf den Header der Nachricht angewandt
	+ wird die Bedingung weggelassen, so wird die Aktion immer ausgeführt
	+ mehrere Bedingungen werden UND-verknüpft
	+ FROM_DAEMON bezieht sich auf automatisch generierte mails

<Aktion>
	+ Aktionszeilen die mit ! steht für eine Mailweiterleitung
	+ kann meherere Aktionen unterienander stehen haben
	+ Programm weiterleitungen werden mut | eingeleitet

#Recipie vorsortieren:
#prüft pb Nachricht eine List-ID Kopfzeile hat und schreibt deren Wert gegebenenfalls in das mbox Postfach
:0
* ^List-ID:.*liste\.list-id\.site\.com
liste

#Recepie Weiterleitung an andere Adressen
:0
* ^From: .*marvin@parkhaus\.de
* ^Subject: *Wichtig:
! beeblebrox@milliways\.de

#Recipie kleinere Nachrichten weiterleiten
:0
* < 2048
! hanymailbox@admin.de

#Recipie automatische Mailbeantworter
:0 c
* !^FROM_DAEMON
* !^X-Loop: info@milliways.de
| (formail -r -I"Precdence: junk " -A"X-Loop: info@milliways.de"; echo "Vielen Dank für Ihre Anfrage.") | sendfail -f

#Recipe Duplikate aussortieren
0: Wh: msgid.lock
| formail -D 10240 msgid.cache


+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


Lokal:	+ MUA läuft auf dem Rechner auf dem auch der MTA|MDA läuft
	+ weiterleitung erfolgt meist direkt aus dem Postfach
	+ MDA und MUA müssen das gleiche Postfachformat benutzen

Pop3/IMAP: + Benutzer greifen über pop3/imap auf ihre Nachrichten zu
	   + MDA und MUA müssen das gleiche Postfachformat benutzen

__Spam und Viren__

Konfigurationen für Postfix:
\\ /etc/postfix/main.cf \\
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#Clients müssen sich mit HELO und EHLO sagen, bevor sie Mails verschicken dürfen
smtp_helo_required 

#Nur Mails annehmen die rfc821 konform sind
strict_rfc821_envelopes 

#Abweisen von gefälschtne lokal aussehenden Absenderadressen
smtpd_reject_unlisted_sender

#Mails mit nicht existierenden lokalen EMpfängeradressen abweisen
smtpd_reject_unlisted_recipent


#Restriktonen mit PERMIT, REJECT. DEFER
#Nach dem Verbindungsaufbau ausgewertete Kriterien
smtpd_client_restrictions

#Clients zurückweisen die keinen gültigen PTR Datensatz im DNS haben
reject_unknown_client

#Rechner dessen HELO keine gültigen MX und A Records haben abweisen
reject_unknown_hostname

#Zurückweisen einer nicht FQDN
reject_non_fqdn_hostname 

#Zurückweisen syntaktischer falscher Hostnamen
reject_invalid_hostname 

#Diese Domains immer abweisen
reject_rbl_clients = <Domain>,...

#Nach dem MAIL FROM auswerten
#smtp_sender_restrictions 

#Client mit SMTP-Senderadresse die nicht FQDN ist abweisen
reject_non_fqdn_sender 

#Sender abweisen deren Senderadresse keinen gültigen MX und A Records haben
reject_unknown_sender_domain 

#Nach RCPT TO ausgewertete Kriterien
#Anfrage von Clients abweisen, deren Empfängeradresse nicht FQDN ist
reject_non_fqdn_recipent 

#weist Client ab, deren Empfängeradresse keinen DNS A oder MX Record haben
reject_unknown_recipent_domain 

#Anfrage zulassen, wenn
#Domain der Empfängeradresse
#relay_domains erlaubte Sub DOmain
#lokale Zusetllung und die Empfängeradresse passt auf die entsprechenden Direktiven
#permit_auth_destination

#Abweisen er Anfrage, wenn keine der in permit_auth_destination Bedingungen erfüllt ist
rejefct_unauth_destination

#EIne Kette wird wie folgt gebildet
smtpd_client_restriction=permit_mynetworks, reject_unauth_destination,...hash:/AccessTabelle
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

+ Anlegen von Access Tabellen
+ **postmap** zum erzeugen der Datenbankdateien
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
<Ausdruck>	<Restriktion>

<Restiktionen>
	OK		Adresse akzeptieren
	4nn,5nn	<text>	Abweisen mit Fehlercode und <Text>
	REJECT <Text>	Abweisen mit Begründung <TEXT>
	DUNNO		Angeben dass die gesuchte Adresse nicht gefunden wurde
	DISCARD <text>	Behauptet erfolg aber verwirft Nachricht
	Restriktioenen 	Beliebige Resttioktionen benennen
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++	


__SpamAssasin__
+ eine Gute Filterung durch Postfix sollte immer voreerst in Betracht gezogen werden
+ Spam- und Virenfilter sind nicht resourcenschonend
+ Fügt Nachricht zusätzlich Kopfzeilen hinzu, die der Status der Prüfung wiedergeben
+ arbeitet nach einem Punkte System, Nachrichten mit einer gewissen Anzahl Spampunkte werden nicht mehr akzeptiert
+ Benutzer können die Nachricht dann vom MUA ausgewertet werden
+ kann als Deamon **spamd** laufen und über **spamc** Nachrichten zur Auswertung empfangen


\\ /.procmailrc
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#große Mails sind selten Spam
#Highlander Prinzip
:0fw: spamassasssin lock
* < 256000
| spamassasin

Falls Nachicht Spam löschen
:0:
* ^Spam_Status: Yes
! /dev/null

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


===GnuPG===
+ verschlüsseln und signieren von Dateien und elektronischer Mail

+ verschlüsseln meint hier das Unkenntlich machen einer Datei, so dass nur der Adressat sie lesen kann, der
  Zugriff auf die Datei ist weiterhin möglich wenn auch nur kauderwelsch zu sehen ist

+ Mit signieren kann man eine Datei auf Änderungen hin identifizieren, wird die Datei geändert ist die Signatur
  ungülitg

+ Signaturen werden bei der Paketverwaltung genutzt um die authentizität eines Pakes zu sichern

__Asymetrisches Verschlüsselungsverfahren__
Bob --> erzeugt ein Schlüsselpaar bestehend aus einem öffentlichen und einem privaten Schlüssel
    --> schickt seinen öffentlichen Schlüssel an Alice

Alice --> verschlüsselt mit Bobs öffentlichen Schlüssel

Bob --> entschlüsselt mit seinem Privaten Schlüssel die Mail die Alice ihm geschickt hat

__Schlüsselpaare generieren__
\\ ~/.gnupg \\ --> Konfigurationsdateien für gpg

**gpg** --> Programm zum Verwalten und erzeugen von Schlüsseln

--gen-key --> erzeugen eines Schlüsselpaares

--output <Datei.asc> --> Angabe eines Pfades für die Ausgabe

--gen-revoke "<Nutzer>" --> Anlegen eines Wiederufszertifikat für den "Nutzer" mit der NutzerID

--list-keys --> öffentliche Schlüssel die derzeitig zur Verfügung stehen anzeigen

--export --> einen öffentlichen Schlüssel nach Stdout schreiben

--armor --> in einem ASCII kompatiblen Format ausgeben

--keyserver <khp://subkeys.pgp.net> --send-keys <KeyID> --> senden des schlüsels der <KeyID> an einen
							    öffentlichen Schlüsselserver

--import <key> --> einen neuen öffentlichen Schlüssel importieren

--fingerprint <Nutzer> --> den Fingerabdruck für den Schlüssel für <Nutzer> ausgeben

--sign-key <Nutzer> --> den öffentlichen Schlüssel von Nutzer unterschreiben

--check-sigs --> überprüfen von Schlüsseln

---edit-key <Nurzer> --> interaktive Shell zum Bearbeiten der Einstellungen für einen Schlüsell von <Nutzer>
		*sign* --> signieren
		*lsign* --> signieren, nicht exportierbar
		*nrsign* --> nicht widerufbar
		*revsig* --> Sinatur widerufen
		*tsign* --> vertauensvolle Signatur
		*trust* --> Vertrauensstufe festlegen
		*disable* --> Schlüssel deaktivieren
		*enable* --> Schlüssel aktivierren
		*adduid* --> eine alternative NutzerID hinzufügen
		*addphoto* --> ein Photo hinzufügen
		*deluid* --> NutzerID löschen
		*delsig* --> Signatur löschen
		*expire* --> Ablaufdatum festlegen
		*check* --> überpfüfen
		*showphoto* --> Photo anzeigen
		*save* --> Änderungen speichen und exit
		*quit* --> exit ohne Änderungen zu speichern

--encrypt --> verschlüsseln

--recipent <Empfänger> --> einen <Empfänger> bestimmen

Beispiel:
**gpg --output revoke.asc --gen-revoke "Tux Gnu"** --> Ein Widerrufszertifikat für den User Tux Gnu erstelen

**gpg --output dissel.gpg --armor --export "Dissel" --> den öffentlichen Schlüssel von User dissel in eine Datei
							schreiben

**gpg --import Schlüssel.gpg** --> den Schlüssel importieren


Workflow:
(1) Bob erstellt mittels **gpg --gen-keys** einen öffentlichen und einen privaten Schlüssel
(2) Ausserdem erstellt Bob mittels **gpg --outfile revoke.asc --gen-revoke** ein Widerrufszertifikat
(3) Nun sendet Bob seinen öffentlichen Schlüssel an Alice
(4) Alice importiert mittels **gpg --import bob.gpg** bobs key
(5) Alice gibt sich mittels **gpg --list-keys** die KeyID anzigen und überprüft dann mittls 
(6) **gpg --fingerprint bob** den fingerprint von Bob
(7) Da sie Bob vertraut signiert sie den Schlüssel **gpg --sign-key Bob**
(8) Malusios hat die Signatur von Bob gestohlen und Bob will nun Alice darüber in Kenntnis setzen
(9) Bob importiert sein Widerufszertifikat **gpg --import revoke.asc und sendet den Widerrufenen Schlüssel an den Keyserver

__Dateien verschlüsseln mit gpg__
**gpg --output <Datei_enc.gpg --encrypt --recipent "Nutzer1 Nutzer2 ..." <Datei>**
--> Verschlüsseln der <Datei> so dass sie nur noch der Empfänger Nutzer1 bis NutzerN mit seinem Provate key lesen kann

__Dateien entschlüsseln mit gpg__
**gpg --output <Datei_unenc> --decrypt <Datei_eng.gpg** --> entschlüsseln der Datei

__Datei für sich selbst verschlüsseln__
**gpg --output <Datei_enc.gpg> --symetric <Datei_unenc> --> eine symmetrische Verschlüsselung auf eine Datei auf
							    sich selber bewirken
							--> dabei kann die entschlüsselten Datei von Stdout gelesen
							    und geschrieben werden 


__Dateien signieren und Signaturen überprüfen__
**gpg --output <Datei.sig> --sign <Datei>  --> signieren der <Datei> und die Ausgabe an <Datei.sig> geschrieben

**gpg --verify <Datei.sig> --> überprüfen der signierten Datei

**gpg --clearsign <Datei> --> Datei nur Signieren nicht in binärform ausgeben

**gpg --output <Datei_sig> --detach-sign** --> eine abgtrennte, von der Datei losgelöste Signatur erzeugen

**gpg --verify <Datei_sig> <Datei> --> Eine losgelöste Signatur überprüfen

__GnuPG Konfiguration__
\\ ~/.gnupg \\ --> Konfigurationsdateien von gpg
		\\ pubring.gpg \\ --> öffentlicher Schlüsselbund, die importiert oder erzeugt wurden
		\\ secring.gpg \\ --> privater Schlüsselbund
		\\ trusdb.gpg \\ --> Daten für das Eigentümervertrauen von Schlüssel
		\\ random_seed \\ --> interne Ausgangsdaten für die Zufallszahlengenerierung
		\\ gpg.conf \\ --> Diese Dattei enthält Voreinstllungen für gpg
	

===Apache konfigurieren und starten===
+ modularer Webserver 
+ Module DSO (Dynamic Shared Objects) werden zur laufzeit geladen wenn sie benötigt werden

__Installation__
Module für Multiprozessing:

$$apache2-prefork$$ (Sicherheit)
	--> spawning von mehreren Kindprozessen

$$apache2-worker$$ (Schnell)
	--> Threadbasiernd

$$apach2-docs$$
$$apache2-example-pages$$

__Starten und Verwalten des Apache__
**/etc/init.d/apache2** --> InitScript kann mit dem LSB konformen Parametern aufgerufen werden

**rcapache start|stop|reload|restart**

**apachectl** --> Apache ControlScript für nix Syteme, manchmal auch **apache2ctl**
	start --> Starten des Servers, falls noch nicht laufend, falls running Rückgabewarnung
	
	gracefull --> reload der Konfigruationsdateien, vorherige Operationen werden erst beendet
		  --> falls der Server nicht running als Status hatte, wird er jetzt gestartet
		  --> bekommt Signal SIGUSR1
		
	restart --> reload der Konfigurationsdatiene, vorherigen Operationen werden sofort beendet
                --> Falls Server nicht gestarte war, wird er gestartet
		--> bekommt Signal SIGHUP	
		
	configtest --> File-Syntax Test für Konfigurationsdateien
	
	fullstsatus --> Statusscript von mod_status


+ Webserver der über den httpd (Hypertext Transport Protocol Daemon) Webseiten anbietet

__Starten und überprüfen des Apachen__
**/etc/init.d/httpd start|stop|restart** || **service httpd start|stop|restart** 
--> starten|stoppen|neustarten des httpd Daemons

__Apache beim Booten starten__
$$SUSE$$ **chkconfig -a apache2**
$$Debian$$ **update-rc.d add apache2**

**chkconfig -a httpd** --> hinzufügen des Apache Webservers zu den Standardrunleveln

**chkconfig -l httpd** --> überprüfen ob der Apache läuft
		       --> >> httpd: unknown service --> der httpd ist nicht installiert
		       --> >> httpd: 0 off 1 off 2 off 3 off 4 off 5 off 6 off --> der httpd läuft nicht
		       --> >> httpd: 0 off 1 off 2 off 3 on 4 off  5 on  6 off --> der httpd läuft	

___HTTP__
+ Hyper Transfer Protocol
+ Seit version 1.1 KeepAlive um Verbindungen als Stream zu senden
Request: Bitte eines Clients um die Übersendung eines Dokuments oder einer Datei
	 <Methode>:<URI> HTTP/<Version>
		OPTIONS --> Abfrage von Resourcenn und Kommunikationsparameter
		GET --> abholen der durch URI gekennzeichneten Resource
		HEAD --> abholen der durch URI gekennzeichneten Metainfornmationen
		POST -->  Informationen in der Anfrage an die URI Resource weitergeben
		PUT --> Bitte um Speicherung der Informationen in der an der URI Resoruce bezeichneten Stelle
		DELETE --> Bitte um löschen der URI Resource
		TRACE --> Unmittelbares zurückschicken des Request
		CONNECT --> Aufbauen einer Verbindung ohne das Resourcen breitgerstellt werden

Response: Server beantowrtet die Anfrage 
	HTTP/<Version> <Status> <Antworttext>
			1xy --> Informationen 
			2xy --> Erfolg
			3xy --> Umleitung
			4xy --> Client Fehler
			5xy  --> Server Fehler


ErrorDocument Direktiven können in der .htaccess Datei definiert werden

__Bearbeitung von Anfragen__
post-read: Erste Phase nach analyse der Header Dateien
 |	  
 V
URL translation: Übersetzung der URL Anfrage in Dateinamen auf dem Server
 |
 V
Header Parsing: Einlesen der Header und der bereitstellend er <Directory> Abschnitte
 |
 V
Access Control: IP basierte Zugriffsvorschriften werden angewandt
 |
 V
Authentication: Nutzerbasierte Zuriffsvorschriften wereden angewandt
 |
 V
MIME type checking: Überprüfung des MIME Type und bestimmter Attribute
 |
 V
fix-up:	Letzen Änderungen vor der Antwort
 |
 V
content generation: erzeugen der HTTP Antwort
 |
 V
Request Logging: Eintragen von Loginformationen in das Protokoll 
(mod_log_forensic loggt vor dem ersten post-read und nach dem letzten Request logging)

__Apache Module in er Übersicht__

**httpd -l|grep mod.so.c** --> überprüfen ob Apache mit Modul Support gebaut wurden

http://modules.apache.org [liste von bekannten Modulen]

(mod_so) --> dynamisches Laden zur Laufzeit

(mod_setenvif) --> Setzen interner Variablen auf Basis von Request Matching

(mod_env) --> Kontorlle von Apache Server Variablen für CGI Scripten

(mod_unique_id) --> Anbieten von Umgebungsvariablen mit eindeutiger ID für jeden Request

(mod_alias) --> Ummappen von ServerVerzeichnissen unterhalb des / zu URI Verzeichnissen innerhalb der DocumentRoot

(mod_rewrite) --> Regelbasiertes Umeschreiben von URLs
	      --> basierend auf regular Expressions

(mod_userdir) --> Zugänglich machen von persönlichen Verezeichnissen für veschiedenen Benutzern unter \\ ~/public_html \\

(mod_spelling) --> korigieren von einfachen Tippfehlern in URLs

(mod_access) --> einschränken des Zugriffs von Resourcen, Mandatory Access Control (MAC) 
	     --> IP , Rechnerbasiert

(mod_auth_anon) --> erlaubt es Seiten wie anonymes ftp zu behandeln

(mod_mime), (mod_mime_magic) --> zuordnen von Dateitypen 

(mod_dir) --> bereitstellend er Datei index.html

(mod_index) --> auflsitend der Verzeichnisinhalte

(mod_status), (mod_info) --> Überwachen des Zustands des Servers

(mod_cgi), (mod_actions) --> Ausführung von CGIU Scripte

(mod_include) --> Auslieferung von dynamischen Websiten
	      --> Websiten Elemente können aufgrund von Clientanweisungen ersetzt und ergänzt werden

(mod_imap) --> auaswerten von anklickbaren Bildern

(mod_proxy) --> erlaubt Proxyfunktionalittä 


__Konfiguration des Apachen__
\\ httpd.conf \\ --> meistens unter /etc/
		 --> Konfigurationseinstellungen für das http Protokoll 
		 --> Konfigurationseinstellungen für den Betrieb des Servers
		 --> wird zuerst vom Apache verarbeitet

\\srm.conf \\ --> Server Resource Map 
	      --> Eigenschaften die bei der Auslieferung einer bestimmten Website beachtet werden
	      --> wichtig für apache 1.3 
	      --> meist unter /etc

\\ access.conf \\ --> Verwaltung von Zugriffsrechten
		  --> meist unter /etc

\\ ssl.conf \\ --> Konfiguration für SSL Direktiven

\\ .htaccess \\ --> zusätzliche Beschränkungen und Authentifizierungsdirektiven
		--> zusätzlich muss als Directive entsprechend AllowOverride angegeben werden

Direktiven:
DirectiveName	Wert [Wert]

1) Programmeinstellung (global environment) 
--> Einstellungen die den Daemon des Hauptservers betreffen

2) VirtualHostDirektiven (VirtualHost) 
--> Einstellungen die nur für Virtuelle Hosts zulässig sind

3) DirectoryDirektiven (Directory Directives)
--> Einstellungen die für Webspacecontainer oder Verzeichnisse gelten
	     
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
###Server Umgebung

##Grundkonfiguration
ServerType	standalone|inetd	#FEstlegen wie Apache gestartet werden soll

ServerRoot	   PATH			#Verzeichnis in dem der Server installiert ist
					#enthält die Konfigationsverzeichniss und Logfiles

TimeOut		     SECONDS(INT)	#Zeitspanne für GET Anfrage
					#Zeitspanne zwischen Empfangen eines TCP Paktes und einer POST|PUT Anfrage
					#Zeitspanne für ACKS bei der Übermittlung von Paketen

KeepAlive	    On|Off		#mehrere Verbindungen über den gleichen TCP Strom senden
					#empfohlen bei Bildern oder mehreren kleineren Objekten

MaxKeepAliveRequest INT			#Anzahl der Abfragen por Verbindung begrenzen
					#Ist 0 gestzt sind unbegrenzt viele Anfragen erlaubt

KeepAliveTimeout    SECONDS(INT)	#Zeit bevor die Verbindung geschlossen wird

Listen		    PORT(INT)		#Port auf dem der Server auf Verbindungen lauschen soll

LoadModule	    PATH(.so)		#Ein Modul laden $$SUSE$$  \\ /usr/lib/apache \\

LoadFile	    PATH(.so)		#Zusätzliche Bibliotheken die von Modulen geladne werden
					#muss vor dem Modul geladen werden, da das zuladende Modul von diesen
					#abhängt

PidFile		   PATH(.pid) 		#Spezifizierung wo das Server PID File liegen soll

User		   STRING(User)		#Der Nutzer mit dessen Rechten der Apache laufen soll

Group		   STRING(Group)	#Die Gruppe mit dessen Rechten der Apache laufen soll

			
##Konfigurattion des Hauptservers
ServerAdmin	  STRING(Mail)		#Adresse unter der der Administrator bei Fragen erreicht werden kann

ServerName	  STRING:INT(FQDN:Port)	#Rechnername und Port den der Server dazu verwendet sich selbst zu
					#identifizieren

UseCanonicalName On|Off|DNS		#Selbsrefernzierende URL und Port von ServerName bei On
					#Selbstreferneziernednen URL vom Client bei Off
					Selbstrefernzeirende URL via DNS

ServerTokens	Major|Minor|Min|Prod|OS|Full	#Responds Header der an den Client zurückgesendet wird
						#Prod Apache
						#Major Apache\2
						#Minor  Apache\2.2
						#Min	Apache\2.2.3
						#OS	Apache\2.2.3(SuSE Linux)
						#Full	Apachhe\2.2.3(SuSE Linux) PHP(5.3.3)


ServerSignature	On|Off|EMail		#Signatur des Servers bei servvereigenen Dokumentenn
					#Off unterdrückt Signatur
					#On Signatur anzeigen
					#EMail mailto ServerAdmin

DocumentRoot	PATH			#Verzeichnis des Hauptdokumentenbaums auf dem Server

DirectoryIndex	index.html /index.php	#Anweisung für die Datei die angeziegt wird wenn die URL angegebn wurde

DirectorySlash	On|Off			#Anweisung des Servers soll führende / beachten |nicht beachten

##Verzeichnis Konfiguration
Options		[+|-] All 		#Alle Optionen ausser Multiviews
		[+|-] ExecCGI		#erlauben der Ausführung von CGI Scripten
		[+|-] FollowSymlinks	#Der Server folgt symbolischen Links in diesem Verzeichnis
					#nicht in <Location> </Location>
		[+|-] Includes		#Includes sind erlaubt
		[+|-] IncludesNOEXEC	#Includes sind erlaubt CGI jedoch nicht
		[+|-] Indexes		#Befindet sich in im Verzeichnis keine DirectoryIndex Datei wird der
					#Verzeichnisbaum aufgelistet

		[+|-] SymLinksOwnerMatch #Server folgt nur symbolsichen Links die dem gleichen Nutzer gehören				
AllowOverride	All|None		#erlaube das Überschreiben durch .htaccess Dateien 

Order		allow,deny|deny,allow	#Reihenfolge der Allow,Deny Direktiven festlegen
					#allow,deny --> Allow vor Deny auswerten und standardmäßig Zugang verweigern
					#deny,allow --> Deny vor Allow auswerten und standardmäßig Zugang gewähren						
Allow		from [all|host]		#Welcher Host darf auf eine Resource zugreifen

Deny		form [all|host]		#Welcher Host darf auf eine Resource nicht zugreifen

##Weiterleitung und Indexes
(mod_alias)
Alias	URL-PATH Server-PATH		#Eine Resource auf den Server außerhalb der DocumentRoot definieren

AliasMatch	regex	Server-PATH	#Eine Reguläre Expression auf den Pfad zu einem Server mappen

Redirect	[301|302|303|410] URL-PATH URL	#Eine veraltete URL umleiten auf eine neue URL
						#Redirect hat immer Vorrang gegenüber anderen Umleitungsdirektiven
						#301=permanent
						#302=temp
						#303=seeother
						#410=gone
		/blah http://www.example.de/blubb/

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

__Authentifizierung__
+ (mod_authz_host) (mod_access)
+ RFC 2617

mod_auth_basic --> Stellt Authentifizierung zur Verfügung

mod_auth_digest --> Stellt Nutzerauthentifizierung durch MD5 Summe zur Verfügung
                --> Sichere Variante zu mod_auth_basic

mod_authn_file	--> Nutzer Authentifizierung durch eine TextDatei
                --> hängt ab von mod_auth_basic oder mod_auth_digest

mod_authn_dbm	--> Nutzer Authentifizierung durch eine DdmDatei
		--> hängt ab von mod_auth_basic oder mod_auth_digest

mod_authnz_ldap --> Nutzer Authentifizierung durch ldap Verzeichnis
		--> hängt ab von moth_auth_basic oder mod_auth_digest

mod_authn_dbd   --> Nutzer Authentifizierung durch eine SQL Datenbank
		--> höngt ab von mod_auth_dbd

**htpasswd -c <Pfad> [-n] -m|-d|-p|-s [-b <Pass>] User** --> erstellen und Verwalten von Passwortdateien
-c <Pfad> --> Erstellen (Create) von Passwortdatei in <Pfad>
-n --> Datei nicht verändern, Ausgabe erfolgt auf Stdout
-m --> nutze MD5
-d --> nutze Crypt
-p --> keine Verschlüsselung Plaintext
-s --> Nutze Sha
-b --> Lies Passwort von der Kommando zeile
-D --> löschen des Angegeben Nutzers

**htdigest [-c] Realm Benutzername** --> erstellen einer verschlüsselten Passwortdatei
				     --> es wird eine Datei mit den Einträgen User:Realm:MD5-Hash erzeugt	
-c erstellen 

**dbmanage [Codierung] Dateiname add|adduser|check|delete|update Username [Passwort [Gruppe] [Kommentar]]** 
**dbamange Dateiname view [Username]**
**dbamanege Dateiname import**	   --> Verwalten und erstellen von Nutzer Dbm Authentifizierungs Dateien
Dateinamen: Name der Basisdatei
Username: Der Benutzer auf den sich ein Befehl bezieht
Passowrt: bereits vrehschlpssel Angabe von - fragt nach dem Passwort
Gruppe:	Gruppen denne der Benutzer zugehörig sein kann 
Codierung: -d crypt 
	   -m md5
	   -s sha11
           -p plain text

add --> Neuer Eintrag für den Angegebenen Benutzer

adduser --> füge Nutzer hinzu

check --> Überprüfung

delete --> löschen eines Benutzers

import --> Benutzername und Password von Stdout lesen

update --> Ändern der Daten für existirernde Benuzer

view --> Anzeigen

**htdbm Datei Benutzername Passwort** --> Verwalten und Passwortdatenbank Dateien
-b --> Passwort von der Kommandzeile StdIN lesen 
-c --> erstellen einer Passwortdatei
-n --> Anzeigen auf Stdout
-m --> md5
-d --> crypt
-s --> sha1
-p --> palin Text
-T Type --> Datenbanktyp festlegen (SDBM|GDBM|DB|default)
-t Kommentar festlegen
-v Verifizieren von Username und Passwort
-x Nutzer löschen x-en

Workfow Authentifizierung einrichten:
(1) Benutzer und Passwort einrichten mithilfe der Tools **htpaswd**|**dbmanage**|htdbm
(2) erstellen eines <Locaction /Secrect> ... </Location> Containers für das Verzeichnis
+++++++++++++++++++++++++++++
<Location /Secret>
	AuthType 		Basic
	AuthBasicProvider 	File
	AuthName		"For your eyes only"
	AuthUserFile		/usr/local/apache2/misc/.htpasswd
	Require			user htuser
</Location>
+++++++++++++++++++++++++++++

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
## Einfach Authentifizierung
AuthName		STRING 		#Name des Autorisierungsberiech der durch Realm festgelgt wurde
		
AuthType		Basic|Digest 	#Art der Benutzerauthentifizierung
					#benötigt die Direktiven AuthName Require und AuthUser|GroupFile

AuthBasicProvider	file|dbm|dbd|ldap  #Wie findet Benutzerauthentifizierung statt

AuthUserFile		PFAD		#Wo befindet sich die entsprechende Datei zur Authentifizierung
AuthGroupFile		PFAD		

Require			User,User2,..	#Welche Nutzer dürfen auf eine Resource zugreifen

Satisfy			Any|All		#Steuerng des Nutzerzugriffs, eine Direktive stimmt|alle Direktiven stimmen

##Digest Authentifizierung
AuthDigestProvider	file|dbm|dbd|ldap	#Wie findet Benutzerauthentifizierung statt

AuthDigestAlgorithm	MD5|MD5-sess	#Algorithmus für die Berechnung der Chanllenge und Response Hashes

AuthDigestDomain	URI		#Angabe einer URI die sich im selben ProtectionSpace befindet

AuthDigestNonceLifetime	Sekunden(INT)	#Dauer für die eine Authentifizierung valide ist

AuthDigestShemSize	Size(INT)	#Allocierter Speicher der den Clients zur Verfügung steht

AuthDigestQOP		none|auth|auth-int	#Art der Authentifizierung 
						#none nach RFC 2069
						#auth Username Passwort
						#auth-int Username Passwort und Hash

##Dbm Authentifizierung
AuthDBMUserFile		PATH		#Pfad zur Datenbankdatei
					#Stellen sie sicher dass sich dieser ausserhalb von DocumentRoot befindet

AuthDBMType		default|SDBM|GDBM|DB	#Typ der Datenbankdatei
		
AuthDBMGroupFile		
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

__Kontrolle des Dämonen Schwarms__
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
<IfModule prefork.c>
StartServers #Anzahl der Prozesse im Schwarm

MinSpareServers #Anzahl der freien Prozesse die immer laufen Sollen

MaxSpareServers #Anzahl der freien Prozesse die höchstens laufen sollen

ServerLimit #Maimale Anzahl der Server Prozesse die gestartet werden können

MaxClients #Maximale Anzahl der Request

MaxClientsPerChild #Maximale Anzahl Request pro Server Prozess
</IfModule>

<IfModule worker.c>
StartServers #Anzahl der Prozesse im Schwarm

MinSpareThreads #Anzahl der freien Threads die immer laufen sollen

MaxSpareThreads #Anzahl der freien Threads die höchstens laufen sollen

ThreadLimit	#Maximale Anzahl der Threads die gestartet werden können

MaxClient 	#Maximale Anzahl der Request

ThreadsPerChild #Threads pro Clients die offen gehalten werden werden

MaxClientsPerChild	#Maximale Anzahl Request pro Server Prozess
</IfModule>
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

__Verezichnis & Dateidirektiven__
+++++++++++++++++++++++
<Directory Pfad>
...
</Directory>
++++++++++++++++++++++
--> Container für Direktiven, die auf ein Verzeichnis angewendet werden sollen

++++++++++++++++++++++
<Location Dokument>
...
</Location>
++++++++++++++++++++++
--> Container für Direktiven, die auf eine angefragte URL verweisen

++++++++++++++++++++++
<Files Dateiname>
...
</Files>
--> Container für Direktiven die auf eine oder mehrere Dateien angwandt werden soll
--> Wildcards können verwendet werden

__Persönliche Websiten des Benuzters__
+ unter ~/$USER/public_html kann jeder Nutzer seine eigene Webpräzens definieren
+ diese ist dann unter FQDN~User erreichbar

+++++++++++++++++++++++++++++++++++++++++
UserDir	public_html|disabled|enabled Nutzer1... 
++++++++++++++++++++++++++++++++++++++++
--> Direktive für das UserDir 

__Gesicherte Verbindung mit SSL/TLS__
SSL Secure Socket Layer Port:443 https
TLS Transpoer Layer Security


SSL Handshake:
(1) Client stellt Verbindung zum Server her und schickt daberi eine Lste der cipher suites die unterstützt werden
    Cipyhersuite=schlüsselaustauschmethode,Kryptosystem,kryptografischen Hashfunktion

(2) Server wählt stärkste Cipher Suite aus und teilt dem Client die Auswahl mit

(3) Senden des Zertifikats an den Client.

(4) Client verschöüsselt mit Zufällszahl des öffentlichen Schlüssels des Servers und schickt diese dann dem Server zurück

(5) Server entschlüsselt die Zufallszahl mit seinem privaten Schlüssel

(6) Beide Seiten verwenden nun die Schlüssel und die Kommunikation wird nur noch verschlüsselt übertragen

Symmetrische Verschlüsselung: + Ver- und Entschlüsselung wird derselbe Key verwendet

Asyymetrische Verschlüsselung: + Public und Private Key werden verwendet
			       + Verschlüsselung des Senders mit dem PublicKey des Empfängers
			       + Entschlüsselung beim Empfänger mit dessen Private Key

Einwegverschlüsselung: + Dechefrieung nicht vorgesehen
		       + Vergelich von Hashwerden

SSL/TLS bietet
		Identitätsgarantie
		--> Gewährleistung dass Informationen von einer bestimmten Person stammen
		--> wird durch eine CA verifiziert und bestätigt

		Integritätsprüfung
		--> durch (mod_ssl) wird sichergestellt das der Client genau das erhält was er angforder hat
		--> MD5 Summe

		Verschlüsselung
		--> Client Server verwenden einen SessionKey mit denen die Daten verschlüsselt werden
		--> Key ist nur für die Dauer einer Session gülitg

**openssl [Länge]** --> Programmsuite zum erstellen und verwalten von SSL Zertifikaten und Schlüsseln

**openssl genrsa** --> Programm zum erstellen eines RSA Private Keys
-des3 --> Verschlüsserlung verwenden
-out <Datei> --> Schlüsselname/Datei 

**openssl req** --> Programm zum Abfragen und Erstellen von openssl Zertifikaten
-new --> Neues Zertifikatrequest erstellen
-x509 N --> Selbstsigniertes Zertifikat mit x509 mit N Tagen Gültigkeitsdauer
-key <Datei> --> privaten Schlüssel <Datei> angeben
--newkey   rsa:N |dsa:<Datei> --> erstelle einen neuen Zertifikatrequest und ein neuen Key
-out <Datei> --> Zertifikat/Datei die erstellt wird
-in <Datei>  --> Datei von der ein neuer Request gelesen werden soll. Nur falls -new|-newkey nicht als Option gebraucht wurde
-text --> Ausgabe des Zertifikats in Textform
-config <Datei> --> Alternative Konfigurationsdatei angeben


X.509 Zertifikate:
Versionsnummer - Seriennummer (Benötigt für das Widerrufen eines Certs) - Hausageber (CA) - Signaturalgorithmus - Gültigkeitzeitraum
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Certificate:
	Data:
		Version: 3 (0x2) 							<-- Versionsnummer
		Serial Number: 1(0x1)							<-- Seriennummer
		Signature Algorithm: md5WithRSAEncryption				<-- Signaturalgorithmus
		Issuer: CN=Test-CA L=Berlin C=DE/emailAdres=ca@example.com, 		<--Herausgeber
			0=Zertifizierungstelle
		Validity								<-- Gültigkeitszeitraum
			Not Before: Oct 27 14:36:58 2003 GMT	
			Not After : Oct 26 14:36:58 2005 GMT
		Subject: CN=www.example.com L=Berlin					<-- Zu zertifizierender Name
			C=DE/emailAdress=webmaster@example.com 0=BIT GmbH;
			OU=Web-Server
		Subject Public Key Info:
			Public Key Algorithm: rsaEncryption 
			RSA Public Key: (1024 bit)					<-- ZU zertifizierender Schlüssel
				Modules: (1024 bit)
					00:d2:d1:a1:6b:22:4f:05:ba:04:5f:ba:f8:da:e0:
					87:17:33:e0:7e:c6:54:b7:f3
				Exponent: 65537 (0x10001)
			X503v3 extension:
				X509v3 Basic Constraints:
				CA: FALSE
		Signature Algorithm: md5WithEncryption 					<-- Signatur
		69:c4:fa:fb:85:6b:b4:5d:cd:da:e1:c1:51:10:cc:1c:09...
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\\ /etc/openssl/openssl.cnf \\
Aufbau einer Openssl.cnf Datei:
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
[Abschnitt]
Direktive

[ca]
default_ca=myCA

[myCA]
dir	= 	/usr/local/openssl/myCA 	#Variable dir 
certificate = 	$dir/cacert.pem 	#Wo befindet sich das zertifikat der zertifizierungsstelle
database =	$dir/index.txt 		#Ort der Indexdatenbank
new_certs_dir = $dir/certs		#Ort für ausgestellte Zertifikate
private_key =	$dir/private/cakey.pem  #Ort des Privaten Schlüssels der Zertifizierungsstelle
serial = 	$dir/serial		#Seriennummer

default_crl_days = 7 	#Veröffentlichungszeitraum
default_days = 730	#Gültigkeitsdauer	
default_md = md5	#Algorithmus für Hash

policy = myCA_policy
#in welchem Abschnitt soll nach Direktiven für Extensions gesucht werden
x509_extensions = certificate_extensions

[myCA_policy]
			#mögliche Werte sind match | supplied | optional
			#match:  Wert des Feldes muss mit dem der Zertifizierungsstelle übereinstimmen
			#supplied: Felder müssen im CSR vorhanden sein
			#optional: Felder können vorhanden sein und müssen nicht übereinstimmen
commonName		= supplied
localityName		= supplied
countryName		= supplied
emailAdress		= supplied
organizationName	= supplied
organizationalUnitName	= supplied

[certificate_extensions]
bascConstraints = CA:false #CA Zertifikate können nicht verwendet werden um weitere Zertifikate zu erstellen

[req]
default_bits		= 2048 #länge des Schlüssles
default_keyfile		= /usr/local/openssl/myCA/private/myCAkey.pem #Standardkey
default_md		= md5 #Hash
prompt			= no #Soll nochmal gefragt werden
distinguished_name	= myCA_dn 
x509_extensions		= myCA_extensions

[myCA_dn]
commonName		= Test-CA
localityName		= Berlin
countryName		= DE
emailAdress		= myCA@example.com
organisationName	= MyCompanyCA

[myCA_extensions]
basicConstraints	= CA:true
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

**openssl x509** --> Programm zum Anzeigen und Signieren von Zertifikaten
-in <Datei> --> Angabe eines Zertifikats das Signiert werden soll
-text --> IN Textform ausgeben
-noout --> Verhindert die Ausgabe der verschlüsselten Version
-req --> Zertifikat Request wird erwartet
-md2|-md5|-sha1|-mdc2 --> Nutze diesen Diget
-CA --> Angabe des CA Zertifikats dass für die Signierung verwendet werden soll
-CAkey --> Angabe des CA Private Key, falls es sich um ein verschlüsseltes CA Zertifikat handelt
-CAcreateserial --> erstelle eine CA Seriennummer
-days N --> Zertifikatsgültigkeitsdauer festlegen


Workflow erstellen einer eigenen Zertigfizierungsstelle:
(1) Erstellen der Verzeichnbisse für die Zertifikate **mkdir -p /usr/local/share/myCA/{private,certs}**
(2) Nutzer und Gruppenrechte anpassen **chown -R USER:users /usr/local/share/myCA && chmod 700 /usr/local/share/myCA**
(3) Erstellen der Serial Datei **echo 01 > /usr/local/share/myCA/serial**
(4) Analgen der Zertifikatsindexdatei **touch /usr/local/share/myCA/index.txt
(5) Erstellen und Bearbeiten der Konfigurationsdatei openssl.cnf
(6) Erstellen eines Schlüssels: **openssl req -x509 -days 1825 -newkey -rsa:2048 -out cacert.pem
(7) Anschauen des Zertifikats: **openssl x509 -in cacert.pem -text -noout**

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
##SSL Direktiven

SSLPassPhraseDialog	buildin|exec:PATH	#legt das Programm fest, welches verwendet werden sol wenn der apache beim 
						#Starten nach der Passphrase fragt

SSLMutex		none|file:PATH|sem	#serialisieren von SSL Zugriffsabfolgen, damit nicht zwei SSL Prozesse auf 
						#diese gleiche Funktion
						#zugreifen könnnen. Der Wert none ist ist nicht zu empfehelen

SSLRandomSeed		buildin|none|file:PATH|exec:PATH|edg:PATH	#Konfiguration des Randomisierers
			Kontext Quelle Bytes

SSLSessionCache		none|dbm:PATH|shm:PATH [size(INT)]		#Configurieren des Session Caches

SSLSessionCacheTimeout	Sekunden(INT)		#Dauer für die ein SessionCache gültig ist	
		
SSLEngine		On|Off			#SSL/TLS Protooll Engine aktivieren
						#muss in Virtuellen Hosts spezifiziert werden

SSLProtocol		all|[+-]SSLv2|SSLv3|TLSv1 #Welches SSL Protokoll wird genutzt

SSLCipherSuite		all|:cyperspec:...	#Spezifikation der Openssl CipherSuite
						#siehe www.modssl.org

SSLCertificateFile	none|PATH(.crt)		#Pfad zur ServerZertifikats-Datei

SSLCertificateKeyFile	none|PATH(.key)		#Pfad zur SSLZertifikats-Schlüsseldatei

SSLCertificateChainFile	none|PATH(ca.crt)	#Pfad zur CA-Verifizierungs-Zerifikat-Datei die von den Servern genutzt wird

SSLCACertificatePath	none|PATH(ssl.crt)	#Pfad zum CA Verifizierungstelle, die von den Clients genutzt wird, muss ein 
						#gültiges Verzeichnis sein

SSLCACertificateFile	none|PATH(.crt)		#Pfad zur CA Verifizierngstelle, die von den Clients genutzt wird, muss eine 						     #gültige Datei sein

SSLCARevocationPath	none|PATH(ssl.crl)	#Pfad zur CA Widerufungsstelle, die von den Clients genutzt wird, muss ein gü						     #ltiges Verzeichnis sein

SSLCARevocationFile	none|PATH(.crl)		#Pfad zur CA Widerufungsstelle, die von den Clients genutzt wird, muss ein 
						#gültiges Verzeichnis
		
SSLVerifyClient		none|optional|require	#Client Certifikat Zerfikations Level 
						#none Client Zertifikat ist nicht nötig
						#optional Client Zertifikat wird gelesen falls vorhanden
						#require Client muss ein Zertifikat anbieten

SSLVerifyDepth		0-10			#Die tiefe der Verifikation, bevor SSL entscheidet dass das Zertifikat 
						#ungülig
						#0 Selbst signierte Zertifikate werden akzeptiertr

SSLLog			none|PATH		#Dateipfad für Logfiles der SSL-Logfiles Engine

SSLLogLevel		none|error|warn|info|trace|debug #Loglevel für die SSL Logs

SSLOptions		StdEnvVars	#Erstelle die StandardvariblenUmgebung für SSL CGI/SSI
					#Sehr Performanceintensiv

			CompatEnvVars	#Zusätzliche SSL Variablen werden erstellt um Abwärtskompatibel zu sein

			ExportCertData	#Die Zertifikationseinstellung werden an Umgebungsvariablen abgegeben
			
SSLRequireSSL		>Empyte<	#Diese Direktve verbietet den Zugriff, falls ein Client keine SSL Verbingund 
					#nutzt

SSLRequire		none|log ausdr.	#Spezifiziert einen logischen Ausdruck der wahr sein muss, damit der Zugriff
					#gewährt ist. Dieser Ausdruck nutzt die BNF Notation
	
expr     ::= "true" | "false"
           | "!" expr
           | expr "&&" expr
           | expr "||" expr
           | "(" expr ")"
           | comp

comp     ::= word "==" word | word "eq" word
           | word "!=" word | word "ne" word
           | word "<"  word | word "lt" word
           | word "<=" word | word "le" word
           | word ">"  word | word "gt" word
           | word ">=" word | word "ge" word
           | word "in" "{" wordlist "}"
           | word "=~" regex
           | word "!~" regex

wordlist ::= word
           | wordlist "," word

word     ::= digit
           | cstring
           | variable
           | function

digit    ::= [0-9]+
cstring  ::= "..."
variable ::= "%{" varname "}"
function ::= funcname "(" funcargs ")"
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Workflow SSL Verbindung einreichten (Beispiel):
(1) Setup einer eigenen CA für den internen Gebrauch (Intranet)  
	a) Erstellen eines privaten CA Schlüssels **openssl genrsa -des3 -out my-ca.key 2048**
	b) Erstellen eines CA Zertifikats **openssl req -new -x509 3650 -key my-ca,key -out my-ca.crt**

(2) Schlüssel und Zertifikat für den Server erstellen und entsprechend mit einem eigenen Zertifikat absichern
	a) Erstellen des private Server Schlüssels **openssl genrsa -des3 -out Server.key 1024
	b) Erstellen des Zeritfikat für den Servers **openssel -req -new -key Server.key -out Server.csr**
	c) Signieren des Zertifkats **openssl x509 -req -in Server.csr -out Server.crt -sha1 -CA my-ca.crt 
				      -CAkey my-ca.key -CAcreateserial -days 3650**
	!!Dabei ist Server der FQDN unter der Apache später erreichbar ist!!

(3) Kopieren von .csr, crt .key Datei in die entsprechenden Verzeichniss \\ /etc/apache2/{ssl.csr, ssl.crt, ssh.key} \\	

(4) Es empfiehlt sich auf dem Server gesicherte Verbindungen von unsicheren Verbindungen zu trennen. Deshalb wird 
    empfohlen, folgendes Verzeichnis im Stammverzeichnis des Servers anzulegen: \\ /srv/www/SSL/ \\
												    \\ Passneeded \\ 	
												    \\ Certneeded \\ 	
												    \\ PassAndCert \\

(5) Als nächstes sollte der Apache entsprechend konfiguriert werden, dass er SSL Verbindung annimmt
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
DocumentRoot		"/srv/www/SSL"
SSLEngine		On
SSLProtocol		all -SSLv2
SSLCertifiacateFile	"/etc/apache2/ssl.crt/Server.crt"
SSLCertificateKeyFile	"/etc/apache2/ssl.key/Server.key"
SSLCertificateChainFile	"/etc/apache2/ssl.crt/my-ca.crt"
SSLCACertificateFile	"/etc/apache2/ssl.crt/my-ca.crt"

<Directory "/srv/www/SSL">
	Options		-Indexes
	AllowOveride	None
	Order		allow,deny
	Allow from all
</Directory>
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++
(6) Username und Passwortauthentifizierung mit htpasswd einrichten **htpwasswd -c -m /etc/apache2/.htpasswd**
								   **chown www:wwrun /etc/apache2/.htpasswd**

(7) Das Verzeichnis Passneeded auf den Server konfigurieren
+++++++++++++++++++++++++++++++++++++++++++++++++++++
<Directory "Passneeded">
	AuthType		Basic
	AuthBasicPorivder	file
	AuthName		"Username and Password"
	AuthUserFile		".httpasswd"
	Require			valid-user
</Directory>
+++++++++++++++++++++++++++++++++++++++++++++++++++++

!!!SSL kann nicht mit Namensbasierten Virtuellen Hosts funktionieren!!!

$$SuSE$$ 
(1) Kopierren des Zertifikats nach \\ /etc/httpd/ssl.crt/server.crt \\
(2) Kopieren des privaten Schlüssels nach \\ /etc/httpd/ssl.key/server.key \\
(3) editiereen \\ /etc/sysconfig/apache \\ HTTPD_SEC_MOD_SSL=yes
(4) **SuSEconfig --module-apache**

__Logging_
\\ access_log \\ --> Logfile für die Zugriffe auf den Server

\\ error_log \\ --> Logfile für die Fehlermeldungen des Servers

_
(mod_log_forensic) --> Forensisches Loggen von Client Requests (Logging bevor oder nach Request) 
		   --> Im Logg Stehen 2 EInträge für jeden Request
		   --> es wird den Logfiles eine forensic-id für jeden Eintrag zugeordnet 	

(mod_dumpio)  --> Loggen von allen Ein und Ausgabe Strömen des Apache 
	      --> dumpen des Aus und Eingabeverhaltens
	      --> Data Logging wird direkt nach dem SSL Decoding (Eingangsstrom) und vor
		  dem SSL Encodeing (Ausgangsstrom)
	      --> aktiviert durch die DumpIOInput & DumpIOOutput Direktive 

(mod_logio)   --> hängt ab vom Modul mod_log_config 
	      --> Die Anzhal der Ein und Ausgabe Bytes pro Request
	      --> Das Zählen der Bytes findet vor der SSL Verschlüsselung statt
	           %I,%O können als zusätzliche Logging Variaben verwendet werden 		

(mod_log_config) --> Loggen von Clientrequests durch eigeness Logformat festlegen 
		 --> Loggs werden entweder in eine Datei oder an ein externes Porgramm weiter gegeben
		 --> Durch TransferLog, LogFormat oder CustomLog festgelegte Direktiven
		 --> dabei dürfen die Direktiven TransferLog und CustomLog mehrfach benutzt werden

Formate für das CustomLog:
%%	Prozentzeichen
%a	Remote IP Adresse
%A	Lokale IP Adresse
%B	Größe der Antwort in Bytes ohne HTTP Header
%b	Größe der Antwort in Bytes ohne HTTP Header in CLF format (- statt 0)
%{<Cookie>} C	Inhalt des Cookies die vom Server kommen	
%f	Dateiname	
%D	Die Zeit die es gedauert hat, diesem Request zu dienen (ACK;SYN; SYNACK;FIN)
%h	Der Name des Remote Hosts
%H	Das verwendete Request Protokoll
%k	Anzahl der KeepAlive Anfragen die genutzt wurde
%{Note} <Module>		Eine Notiz von <Modul>
%{Content} N			Der Contend der ersten N header Zeilen	
%P	Die PID des Kindes der den Request beantwortet hat
%tid P	Die Threadid beim Apache Worker
%r	Erste Zeile des Requests
%s	Status für Request die intern redirected wurden
%T	Zeit, die es gedauert den Request zu beantworten
%u	Der Remote User
%U	Die URL die angefragt wurde
%v	Name des Server |Canonical Name
%V	Der Name des Servers der mit UseCanonicalName festgelegt wurde

%O und %I sind zusätzliche Formate die Angeboten werden, falls mod_log_config geladen wurde
			 
(mod_usertrack) --> ClickStream Logging von User Optionen dabei werden Cookies genutzt
		--> CockieLog |CustomLog Direktive aktiviert 
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#mod_usertrack
CookieDomain	Domain		#kann im Kontext Server, VirtualHost, Directory, .htaccess
				#Domäne, zu der ein Cockie passt

CookieExpires	Seconds		#Setzen einer Gültigeitsdauer des Cookies dass von mod_user_track erzeugt wird

CookieName	Name		#Name des Cokies der von diesem Server asugeliefert wird
				#Standard ist Apache

CookieStyle	Netscape|Cookie|Cookie2|RFC2109|RFC2965	#Format des Cookie Header Feld

CookieTracking	On|Off		#Cookie Rückverfolgung aktivieren oder deaktiveren

#mod_dumpio
DumpIOInput	On|Off		#Dumpen aller Eingangsströme

DumpIOOutput	On|Off		#Dumpen aller Ausgangsströme

DumpIOLogLevel	(siehe LogLevel) #Wie detailliert soll geloggt werden

#mod_log_forensic
ForensicLog	DATEI|PIPE(.log)	#DateiNamen des Logfiles setzen
					#dabei wird dieser relativ zum Serverpfad angegben
					#wird Pipe verwendet,so wird | gefolgt vom Programm dass die Loggs verarbeiten soll

#mod_log_config
BufferedLogs	On|Off		#Logfiles werden im Arbeitsspeicher gehalten und gecached 
				#Sie werden zusammen auf die Festplatte geschrieben nicht nach jedem Request einzeln

CoookieLog	Datei(.log)	#Dateiname für das Mitloggen von Cookies

CustomLog	Datei|Pipe	#Standardlogifle oder wenn |Pipe angegeben wird durch |PATH_EXEC Programm was loggs
				#empfängt und verarbeitet, dieses beseitzt dann die UID des Server Prozesses

LogFormat	Format		#Festlegen des Formats, hier werden die Logging variablen % genutzt

TransferLog	Datei|Pipe	#wie CustomLog ohne festlegen des Formats wird das CustomLogFormat genutzt
				#"%h %l %u %t \"%r\" %>s %b"
				
LogLevel	emerg|alert|crit|error|warn|notice|info|debug	#Wie detailiert wird geloggt

ErrorLog	Dateiname(.log)|syslog[:facility] #Wo werden Fehler protokolliert			
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

__VirtualHosts__
+ mehere Hosts können auf einem Server laufen
+ Ein Rechner beinhaltet verschiedene Hosts und kann diese unter verschiedenen Namen oder IPs ausliefern

(mod_vhost_alias) --> erstellen von dynamisch verwalteten Virtual Hosts 
		  --> IP Adresse und / oder Header des Hosts werden für die Namensauflösung des Pfads bestimmt

 
(mod_mpm_itk) --> ermöglicht es jeden VHost unter seiner eigenen UID und /oder GID laufen zu lassen

a) IP-basiert
++++++++++++++++++++++++++
<VirtualHost 192.23.17.51>
	ServerName	www1.mynet.de
	ServerAdmin	webguy@mynet.de
	DocumentRoot	/srv/www1/htdocs
	ErrorLog	logs/www1.error.log
	CustomLog	logs/www1.access.log "%a %D"
</VirtualHost>
++++++++++++++++++++++++++
b) Namens-Basiert
++++++++++++++++++++++++++
NameVirtualHost	*:80

<VirtualHost *:80>
	ServerName	www.mynet.de
	ServerAdmin	webmaster@mynet.de
	DocumentRoot	/srv/www/htdocs
	ErrorLog	logs/error.log
	CustomLog	logs/access.log "%a %D"
</VirtualHost>
++++++++++++++++++++++++++
!! Um Namens und IP-basiertes virtuell Hosting gleichzeitig zu ermöglichen wird "NameVirtuellHost IP:Port" verwendent!!

c) Portbasiert
++++++++++++++++++++++++++
Listen 80
Listen 8000

#MainServer Port 80
#IntranetServer Port 8000
<VirtualHost *:8000>
	ServerName
	ServerAdmin
	DocumentRoot
	ErrorLog
	CustomLog
</VirtualHost>
++++++++++++++++++++++++++

Direktiven:
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
NameVirtualHost		Adresse[:Port]	#Adresse und Port unter der Server Anfragen für namensbasierte Virtulle Hosts
					#annimmt

ServerAlias		Hostname...	#Maherere Alternative Namen eines Hosts zur Verwendung bei Vhosting

ServerPath		URL		#Festlegen eines legacy URL Pfadenamen für den Host 

#mod_mpm-itk
AssignUserID		#UID [#GID] | User [Gruppe]	#festlegen der UID oder GID (Nutzer Gruppe) unter der Vhost
							#laufen soll
							#Wird UID oder GID verwendet muss diese durch # eingeleitet
							#werden

MaxClientsVHosts	INT		#Die maximale Anzahl der Client-Requests die von einem VHost beantwortet 
					#werden

NiceValue		INT(-20;19)	#Einen nice Wert für die Prozesse dieses VHosts festlegen

#mod_vhost 
VirtualDocumentRoot	PATH		#dynamische Angabe der DocumentRoot für Virtual Hosts
					#UseCanonicalName muss ausgeschaltet sein

VirtualDocumentRootIP	IP		#Verschiedene IPS für IP basierte VIrtualHosts definieren
					#Das folgende Beispiel definiert virtuelle Hosts für verschiedene IP-Adressen im 
					#Netzwerk 196.23.17.0/24; die Verzeichnisnamen sind /var/sites/ip1 bis /var/sites/ip254:
					#VirtualDocumentRootIP /var/sites/ip%4			

VirtualScriptAlias	PATH		#Wo werden Scripte (CGI etc.) abgelegt

VirtualScriptAliasIP	PATH		#Wo werden Scripte (CGI etc.) für IP-basierte Vhosts abgelegt

!!Tipp!! Die Direktive:
+++++++++++++++++++++++++++++++++++++++++++
<VirtualHost _default_:*>
	DocumentRoot	/www/default
	....
</VirtualHost>
+++++++++++++++++++++++++++++++++++++++++++
--> erlaubt e einen Virtuellen Server einzurichten für
    dem kein Virtueller Host zugeordnet ist.
--> Verhndern dass Anfragen nicht den Hauptserver erreichen

!!Achtung!! Namensbasierte VHosts können keine SSL Verschlüselung anbieten


__Benchmarks__
*ab* --> Tool um apache Benchmarks durchzuführen

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
EnableMMAP		Off|On		#Memory Mapping aktivieren | deaktivieren

EnableSendfile		On|Off		#direktes Senden einer Datei, dabei wird sendfile() verwendet ohne direktes lesen

MMapFile		PATH,FILES	#Eine Liste von Dateien, die bereits beim Starten des Servers in den RAM geladen werden

CacheFile		PATH,Files	#Eine Liste von Dateien, die bereits beim Starten des Servers in dessen Cahce geladen werden
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

__Sicherheit__
(mod_security)	--> Web Application Firewall Modul für Apache
		--> solte vor allem für Web Applikationen eingestzet werden
		--> unterstützt zusätzliches Logging und Sicherheitsfeatures
		--> Unterstützt Audiding

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
LimitInternalRecursion	INT		#bewahrt den Server vor Abstürzen falls dieser beim betreten von Verzeichnissen
					#oder Verzeichnissen in einer Endlosschleife bei Redirect wie er zum Bispiel von 
					#der Direktive Action verwendet wird
					#Standard ist 10
		
LimitRequestBody	INT		#Anazahl der Bytes die pro Request-Body erlaubt sind

LimnitRequestFields	INT		#Wird zur Laufzeit durch die Compile Option DEFAULT_LIMIT_REQUEST_FIELD gestetz
					#Maximale HTTP-Request-Header pro Request
					#100 ist ein sinnvoller Wert

LimitRequestFieldSize	INT		#Anzahl der Bytes die pro Request im Hader erlaubt sind
					#Standard 8190 

LimitRequestLine	INT		#Die Direktive LimitRequestLine erlaubt es dem Serveradministrator, die maximale 
					#Größe der HTTP-Anfragezeile auf einen Wert unterhalb der normalen, im Server 
					#einkompilierten Größe des Eingabepuffers zu verringern

LimitXMLRequestBody	INT		#Grenze für die maxmale Anzahl von Bytes des XML basierten Request Bodys
					

RLimitCPU		Sekunden|Max	#setzen einer weichen Resourcenbegrenzung für die CPU pro Prozess
					#Zusätzlich kann eine Maximalresourcenbegrenzung für den gesamten Server angegeben werden

RLimitCPU		Bytes|Max	#setzen einer weicher Resourcenbegrnzung für den verbrauchten Arbeitsspeicher pro Prozess
					#Zusätzlich kann eine Maximalresourcenbegrenzung für den gesamten Server angegeben werden

RLimitNPROC		INT|Max		#setzen einer Resourcenbegrenzung wieviele Prozesse gepawnt werden können
					#Zusätzlich kann eine Maximalresourcenbegrenzung für den gesamten Server angegeben werde

EnableExeptionHook	Off|On		#erlaubt es Module bei einem Prozess einzuhängen und nach Absturz noch Befehle auszuführen
					#sollte deaktiviert sein		
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

!!Tipp!! Zugriffe ausserhalb der DocumentRoot abweisen:
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
...
<Directory />
	Order		allow,deny
	Deny 		from all
	AllowOverride	None
</Directory>
...
<Directory /srw/www/htdocs/
	Order	deny,allow
	Allow	from all
</Directory>
...
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++		

!!Tipp!! ~root deaktivieren:
++++++++++++++++++++++++++++++++++++++++++++++++++++++++
...
UserDir	disabled root
...
++++++++++++++++++++++++++++++++++++++++++++++++++++++++

suEXEC --> ermöglicht es Scripte mit den Rechten eines anderen Benutzers auszuführen
       --> dokumentiert in apache_suexec 
	

===Proxy Server===
+ Proxies für verschiedene Protokolle: SMTP
				       HTTP
				       DNS

+ Filtern und Protokollieren von Verbindungen
+ Caching (Specihern von häufig gefragten Resourcen)
+ Anbieten von Webseiten aus dem Cache

__Squid__
+ cachender Proxy
+ http; ftp; gopher
+ erlaubt https über http zu tunneln
+ DNS caching 
+ negative caching, d.h. Objekte die schon einmal nicht erreichbar waren, werden auch in zukunft nicht erreichbar sein
+ Request Blocking Server

\\ /etc/squid/squid.conf \\ --> Konfigurationsdatei für den Squid Proxy Server
\\ /etc/squid/passwd \\ --> Passwortdatei für Proxyauthentifizierung 


\\ /var/cache/squid \\ --> Heimatverzeichnis des Proxis 
		       -->  sollte dem Benutzer squid und der Gruppe root oder squid gehören und 600 sein
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Direktiven
cache_access_log	PATH	#Pfad zum Logfile dass Zugriffe Protokolliert
cache_log		PATH	#Pfad zum Standardlogfile		
cache_store_log		PATH	#Pfad zum Logfile für den Storagemanager
cache_effective_user	User	#effektiver Nutzer unter dem Squid startet
cache_effective_group	Group	#effektive Gruppe unter der Squid startet

cache_dir		ufs PATH CACHESIZE(MB)	 AnzahlVerzeichnisse AnzahlUnterverzeichnisseInVerzeichnissen 
cache_dir	ufs /var/cache/squid 100 16 256 #Standardwert

cache_swap_low		%INT	#Ab %INT beginnt squid Objekte von Festplatte zu löschen
cache_swap_high		%INT	#Obere Grenze in % für den vorzuhaltenen Cache

cache_replacement_policy	policy
				lru #objekte die am wenigsten nachgefragt als erstes
				heap LRU 
				heap GDSF #kleine häufig nachgefragte Objekte behalten
				heap LFUDA #populäre Objekte im Cache behalten

cache_mem	#Die Größe des im Arbeitsspeicher forgehaltenen Platzes
memory_replacement_policy	#Wie cache_replacement_policy aber für cache_mem

cache_peer URL	parent|sibling	Port des entfernten	ICPPort auf dem der Proxy mit anderne Proxys kommuniziert 	Optionen
cache_peer	parent.example.com	parent	3128	3130	proxy-only				 

auth_param 	#Welche Paramter sollen für die Authentifizierung verwendet werden

http_port	[Rechner:]Port	#Port auf dem Squid lauschen soll
				#Standardport ist 3128 
http_port	localhost:8080	#Squid lauscht nur auf Port 8080 der loopbackadresse
				#darf mehrfach vergeben werden	

https_port	[Rechner:]Port	#Zusätzlicher Port für https, falls transparent proxy

dns_testnames

redirect_programm PFAD_zum_Programm	#Angabe eines Redirector rogramms		
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

__Squid steuern__

**squid**
-z --> initialiesren und neu einlesen des Caches
-N --> verhindert das squid einen eigenen Kindporzess startet
-d N --> debugging Level angeben \\ cache_log \\
-D --> die Direktive dns_testnames wird nicht behandelet
-k <Signal> --> ein Signal an squid senden
	reconfigure: SIGHUP
	rotate: rotireen der Logdateien
	shudown:SIGTERM, bestehende Verbindungen bearbeiten
	interrupt: SIGINT, bestehende Verbindungen sofort beenden
	kill: SIGKILL
	debug: debugging Informationen an | ausschalten
	check: überprüfen ob squid läuft
	parse: Überprüfen des Squids auf sytaktische Fehler
	

**squid -z** --> initialisieren der Cache verzeichnisse

**squid -N -d 1 -D** --> Testen des Proxies

**dnsserver** --> Domain Name Server lookup Teil von Squid

**clamaris < <Input_LOG> > <Ausgabe_LOG>** --> Tool um Logdateien aus squid logs zu erstellen
-a --> Vollstädniger Report
-F <Format> --> Format der Ausgabe (html, tex, txt)
 
__Squid Zugriffskontrolle__
+ Squid steuert seine Zugriffe durch Bedinugen und Regeln

+ Squid Bedingungen werden in Form von acl Direktiven in der \\ /etc/squid/squid.conf \\ beschrieben
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
acl <Name> <Typ> <Wert> ...

<Name> --> definiert den Namen einer Bedingung auf den Später verwiesen wird
       --> Namen müssen eindeutige Typen definieren 
       --> jeder Name definiert eine Relation von <Typ> auf <Wert>

Eine Bedingung trifft genau dann zu wenn <Typ> den Wert <Wert> annimmt

acl my_network	src	192.168.1.0/24 192.168.2.0/24
Der <Typ> src gibt die Quell IP-Adresse für Anfragen an
Der <Typ> dst gibt die Zieladresse des Servers an
Der <Typ> port definiert einen Zielport beim Server 
Der <Typ> proto definiert das verwendette Protokoll oder den Zugriff auf den Cache cache_object
Der <Typ> method verweist auf eine verwendete http methioode (GET,CONNECT, HEAD,...)
Der <Typ> url_regex|urlpath_regex Reguläre Ausdrücke die auf eine angeforderte URL passen

Der <Typ> time Wochentage(MTWHFAS) Zeitraum(HH:MM - HH:MM)
acl workinghours time MTWHF 8:00 - 17:00

Der <Typ url_regex kann benutzt werden um Sperr-Listen zu implementieren
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

+ Squid Regeln werden in Form von Akionen in der \\ /etc/squid/squid.conf \\ beschrieben
+ Die Aktionen werden nacheinander wie an einer Schnur (ChainRule) abgeareitet
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
<Aktion> allow|deny <Bedingung>
http_access allow our_networks #http_access steuert welche Netze|Clients hhtp Zugriff erhalten
http_access deny all

http_access #Regelt den HTTP Zugriff auf Web Resourcen

http_reply_access #Zugriff auf Server Antworten einschränken, Filterkriterien nach GET 

cache_dir <DIR> <MB size> <Anzahll Unterberzeichnisse> <Dateien> #Verwalten des Cache Verzeichnisses

cache #Zugriffs Steureung dessen was sich im Cache befinden darf und was nicht

redirector_access #Die URL der Anfrage wird durch die Redirector Schnittstelle von Squid geleitet

cache_peer_access #Anfrage wird an einen anderen Proxy umgeleitet
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

**squid -k reconfigure** --> neu einelesen der Konfigurationsdatei


===Ftp===
+ File Transfer Protocol 
+ Pure-FTPd, vsFTPd, WU-FTPD
+ benötigt immer eine Anmeldung (anonymous ist für Passwortfreie Anmeldung reserviert)
+ Kommunikation erfolgt auf zwei Ports 
					Port 21 --> Steuerungskanal, Befehle zum Steuern des Servers
						--> abgespeckte Form von Telnet
					
					Port 20 --> Übertragungport, Übertragung von Dateien



__Ftp Statusmeldungen__
1nn --> Positive ankündigende Antwort (Beginn der Dateenübertragung)

2nn --> Positive entgültige Antwort (Datei erfolgreich übermittelt)

3nn --> Positive zwischenzeitliche Antwort (User, Passwort erfolgreich)

4nn --> Negative vorübergehende Antwort (kein Plattenplatz mehr 452) 

5nn --> Negative dauerhafte Anwort (503 unbekannter Befehl)

n0n --> Systax Fehler (202 Kommando hier überflüssig)

n1n --> Informationen 

n2n --> Verbindung 

n3n --> Authentisierung und Accountzuweisung

n4n --> reserviert

n5n --> Dateisystem (527 Datei angelegt)


**ftp <ftp://Url>** --> clientseitiges Programm für den Zugriff auf ftp Resourcen
	open --> Öffnen einer Sitzzung
	close --> schließen einer ftp Sitzung	
	user --> angeben eines Nutzers für die Sitzung
	
	cd --> wechseln in das Verzeichnis auf dem Server
	lcd --> wechseln in das Verzeichnis auf dem Client
	pwd --> Anzeigen des aktuellen Arbeitsverzeichnis auf dem Server	
	lpwd --> Anzeigen des aktuellen Arbeitsverzeichnis auf dem lokalen Client
	mkdir --> Anlegen eines Verzeichnisses auf dem Server
	rmdir --> löschen eines Verzeichnisses auf dem Server
	chmod --> Ändern der Zugriffsrechte auf dem Server
 	delete --> löschen einer Datei auf dem Server
	rename --> umbennenen einer Datei

	get, mget --> kopierten einer| mehrer Dateien vom Server

	put, mput --> kopieren einer | mehreren auf den Server
	
	ascii|binary|system --> einschalten von Zeilenumbrüchen|als Binärdatei übertragen|systemtyp des Servers erfragen	

	passive --> Aktiven Modus deaktivieren oder aktivieren	

	page --> Anzeigen einer Seite 
	
	quit --> beenden der Sizung

**service vsftpd start** **/etc/init.d/vsftpd start** --> startet den Server

**chkconfig -a vsftpd** --> fügt den Server den Standardrunlvel 3 und 5 hinzu 

__vsFTPd__
\\ /etc/vsftpd.conf \\ --> Konfigurationsdatei für den vsFTPd
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
listen=yes
backgorund=yes

#An Adresse binden
listen_adress=192.0.2.1

#Auf Port 20 Daten übertragen
connect_port_20=YES|NO

#Time Out für nicht aktive Verbbindungen
idle_session_timeout=300|Seconds

#Unpriviligierter User wird gemappt auf
nopriv_user=ftpsecure|<USER>

#Lokales Verzeichnis für das chroot für Anonyme Nutzer
anon_root=/srv/ftp/pub

#Login Banner
ftpd_banner=STRING

#Anonymes Schreiben von Daten erlauben
write_enable=NO|YES

Meldungen beim Betreten von Verzeichnissen aktivieren
dirmessage_enable=YES|NO 

#Anonymen Bnutzern den Zugriff gestatten
anonymous_enable=YES|NO

#Anonymen Nutzern nur das Herunterladen von Dateien erlauben die World Readable sind
anon_world_readable=YES|NO

#Anonymen Benutzern das Uploaden von Datein erlauben
anon_upload_enable=NO|YES

#Anonymen Benutzern das Erstellen von Verzeichnissen erlauben
anon_mkdir_write=NO|YES

#Anonymen Benutzern das Löschen und Umbenennen von Dateien erlauben
anon_other_write_enable=NO|YES

#syslog Protokollierung aktivieren
syslog_enable=YES|NO
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

!!!TIPP!!! FtpVorlage aus der Manpage generieren
**mv /etc/vsftpd.conf /etc/vsftpd.conf.bak**
**export GROFF_NO_SGR=yes**
**man vsftpd.conf | sed -d $'s/\b.//g' -e 's/^/## /' > /etc/vsftpd.conf**


\\ /etc/xinetd.d/vsfpd \\ --> Konfigurationsdati für den tcpwrapper des vsftpd
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# Begin /etc/xinetd.d/vsftpd

service ftp
{
	disable 	= no
	socket_type	= stream
	wait		= no
	user		= root
	server		= /usr/sbin/vsftpd
	per_source	= 5
	instances	= 50
	banner_fail	= /etc/vsftpd.busy.banner
	log_on_success	+= PID HOST DURATION
	log_on_failure	+= HOST
}

#End /etc/xinetd.d/vsftpd
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

===NFS===
Network Filesystem
+ bietet ein leicht konfigurierbares Netzwerkdateissystem
+ transparenter Zugriff
+ keine Sicherheit (Verschlüsselung oder Authentifizierung)
+ Clients können NFS freigaben mounten
+ benutzt UDP 

__NFS Kompnenten__
Server:
	User-Mode_Nfs: Alle Komponenten liegen asl Serverdienste vor
	Kernel-Mode_Nfs: Teile des NFS Server sind im Kernel impelmentiert $$SUSE kernel-nfs-server$$
	Portmapper: **portmap**, **mountd** **nfsd** werden benötigt

**nfsd** --> Der NFS Daemon zur verabeitung von Anfroderungen seiner Clients (benötigt)

**mountd** --> Verabeitet die mount Anforderungen der Clients (benötigt)

**nfslogd** --> Protokolliet die NFS Aktivitäten (optional)

**rquatad** --> Zur Verwaltung von Remote Quata Einträge (optional)

**lockd** --> Bereitstellen von Datei Locking (optional)
          --> benötigt **statd**

**Statd** --> wird von **lockd** benötigt (optional)
	  --> ermöglicht das zurücksetzen fehlerhafter verbindungen

**portmap** --> für das Mappen und zur Verfügung Stellen von Ports zustädnig
	    --> mit Hilfe des tcp wrappers Verbindungen kontrollieren

Client:
	keine weiteren Dienste benötigt ausser eine Version von **mount** die NFS unterstützt

__NFS Kernel Optionen__

CONFIG_NFS_FS --> für NFS Client Kompatibilität
	      --> diese Option stellt nur NFS Version 2 bereit
              --> diese Option kann beim Kernelbau deaktiviert werden wenn nur Clientseitiges NFS beötigt wird

CONFIG_NFS_V3 --> zus#tzlich zur Option CONFIG_NFS_FS bietet diese Optione NFS3 an

CONFIG_NFSD --> für NFS Server Kompatibilät
            --> diese Opotion stellt nnur NFS Version 2 bereit
	    --> diese Option kann beim Kernelnau deaktiviert wenn nur Serverseitiges NFS benötigt wird

CONFIG_NFSD_V3 --> zusätzlich zur Option CONFIG_NFSD bietet dies Option NFS3 an




__Konfigurieren des Server__
\\ /etc/exports \\ --> festlegen welche Verzeichnisse exportiert werden
		   --> Festlegen welche Clients darauf zugreifen dürfen
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
/<DIR>	<erlaubterClient>(<Optionen>,...)...
/home/exports	192.168.128.0/24(rw, sync) Admin(rw, sync, no_root_squash)

#<DIR> ist ein Verzeichnis auf dem Server dass exportiert wird

#Als <Erlaubter Client können IPs/Ranges sowie Namen angegeben werden
#Bei Namensangabe muss ein DNS entsprechend Rechnernamen auflösen können
#Wird * oder kein Client angegeben wird verzeichnis für alle exportiert
#qird ein @ verwendet wird das Verzeichnis für eine NIS-Gruppe exportiert


#<Optionen>
#rw --> lesend und schreibend
#ro --> nur lesend, die Rechte müssen auf dem Server entsprechend gestzt werden
#root_squash --> der Nutzer, die Gruppe root bekommt vom Server die Identität nobody
no_root_squash --> Der Nutzer, die Gruppe root bekommt vom Server die UID/GID 0
squash_uids --> Andere UIDs auf nobody mappen (squah_uid 0-999)
squash_gids --> Andere GIDS auf nobody mappen (squash_gid 0-999)
all_squash --> Jeden Benuztzer des Clients auf nobody mappen
anon_uid=<UID> --> jeden Benutzer auf die UID <UID> ummappen, verlangt all_sqaush (all_sqaush, anon_uid=1001)
anon_gid=<GID> --> jeden Benutzer auf die GID <GID> ummappen, velangt all_sqaush  (all_squash, anon_gid=1001) 
sync --> Änderungen werden sofort geschriben und der Buffer freigegeben
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

**eportfs [<User>:<Freigabe> -o <Optionen>]** --> exportierren von Freigaben zur Laufzeit des NFS Servers
            				      --> erstelln temporärer Freigaben
-a --> Alle Freigaben in der \\ /etc/exports \\ werden exportiert, wird meistens beim hochfahren von einem init Script übernommen
-u --> lösen einer temporären Freigabe
-ua --> lösen aller temporären Freigaben
-o --> Angeben von Optionen für ein temporär exportiertes Verzeichnis
-f --> die Kernel Exporttabelle  \\ /proc/fs/nfs löschen
-r --> aktivieren /reaktiveren der \\ /etc/exports \\
-v --> Verbose


**exportfs -af** --> löschen der Kernel Exporttablle und neu einlesen der Freigaben

**exportfs -u ford:/home/Magrathea** --> lösen der temporären Freigabe für den Nutzer ford auf /home/Magrathea

**showmount** --> Anzeigen von Mount Informationen des NFS Servers
	      --> ohne Optionen werden die Verbindungen zu den Clients angezeigt
-a|--all --> auflisten des Clients Hosnamenes und die IP Adresse
-e|--exports --> anzeigen der NFS Server Exportliste
-d|--direcotries --> aanzeigen von Verzeichnissen die von einem Remote Client eingebunden wurden

**showmount -e Beeblebrox** --> Anzeigen von Berechtigungen für den Rechner Beebelebrox
**service nfsserver start** --> startet den NFS Server und alle weitere von ihm benötigten Dienste

**rpcinfo** --> Informationen zum portmapper erhalten

__NFS Client__
+ Clients mounten exportierte Freigaben
+ das Zumountende Gerät ist in diesem Fall die Server Freigabe die durch <Rechner>:Verzeichnis angegeben wird

/etc/fstab
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
<Rechner>:<Verzeichnis>	<MountPunkt>	nfs	optioen	0 0
192.168.128.23:/home/exports	/mnt	nfs 	rw,sync 0 0
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

**mount -t nfs -o <Optionen> <Rechner>:<Verzeichnis> /mnt/exports** --> nfs Freigaben unter /mnt/exports einhängen
<Optionen>
	tcp --> tcp statt udp verwenden
	rw, ro --> readonly, readwrite 
	nolock --> deaktiviert das Locking von Dateien
	soft --> Schreib- Leseversuche nach Timeouts abbrechen
	hard --> Schreib- Leseversuche werden beliebig lange probiert
	intr --> Erlaubt das abbrecen von Datienoptionen durch das senden vpn Signalen
	auto --> mit mount option -a behandeln
	exec --> erlaubt die Ausführung von Dateien auf dem exportierten Verzeichnis
	noexec --> verbietet die Ausführung von Dateien auf dem exportierten Verzeichnis
	nodev	--> verbietet das Anlegen von Gerätedateien
	nosuid --> verbietet das Anlegen der Dateien die das Set UId Bit gestzt haben
	sync --> Daten zufort synchronisieren
	async --> Daten für Schreib-Lesezugriff optimieren und erst beim schließen der Datei synchronisieren
	
**showmount -e <Server>** --> zeigt die vom <Server> zur Verfügung gestellten Mount Punkte an

__Allgemeine Tools__

**nfsstat** --> Auflisten von NFS und RPC Statistiken
            --> dieses Programm kann Client und Serverseitig verwendet werden
-s --> nur Serverseitig
-c --> nur Clientseitig
-n --> nur NFS Statistiken ausgeben, per default werden auch rpc Statistiken mit aufgeführt
-m --> Informationen über jedes gemountete Dateisystem anzeigen

===NIS==
+ Network Information Service
+ Datenbank zur Steuerung und automatischen Verteilung von Konfigurationsdateien in einem Netzwerk
+ ermöglicht es die Dateien \\ /etc/passwd \\ \\ /etc/shadow \\ \\ /etc/groups \\ zentral auf einem Server zu verwalten
+ Datenbanken werden als NIS-Maps bezeichnet
+ führer Yellow Pages (yp)

__Automatisches erzeugen von MAPS__
+ einige Konfigurationsdateien erzeugen automatisch NIS-Maps
+ Maps können auf einem Master Server der den Serverprozess **ypserv** zur Verfügung gestellt werden
+ Anschließend können Maps von den Clients abgefragt werden
+ benötigt **portmap** 
+ Clients schicken rpcs für die Abhandlung der Anfragen
+ Master und Slave Server

\\ /etc/ethers \\ --> ethers.byaddr, ethers.byname

\\ /etc/hosts \\ --> hosts.byname, hosts.byaddr

\\ /etc/networks \\ --> networks.byname, networks.byaddr

\\ /etc/protocols \\ --> protocols.byname, protocols.byaddr

\\ /etc/servces \\ --> services.byname

\\ /etc/aliases \\ --> mail.aliases, mail.byaddr

**ypcat -x** --> listet die verfügbaren Maps auf dem aktuellen Host auf

**ypserv** --> NIS Server Daemon

**ypbind** --> NIS Client Daemon

**yppush** --> MAPS an den Slave Server senden

**ypinit -s <Master>** --> Initialisieren eines Slave Servers

__Den NIS Server konfigurieren__

Workflow Koinfigurieren des NIS:

(1) \\ /etc/sysconfig/networks \\ --> festlegen der NIS Domain
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
NETWORKING=yes
HOSTNAME=beeblebrox.adams.com
NISDOMAIN=beeblebrox.com
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

(2) generieren der Anfangs-Maps mit make **make \\ /var/yp/ \\**

(3) Starten des Servers **service ypserv && service ypbind**

(4) nsswitch.conf konfigurieren
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
hosts:		dns nis files
networks:	nis [NOTFOUND]	files
services:	nis files
protocols	nis files
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

__Clientseitige Konfiguration__
\\ /etc/yp.conf \\ --> Konfiguration des NIS Clients
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#für die angegebene Domain den Server Hostname verwenden
domain <Nisdomain> <Server> <Hostname>

#per Broadcast einen NIS-Server für die angegebene NIS Doamain suchen
domain <Nisdomain> broadcast

#der angegebenen NIS Server verwenden
ypserver <Hostname>

#per Broadcast nach einem NIS-Server suchen
broadcast
#Beispiel
domain	DONTPANIC	Slarty	192.168.128.42
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\\ /etc/nsswitch.conf \\ --> Konfigurieren der verwendeten Quellen
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
<datenbank>: <quelle1> <quelle2> <quelle3>...
<datenbank>
	aliases --> Mail Aliasse aus /etc/aliases

	automount --> Konfigurationsdateien für den Automounter

	ethers --> Datei \\ /etc/ethers \\, die Ethernetadressen IP-Adressen zuordnet

	group --> Benutzergruppen aus \\ /etc/group \\

	hosts --> \\ /etc/hosts \ mit ihren Zuordnungen zu IP-Adressen

	netgroup --> Negroups aus \\ /etc/netgroup \\ 

	networks --> \\ /etc/networks\\, die Netzwerkadressen Netzwerknamen zuordnet

	passwd --> \\ /etc/passwd \\, 

	protocols --> Protokolle die in \\ /etc/protocols \\ für TCP/IP Sub System verwendet werden

	publickey --> öffentliche und geheime Schlüssel für Secure_RPC

	rpc --> RPC Dienste in \\ /etc/rpc

	services --> \\ /etc/services \\ für Ports auf Dienste mappen

	shadow --> \\ /etc/shadow \\

<quelle>
	files --> lokale Datei
	nis --> NIS Server
	dns --> DNS Server
	ldap --> LDAP Server
	compat --> Kompatibilitätsmodus für passwd, shadow, group
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

__NIS Programme__
**ypcat** --> zum Anzeigen von NIS-MAPS
-x --> Anzeigen der \\ /var/yp/nicknames \\ transformations Tabelle
-k --> Anzeigen der Schlüsselwerte 
**ypcat passwd** Anzeigen der Datei passwd.byname


**ypmatch** --> Den Inhalt einer MAP nach Schlüsselwerten durchsuchen
-d <Domain> --> angeben einer Domain
-x --> Anzeigen der \\ /var/yp/nicknames \\ transformations Tabelle
**ypmatch -x Marvin passwd.byname** den Eintrag für User Marvin in der Passwortdatenbank anzeigen

**yppasswd** --> entspricht passwd und ändert Passwörter direkt auf dem NIS Master Server

**yppoll** --> gibt den Zeitstempel von NIS Maps aus
-h --> Angabe eines Hosts
-d --> Angabe einer Domain

**ypwhich** --> gibt den NIS Server aus, den ein Client verwendet

**yppush** --> übermitteln die Meldung das NIS Maps geändert wurden an den Slave Server

**ypxfer** --> übermitteln der NIS Maps vom Master Server an den Slave


===LDAP===
+ Lighweight Directory Access Protocol
+ im Netzwerk verteilte, hierarchische Datenbank, die auf einem Client Server System basiert
+ sammeln von Benutzer - und Objecktdateien
+ optimiert auf hohe Lese und schreibzugriffe
+ Objektorientiert
+ keine Relationen
+ über mehrere Server verteilt (Teile von Verzeichnissen können auf unterschiedlichen Servern liegen)
			       (Replikationen auf mehereren Servern möglich)		

__Aufbau eines Verzeichnisdienst__
+ Baumstruktur (Directory Information Tree) DIT
+ wird in einer Backend Datenbank abgelegt die sich über einen oder mehrere Rechner erstreckt

Bsp:               RootDSE
       --c=de --		c=at--
      |	        |                    |
      o=firm2   o=firm1              o=outbound
        |
        ou=scince---
	|	    |
	cn=user2    cn=user1

+ die höchste unsichtbare Einstiegspunkt bildet das rootDSE (Directory Service Entry)
+ die höchste greifbare Ebene bildet das DN (Distinguished Name) bsteht aus einer oder mehreren Komponenten
+ Base DN bestht aus einer Top Level Domain (TLD) Komonente (c=county im Beispiel) 
c=> country
o=> organisation
ou=> orgnaisational unit
cn = common Name (Hier Blatt des DN)
+ Objecte werden von ihrem Leaf (Blatt) aus von unten nach oben gelesen und geschrieben
+ Einträge bestehen aus *Attributen*, die einen *Typ* und einen oder mehrere *Werte* haben
+ Jedes Attribut hat eine Syntax die festlegt welche Typen und Werte erlaubt sind


__Standardattribute zur Bildung eines DNS__
Aufbau von oben nach unten:

TLD:
 |
 V
c=<Country>
o=<organization>
dc=domain component --> erstellen Verschachtelter Domain Strukturen
 |
 V
OU (Containerobjekte):
ou, dc
 |
 V
Gruppenobjekte
cn, dc
 |
 V
Userobjekt
uid,ou,o,c

__Distinguished Name__
+ Der DN wird immer vom Blatt zur Wurzel gelesen
+ Jedes Objec'kt ist durch seinen DN eindeutig gekennzeichnet.

dn="uid=gnu,ou=cows,dc=linux,dc=priv" ergibt folgende Struktur: rootDSE--> priv--> linux-->cows-->gnu



__Objekte, Klassen und Attribute__
+ Jedes Objekt hat einen oder mehrere Attribute, abhängig von den Objektklassen
+ Jedes Objekt definiert sich über seine Pflicht Atrribute
+ beim Start des LDAP Daemons werden in *Schema Dateien* die zur verfügung sehenden Datenbankfelder geladen
+ Objektkklassen und Attribute stellen Datenbankfelder brereit um Objekte zu beschreiben
+ Datenstrukturen die innerhalb eines Directories abgelegt werden heißen Einträge

<Name des Attributs>, <OID (weltweit eindeutiger Object Identifier)>, <Syntax>, <EQUALITY(Vergleichsregeln)>, <Single-Value>|<Multi-Value>

Matching Rules:
+ wie wird nach einem Objekt innerhalb eines Trees gesucht (Zum Beispiel wie Groß/Kleinschreibung nterpretiert werden soll)

Objekt Klasse: Die in einer Objektklasse zusammengefasstnten Attribute beschreiben ein Kosntrukt für die Abbildung von Objekten.
++++++++++++++++++++++++++++++++++++++++++++++++++++++++
dn: dc=local, dc=sitte #definiert den einderutigen DN
objectClass: dcObject      #stellt das Attribut dc bereit
objectClas:organization   #stellt das Attribut o bereit
dc:local
o:brain
+++++++++++++++++++++++++++++++++++++++++++++++++++++++
Objektklassen bestimmen darüber welche Attribute einen Attributwert erhalten müssen --> MUST/MAY

__LDAP Schemas__
+ beschreibt die Liste möglicher Typen von Einträgen (Objektklassen)
+ Attribute werden vor Objektklassen definiert
+ eine Objektklasse kann MUST Und MAY Attribute besitzen
+ Jeder LDAP Dienst greift auf mindestens eine Schemadefinition zurück
+ Schema beschreiben Objektklassen und Attribute die von einem LDAP Dienst angefordert werden
+ Schemas müssen per include in die Datei \\ /etc/(open)ldap/slapd.conf \\ \\ /etc/(open)ldap/slapd.d/ \\ eingelesen werden

\\ /etc/(open)ldap/slapd.conf \\ --> Enthält Anweisungen über die zu ladenden Schemadateien
                                 --> Konfiguration des Stand Alone LDAP Daemon | Server
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#Globale Konfigurationsdirektiven
#Durch Backend oder Database-Direktiven überschrieben

#ProzessID des slapd in Datei ablegen
pidfile /var/run/slapd.pid

#Argumente des slapd in Datei abelgen
argsfile /var/run/slapd.args


#ACLS
#slapd.access(5)
#access to <Objekt|*>
#by <dn="<DN>"|*>  none(kein Zugriff)|auth(Authentifizieren)|compare(Vergleich erlaubt)|search(suchen Erlaubt)|read(lesen erlaubt)
	           write (verändern erlaubt)|delete(löschen erlaubt) (Höhere Rechte schließen niedere mit ein)		
....                
  
access to attr=userPassword
by dn="cn=Manager,dc=my-domain,dc=com" write
by sellf write
by * auth


access to *
by dn="cn=Manager,dc=my-domain,dc=com" write
by self write
#Jeder andere
by * read


#Konfigurationsdirektiven für alle Backends eines Typs
backend <Bakcend-Typ>

#Datenbank spezifische Direktiven
#database <Database-Typ>
database	 bdb
#Wurzel des Verzeichnisdienstes RootDN
suffix		 "dc=example,dc=com"
#DN des Administrators des LDAP Servers
rootdn		 "cn=Manager,dc=example,dc=com"
#Passwort des LDAP Administrators
#mit **slappasswd** erzeugter Hash Wert
rootpw		 secret
#Verzeichnis für Datenbanken
directory	 /var/lib/ldap
#Festlegen des Indextyps nach Rfc 2252
index		 objectClass eq


#Integrations von Konfigurations- und Schemadateien
include /etc/openldap/schema/core.schema
include /etc/openldap/schema/cosine.schma
include /etc/openldap/schema/nis.schema
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


\\ /etc/(open)ldap/schema/Schemaname>.schema \\ --> Schemadateien für LDAP
			      	         --> Definieren Objekte und Attribute 

core.schema --> Standard X.501 enthält Standardattribute die grundsätzlich geladen werden müssen

cosine.schema --> wichtige Standardattribute für version 3

inetorgperson.schema --> für den Aufbau von organisationsorientierten Diensten

nis.schema --> LDAP als NIS nutzen

openldap.schema --> zusätzliche Attribute vom Openldap Projekt

smaba.schema --> Objektklassen um Samba über LDAP zu verwalten

misc.schema --> zuäsätzliche Mail Attribute , Experimentell

dyngroup.schema --> für overlay benötigt für dynamische Gruppen

ppolicy.schema --> Passwort Richtlinien bereitstellen

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#Attribute Type Definitions
attributetype (<OID> Name '<OID Alias>'
DESC 'Beschreibung'
EQUALITY <Mathching Rule>
SYNTAX <SYNTAX Bezeichner>)

#Objectclass Definition
objectclass (<OID> Name '<OID Alias>'
#OIDs die mit 1.1 anfangen können für private Zwecke genutzt werden
#Andere OIDs müssen bei der IANA beantragt werden
SUP <Objectklasse> #ABSTRACT|STRUCTURAL|AUXILIARY
DESC 'Beschreibung'
MUST (atributetype $ ...)
MAY (attributetype $ ..))

#ABSTRACT: Oberste Objektklasse, dient dazu nach unten hin Objectklassen aufzubauen
#STRUCTURAL: beschreibt ein tatsächliches Object im DIT, erbt seine attribute von der Objectklasse ABSTRACT
#AUXILLARY: es könnenn nur Attribute zu einer bestehneder Objektklasse hinzugefügt 
#           setzt eine übergeordnete strukturelle Objektklasse vorraus 


#Beispiel Possix Account
attributetype (1.1.1 Name 'uidNumber'
DESC 'An Integer uniquily identifying a user'
EQUALITY integerMatch
SYNTAX 1.1.1 SINGLE-VALUE)

attributetype (1.1.2 Name 'gidNumber'
DESC 'An Integer uniquily identifying a group'
EQUALITY integerMatch
SYNTAX 1.1.2 SINGLE-VALUE)

attributetype (1.1.3 Name 'homeDirectory'
DESC 'The absolute path to the home directory'
EQUALITY caseExactIA5Match
SYNTAX 1.1.3 SINGLE-VALUE)

attributetype (1.1.4 Name 'loginShell'
DESC 'Path to user login shell'
EQUALITY caseExactIA5Match
SYNTAX 1.1.3 SINGLE VALUE)

...

#objeckt Klasse Possix Account
objectclass (2.0.0 Name 'possixAccount'
#leite die Objektklasse possixAccount von der Objektklasse top ab
SUP top AUXILLARY
DESC 'Possix User Account'
MUST (cn $ uid $ uidNumber $ gidNumber $ homeDirectory )
MAY (userPassword $ loginShell $ gecos $ description))
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\\ /etc/(open)ldap/ldap.conf \\ --> Systemweite Einstelunngen für LDAP Clients 
                                --> werden durch \\ ~/.ldaprc \\ überschrieben
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#Der zu verwenderne LDAP Server
#Ohne LDAP Zugriff AUflösbar
host 127.0.0.1

#Der DN der Search Base
base dc=my-domain, dc=com
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\\ /var/lib/ldap/ \\ --> Datenbankdatieen

__Aufbau einer LDIF Datei__
<Datei>.ldif
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
dn: uid=bmarshal,ou=People,dc=pisoftware,dc=com #root DN
uid: bmarshal 
cn: Brad Marshall
objectclass: account
objectclass: posixAccount
objectclass: top
loginshell: /bin/bash
uidnumber: 500
gidnumber: 120
homedirectory: /mnt/home/bmarshal
gecos: Brad Marshall,,,,
userpassword: {crypt}KDnOoUYN7Neac
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


__Die LDAP Programmsuite__

**slappasswd** --> Einen PasswortHash für die Verwendung in einer LDIF Datei oder \\ /etc/slapd.conf \\ erzeugen
-h {CRYPT|MD5|SHA|SSHA} --> den zu verwendeten Hash-Algorhithmus bestimmen
-s --> Das Passwort in die Standardausgabe schreiben


**ldappasswd <RDN>** --> Passwort für ein besthenden User-Objekte setzen oder ändern
-x --> einface unverschlüsselte Authentifizierung, ohne SASL
-W --> anschließenden Passwortabfrage
-D <DN> --> Identität des LDAP Servers, DN
-S --> nach neuen Passwort fragen


**ldapadd** --> fügt ein Objekt Objekt zu LDAP hinzu
            --> ruft Tatsächlich ldapmodify mit der Option -a auf
-x --> einfach unverschlüsselte Authentifizierung, ohne SASL
-W --> anschließende Passworteingabe erforderlich
-D --> Identität des LDAP Servers, DN
-f <Datei.ldif> --> eine LDIF(Lightweight Directory Interchange Format) Datei angeben

**ldapadd -x -D "cn=Manager, dc=eample, dc=com" -W -f blatt.ldif** --> Die Datei blatt.ldif zum LDAP hinzufügen

**ldapsearch <OID>** --> zum Suchen von Objekten im DIT eines LDAP Verzeichnis
-b --> angeben der Search Base anstelle des Standards /
-x --> einfache unverschlüsselte Authentifizierung, ohne SASL
-h --> angeben eines alternativen Hosts für den LDAP Server

**ldapsearch -x objectClass=** -h ldapmaster -b dc=local,dc=site** Auf local.site alle Objekte im DIT anzeigen

**ldapmodify** --> Ändern vorhandener Objekte im DIT
               --> intteraktiv
-x ---> einfache unverschlüseelte Authentifizierung, ohne SASL
-W --> anschlieende Passwortabfrage erforderlich
-D --> Identiät des LDAP Servers, DN
-f <Datei> --> Datei des zu ändernden Blatees im LDIF Format

**ldapdelete** --> löschen von Objekten im DIT
-x --> einfache unverschlüsselte Authentifizierung, ohne SASL
-f <Datei> --> Angeben einer Datei die die zu entfernenden Objekte enthält  
-W --> nach enfacher Authentifizierung fragen

**ldapcompare <DN> <Objekt>:Wert** --> überürüfen ob ein bestimmter Satz an Daten existiert
                --> liefert einen Bollean für das gesuchte Objekt|Atrribut
-x -->einfache Authentifizierung ohne SASL

**ldapwhoami** --> meine aktuelle Datenbank Identität feststellen
-X --> enfach Authentifizierung, ohne SASL

**ldapmodrdn <DN> <Objekt>=Attribut** --> modifizieren des relativen dn (rdn) 
**ldapmodrdn -xWD cn=ldapadmin,dc=local,dc=site,uid=skui,ou=forschung,dc=local,dc=site uid=skiu1** --> Ändern des RDN für skiu in skui1


===Samba==
+ erzeugen von Windwosfreigaben auf Linux
+ gemeinsame Verwendung von Festplatten und Druckern (Resourcen) in einem heterogenen Netz
+ Namensauflösung für WINS
+ vereinheitlichen der Linux- und Windows Benutzerverwaltung und Authentisierung über LDAP

__Definitionen__
Workgroup: Gruppenname, der eine beliebige Sammlung von Computern, die gegenseitig auf ihre Resourcen zugreifen, kennzeichnet
 ^
 |
CIFS: Common Internet Filesystem

NetBIOS: dient dazu Computer NAmen in Adressen umzuwandeln, die von WINS verstenden werden
	--> RFC 1001, 1002 
	--> 2 Computer in der gleichen Workgroup können nicht den gleichen Namen haben

WINS-Server: Verwalten und registrieren von Namen 
		--> Wird ein Name bereits innerhalb einer Workgroup verwendet wird eine Fehler zurückgegeben

__Protokolle SMB und NetBIOS__
SMB: Server Message Block --> Auf Port 146
			  --> besteht aus eine Header (fix, enthält das 8 bit breite Kommando)
			  --> 32 Bit breiter Statusbereich für die Übermittlung von Meldungen
                          --> besteht aus einem Datenteil variabler Größe
			  --> Aufbau und Abbau von Verbindungen zu Freigaben
			  --> Öffnen und Schließen von Dateien
			  --> Lesen und Schreiben von Dateien
			  --> Erstellen und Löschen von Dateien
			  --> Anzeige von Verzeichnis-Inhalten
			  --> Lesen und Schreiben von Datei-Attributen
			  --> Locking von Dateien	


NetBIOS: --> kommunikation von Netzwerkhardware mit PC Programme
         --> Adresssierungsschema durch 16 Byte Name (NetBIOS Name Port 137)
	 --> NetBIOS Namenstypen: + netbios-ns (NetBIOS nameservice Port 138)
				  + netbios-dgm (NetBIOS datagram für Übertragung der Daten Port 139)
				  + netbioas-ssm (NetBIOS Session Service für Auf- und Abbau von Verbindungen) 

__Konfgigurationsübersicht__
\\ /etc/samba/smb.conf \\ --> Konfigrationsdatei für den Samba Server
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#!!Kommentare hinter den Direktiven sind nicht erlaubt!!#
#!!Dienen hier nur der Beschreibung!!#

#Sektion für globale Optionen
#Alle Einstellungen für wweitere Shares gelten als Standard, sofern sie von anderen Sektionen nicht 
#überschrieben werden
[global] 
include = PATH 				#Weitere Konfigurationsdateien aus einem anderen Verzeichnis lesen
netbios name = STRING			#Setzen des Namnes des NetBIOS Name, Standard ist der Hostname des Servers
workgroup = STRING			#Setzen der Samba Domain, des NetBIOS-Gruppen-Name
					#Clients müssen in der gleichen NetBIOS Gruppe sein
					#Standard ist WORKGROUP
					#! Unbeding doppelte Namen im Netz vermeiden dei zu einem Konflikt führen könnten

server string = STRING			#beschreibender String der mit dem Server assoziiert wird

interfaces = ethX|IP|CIDR		#festlegen der Schnittstelle|Subnetzes auf dem der Server Anfragen entgegennimmt

bind interfaces only = Yes|No		#Wird bei meheren Schnittstellen benötigt, empfohlen ist hier Yes

hosts allow = IP|all			#Fstlegen welche Hosts sich beim Server anmelden dürfen
hosts deny = IP|all			#Festlegen welche Hosts sich beim Server nicht anmelden dürfen

log level = [0-10]			#Angabe des Loglevels
					#0 ist Standard
					#1 nur Informationen über Verbindungen
					#2-3 Debugging
					#>3 für Entwickler

log file = PATH				#Pfad zur Logdatei die geschrieben wird

max log size = KB			#Größe in KB der Logfiles

syslog = [0-10]				#Schließt log level aus 
					#Logging wird durch rsyslog übernommen

syslog only = No|Yes			#Samba anweisen fürs Logging nur den Systemdämon zu verwenden

max connections = 10			#maximale Anzahl der Verbindungen zu diesem Server

security = user|share			#Nach Benutezrnamen bei der Anmeldung fragen | nicht fragen

#Definieren eines Shares
[ShareName]
#Optionen können auch in global verwendet werden dann gelten sie für alle Shares
	
	copy = [PreShare] 		#Konfiguration aus einem anderem Share übernehmen
	comment = STRING		#Kommentar einfügen der unter Details angezeigt wird
	path = PATH			#absoluter Pfad auf dem Server der bereitgestellt werden soll
					#falls Verzeichnis nicht exisitert oder Rechte falsch gesetzt wird Zugriff verwehrt
				
	read only | writeable = No|Yes 	#Ist der Share nur lesbar oder auch schreibbar	 
		 			#Standardwert ist nicht schreibbar

	volume = STRING			#Volume Namen des Shares 
					#Standard ist der Name des Shares
					#Wird benötigt falls Share als installationsverzeichnis genutzt werden soll	

#Temporärer Share, der erstellt wird falls der Client keinen Share angegeben hat
[homes]

#falls Samba keine [homes] Vorfindet, wird angenimmen, dass Samba als Printer Share verwendet werden soll
#verwalten von mehereren Druckern als eine Resource
# benötigt eine gültige /etc/printercap
[printers]

#Diese Varibalen können in den Direktiven verwendet werden
#Variablen beginnen mit %
%a #Architektur des Clients
%i #Interface des Clients zu dem der Client verbunden wurde
%I #Client IP-Adresse
%m Client NetBIOS Name
%M Clients DNS Name

%u #Momentaner Unix Nutzername
%U #Username bei der Intialisierung des CIFS 
%D #Nutzer Domäne
%H #Home Verzeichnis von %u
%g #Primäre Gruppe von %u
%G #Primäre Gruppe von %U

%S #Momentaner Share Name
%P #Momentanes Root Verzeichnis
%p #Momentaner Pfad zum Share Root Verzeichnis

%d #PID des Servers
%h #Samba Hostname des Servers
%N #Heimatverzeichn vom Automount Mapper
%v #Samba Version

%R #Das SMB Protokol Level
%T #Datum und Zeit
%$(VAR) Wert der Umgebungvaribale VAR


+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\\ /etc/samba/lmhosts \\ --> Datei die NetBIOS auf IP-Adresseen referriert
			 --> kann für die Namensauflösung verwendet werden
++++++++++++++++++++++++++++++++++++++++++++
192.168.128.23 horst
129.168.128.45 eva
...
+++++++++++++++++++++++++++++++++++++++++++

__Starten und Verwalten des Samba Daemons__
**/usr/sbin/smbd -D**, **rcsmb start|stop|restart** --> Starten und Verwalten des smb Daemons

**/usr/sbin/nmbd -D**, **rcnmb start|stop|restart** --> Starten und Verwalten des nmb Daemons

!!! Bei einem kill werden erst die Clients beendet (wartet) Es werden keine weiteren Verbindungen akzeptiert

**rcnmb start && rcsmb start**


**smbclient -L localhost -N** --> mit dem Server verbinden
-L --> auf Netbiosname
-N --> kein Passowrt erfragen
-U --> User angeben
-W --> Workgroup angeben

** smbclient -W DOMAENE -U tux //WUERGGRUBE/Magrathea/** --> den User tux auf dem Rechner in der Domain DOMAENE auf dem Rechner WUERGGRUBE anmelden
							     und dort auf die Freigabe Magrthea zugreifen


__Samba Distribution und ihre Programme__

**nmbd** --> Name Server Daemon
	 --> Namensauflösung für NetBIOS
	 --> Sucdiesntprotokolle (Netzwerkumgebuing unter Wiwndows)
	 --> bietet WINS Funktionalität
	 --> horcht auf Name-Server Request und bietet die zugehörige IP-Adresse an
	 --> kann nur mit smbd verwenden werden und muss vor diesem gestartet werden
-D --> nmbd als Dämon starten, Standardverhalten
-F --> nmbd nicht als Dämon starten
-S --> Schreibe Logfile nach Sdtout und nicht ins Logfile
-i --> nmdbd wird interaktiv gestartet, nicht als Daämon und die Logfiles werden nach StdtOut geschrieben, implizeiert -S
-d 0-10 --> Setzen des debugging Level
-s <Conf> --> Angeben einer Konfigurationsdatei
-p N --> Angeben des Standardports auf dem nmbd antwortet, Standardport ist 137


**smbd** --> Server Message Block Daemon
	 --> Datentransfer von gemeinsam genutzten Resourcen
	 --> verwalten von gemeinsamen Resourcen
	 --> Verwalten der Nutzerauthentifizierung
-D --> smbd als Dämon starten, Standardverhalten
-F --> smbd nicht als Dämon starten
-S --> Schreibe Logfile nach Stdout und nicht ins Logfile
-i --> smbd wird interaktiv gestarte, nicht als Daemon und die Logfiles werden nach StdOut geschrieben
-d 0-10 --> Setzen des debugging Level
-s <Conf> --> eine Konfigurationsdatei angeben
-b --> Informationen über die Konfigruations zur Kompilieriung nach StdtOut schreiben, der Server wird nicht gestartet
-p N --> Angeben des Standardports, Standard ist in \\ /etc/samba/smb.conf \\ unter der diretive ports festgelegt
-P 0|1|2 --> Angeben des Loglevels für gelieferte Daten


**winbindd** --> vereinheitlichen der Benutzerverwaltung zwischen Unix und WIndows
             --> Integration der Benutzerdatenbank einer Windows Domäne in die des Linux Systems
             --> Identisierung der Benutzer auf eine zentrale Datenbank
	     --> Optional	
-D --> als Daemon starten
-F --> nicht als Daemon starten
-S --> Schreibe Logfile nach StdtOut
-i --> interaktive starten, nich als Daemon und Logfiles werden nach StdOut geschrieben
-d 0-10 --> setzen des debugging Level
-s <Conf> --> eine Konfigurationsdatei angeben



**smbclient** --> erlaubt den Zugriff auf SMB-Freigaben
	      --> erlaubt den Zugriff auf Drucker Freigaben
	      --> Auf Daten kann über Kommanddos ähnlich ftp zugegriffen werden

-R lmhosts|hosts|wins|bcast --> Festlegen der Namensauflösung
				lmhoststs: lookups in Samba lmhosts Datei
				host: Standard Hostname abfrage über \\ /etc/hosts \\, NIS oder DNS Lookups
				wins: Abfragen der Namen per wins spezifiziert im wins server Name
-M <Netbios Name> --> übermitteln einer Nachricht über das Win Popup Protocol 
		   	+ Wenn Verbindung hergestellt wurde kann Nachricht gesendet werden; Abschließen durch <Strg>-D
			+ In Verbindung mit -U und -I kann Sender und Empfänger bestimmt werden

-L --> Auflisten der verfügbaren Services eines Servers

-p N --> Port Nummer N benutzen um eine Verbindung herzustellen

-g --> In Verwendung  mit -L um Ausgabe an **grep** oder **cut** zu pipen

-I <Ip Adresse> --> Ip-Adresse anstelle von Namen angeben

-P --> den Acoount auf der momentanen Maschine benutzen

-k --> Mit kerberos Authentifizieren

-U <Nutzer> --> mit dem <Nutzer> anmelden, nach Passwort wird gefragt oder mit %<Passwort> angeben

**swat** --> Samba Web Administrationstool
	 --> basiert auf https
	 --> Port 901/TCP
	 --> läuft als Daemon unter (x)inetd 
	 --> Adressierbar im Browser unter localhost:901
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#Begin swat

servive swat
{
	socket_type	= stream
	wait		= no
	protocol	= tcp
	only_from	= 127.0.0.1
	log_on_failure 	+= USERID
	server		= /usr/bin/swat
	port		= 901
	disable		= no
}

#End of swat
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

**findsmb** --> durchsucht das lokale Netzwerk nach Rechnern, die auf das smb Protokoll antworten
-r --> berücksichtige Fehlerhafte Win 95 Implementierungen 

**net -w|-W|-I|-S [-U] [-n] <Command>** --> Ausführen von Remote Adminstration von Servern
-w <Workgroup> --> Setzen der Ziel <Workgroup>, Serverseitig
-W <Workgroup> --> Setzen der Ziel <Workgroup>, Clientseitig
-I <IP> --> Setzen der Ziel Adresse 
-U <User> --> Nutzername der verwendet werden soll
-s <Conf> --> Angeben einer Konfigurationsdatei, Standard ist \\ /etc/samba/smb.conf \\
-S <Server> --> Setzen des Zielservers mit Namen <Server>
-p N --> spezifizieren des Ports
-n <Netbiosname> --> Überschreiben des NetBIOS Namen den Samba für seine Verbindungen verwendet
-d 0-10 --> setzen des debugging Level
<Commands>:
	 --> Befehle werden in net(8) ausführlich beschrieben 		

**nmblookup <name>|-A <IP>** --> Namensauflösung für nmb testen
	      	             --> Debuggen des nmb
-M --> nach einem lokalen Master Browser suchen
-r --> berücksichtige Fehlerhafte Win 95 Impelmentierungen
-A --> eine IP-Adresse anstelle eines NetBIOS Namen als Parameter übergeben
-U --> Unicast Adresse
-W <Workgroup> --> Setzen der Ziel <Workgroup>, Clientseitig
-O <Options> --> TCP Socket Optionen übergeben

**nmblookup -U 192.168.128.12 -R DONTPANIC** --> Testen der Namensauflösung 
>> querying DONTPANIC on 192.168.128.12
>> 192.168.128.12 DONTPANIC<00>

**nmblookup -A 192.168.128.12** --> reverse lookup

**nmblookup '*#20' --> finden von Rechnern anhand eines Suffxix

**nmblookup __samba__** --> alle Samba Rechner im Netz finden

**rpcclient** --> Clientseitige rpc Funktionen ausführen
	      --> auch das Herunterfahren entfernter Rechner

**smbcacls {//server/share} {Datei}** --> setzen oder erfragen von ACLs eines Windows NT Verzeichnis
-a acls --> Hinzufügen von ACL
-M acls --> modifizieren der Maske
-D acls --> löschen von ACL
-t --> testen, nichts schreiben

**smbcquotas {//server/share}** --> setzen oder erfragen von Qutas 
-u <User> --> Nutzer festlegen für den die Quotas gelten sollen
-L --> Auflisten aller Quata Records für einen Share
-F --> Anzeigen des Quatos status und der Standard Limitationen
-t --> testen, nichts schreiben 
-S QUOTA_SET_COMMAND --> Quatos setzen 

**smcquotas -u <User> -S UQLIM:<username>:<softlimit>/<hardlimit>** --> Quotas für den Nutzer <User> setzen
**smbcquotas -S FSQLIM:<softlimit>/<hardlimit>** --> Standardquotas setzen

**smbmnt**, **smbmount**, **mount.cifs** --> Tools um SMB/CIFS zu mounten
**smbumount**, **umount.cifs** --> Tools um SMB/CIFS zu unmounten

**mount.cifs //192.168.128.150/Erde/ /mnt/ -o username=tux** --> Die Freigabe Erde auf 192.168.128.150 als user tux mounten
							     --> cifs kann nur mit IP Adressen umgehen

**mount.cifs //Unixversum/Erde/ /mnt/freiagbe -o credentials=<Freigabedatei>** --> Angabe einer Datei die die entsprechenden Anmeldeinformationen
										   beinhaltet

<Freigabedatei>
+++++++++++++++++++++++++++++++++
username=tuxx
passwowrd=geheim
++++++++++++++++++++++++++++++++
--> sollte entsprechend Geschützt sein

**smbpasswd** --> Anlegen und Verwalten von Nutzern auf einem Server
-a <User> --> Einen Nutzer zur \\ /etc/smbpasswd \\ hinzufügen
-x <User> --> Einen Nutzer aus der \\ /etc/smbpasswd \\ löschen
-d <User> --> Einen Nutzer deaktivieren
-e <User> --> Einen Nutzer reaktivieren
-n --> Angeben dass das Passwort =blank= sein wird
-m --> Der angegebene Account ist ein Maschinenaccount, wenn als PDC eingestzt
-s --> silent, Passwort von StdIn lesen

**smbpasswd -r <IP> -U <User>** --> auf dem Rechener mit der <IP> das Passowrt von <User> ädnern

!!! Samba muss seine Passwörter und Nutzer auf vorhanden Nutzer im System mappen können, um Berechtigungen
abzubilden, deshalb muss der Nutzer auch auf dem Server selber mit **useradd** angelegt werden. Dieser bnötig dann aber 
keine valide Login Shell (/bin/false) und kein gültiges Userpasword.!!!

**smbstatus** --> gibt einen Bericht üver die momentan offenen Verbindungne zum Share an
-L --> nur die Locks anzeigen

>> Service		pid	machine					Connected at
-----------------------------------------------------------------------------------------------
<Service  | Share>	 <PID> 	<IP Adresse der verbundenen Maschine> <Verbunden seid Datum>


TIPP: **watch smbstatus**

**smbtree** --> Auflisten aller in einem Subnetz verfügbaren Domänen und zugehörigen Rechner 

**smbtree -N** --> Zeigt die Netzwerktopologie an


**testparm** --> Testten der Konfigurationsdatei
-v --> Ausgeben aller Optionen die nicht explizit in der \\ /etc/smaba/smb.conf \\ angegeben wurden aber Standardwerte erhalten haben
--parameter-name=STRING --> den Wert für diese Direktive erfragen
--section-name=STRING --> alle Werte für eine bestimmte Section ausgeben

**testparm  /etc/samba/smb.conf Beeblebrox 192.168.128.22** --> testen ob die Verbindung von einem bestimmten Rechner aus zugelassen wird


__Samba und Syslog__
+ muss mit der Option --with-syslog kompilliert wprden sein
+ Samba Logfiles werden dann zur der Daemon facility in \\/etc/syslog.conf \\ geloggt
+++++++++++++++++++++++++++++
...
daemon.* = /var/log/daemon.log
...
++++++++++++++++++++++++++++
+ in der [global] Section der smb.conf befindet sich der Eintrag
++++++++++++++++++++
syslog = Level
	#0 Log_ERR
	#1 LOG_WARN
	#2 LOG_NOTICE
	#3 LOG_INFO
	#>4 LOG_DEBUG

syslog only = Yes
+++++++++++++++++++

__Veraltung von Gästen auf dem Samba Share__
Festlegen eines Anonymen Gastaccounts:
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
security = Share
guest ok = Yes
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#Nicht zugelasssene Nutzer werden auf den Gast Account umgelenkt
map to guest = bad user|never|bad password|bad uid [global]

#festlegen des Unix Usernamens auf den Gast gemappt wird
#dieser muss dann auch  entsprechedn existieren und erhält /bin/false als loginshell
guest account = smbguest [global] 

#darf Gast diesen Share betreten
guest ok = No|Yes 	[Share]

#dieser Share wird nur für Gäste verwendet
guest only = No|Yes	[Share]
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
__Passwortverwaltung in Samba__
+ Klartext
+ NTLM
+ Kerberos Tickets

!!Authentifizierung mit PAM!!
+ /etc/pam.d/samba
+ --with-pam zur Kompillierung
+ **smbd -b|grep WITH_PAM** --> erfragen ob Samba mit Pam benutzt werden kann

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#Kontrolliert ob smbd die accound und session akzeptiert
obey pam = No|Yes [global]
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Account Storage:
\\ /etc/smbpasswd \\
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
<username>:<uid auf dem Server>:<lnman_hash>:<flags>:<pw_lct>

<flgs>
D --> Disable
N --> kein Passowrt erforderlich
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

**smbd -b|grep SMB_PASSWD_FILE** --> erfragen ob Smaba mit smbpasswd benutzt werden kann

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
security = user [global]
encrypt passwords = Yes [global]
passdb backend = smbpasswd [global]
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

TDBSAM:
+ empfohlene Methode
+ bietet mehr Attribute als die Klartext Datei
+ Standard ist \\ /etc/samba/passdb.tdb \\

**smbd -b |grep PRIVATE_DIR** --> erfraen ob Smaba tdbsam benutzen kann
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
passdb backend = tdbsam:/PATH  [global]
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Weitere Direktiven:
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#Synchronisiern zwischen der Smaba Passwort Datenbnank und /etc/passwd
#benötig die Direktive passwd programm 
unix password sync = Yes|No [global]

#Angabe des Programms das für die Passwortverwaltung auf dem Server benutzt wird
passwd programm = /usr/bin/passwd %u [global]

#Angabe eines Dialogs falls der User sein Passwort auf dem Server ändern möchte
#Muss mit dem Passwortchat des Systems übereinstimmen
[global]
	preexec = /usr/bin/export %$(LANG=CC)
	passwd chat = *New*Password*for*%u %n\n\
		      *Reenter Pssword*for*%u %n\n\
		      *Pssword*changed*for*%u
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

__Samba als WINS Server__
+ der nmbd muss gestarte sein

++++++++++++++++++++++++++++++++
[global]
	...
	wins support = Yes
	...
++++++++++++++++++++++++++++++++
--> nmbd lauscht auf Port 137 und bietet dort WINS Dienste an

+ registrierte Namen werden in \\ /var/lib/samba/wins.dat \\ abgelegt
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
<NetBIOS Name>#<NetBIOS Suffix>	<TTL> <IP-Adresse> <Flags>
Maria#00	1107768483	192.168.128.12	64R
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
<NetBIOS Suffix>
	#00 --> Rechner
	#03 --> Generischer Rechnername
	#20 --> Rechner bieter Freigaben an
	#1b --> Domain Master Browser
	#1c --> DC 


__Browser, Local Master Browser und Domain Master Browser__
+ nmbd verwaltet Informationen welcher Rechner welche Dienste anbietet


Browser: + verantwortlich für das Vorhalten von Browsinglisten 
         + Registrieren sich mit NetBIOS Namen _MSBROWSER_ und können so von anderen Systemen gefunden werden

Master Browser: + bietet den Dienst an, browsing Listen für andere Rechner bereit zu stellen
                + benötigt WINS Support

LMB (Local Master Browser): + hält die Suchliste für ein komplettes Subnetz vor
                            + zum LMB wird ein Rechner im Netz durch die bisherige Rolle 
                            + das Rollenverhalten wird durch os level = N und local master = Yes eingestellt
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
[global]
    ...
    #Angabe des WINS Server im Subnetz
    wins server = 123.45.67.89
    
    workgroup = ARBEITSGRUPPE
    #Ein guest account muss vorhanden sein
    guest account = nobody
    #Als Master Browser bewerten 
    local master = Yes
    #ertzwingen eines neuen LMB Wettbewerbs
    preferred master = Yes
    #Chance des Samba Servers die Wahl des Master Browsers zu gewinnen
    # WIndows NT beutzt den Wert 32
    # Standardwert
    os level = 65
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Domain Master Browser: + erhält Suchlisten aller LMBs vereinigt sie und schickt sie wieder zurück
		       + domain master = Yes
		       + PDC muss gleichzeitig DMB sein
		       + registriert seinbe IP beim WINS Server unter dem Namen der Arbeitsgruppe gefolgt von <1B>
		       	

__Sicherheitsstufen__
Share Level 
++++++++++++++++++++++++++++++++
security = share [global]
++++++++++++++++++++++++++++++++
--> Zugriffsbeschränkungen sind nur an die Freigaben gebunden
--> keine Unterscheideung zwischen verschiednenen Benutzern
--> Jeder Freigabe kann ein eigenes Passwort zugewiesen werden

User Level
++++++++++++++++++++++++++++++++
security = user [global]
++++++++++++++++++++++++++++++++
--> Datei und Benutzerspezifische Zugriffsbeschränkungen
--> Zugriffsrechte für Dateien können auf einzelen Benutzer verteilt werden
--> Authentifizierungsinformationen liegen lokal auf dem Server auf dem Freigaben liegen

Server Level
+++++++++++++++++++++++++++++++
security = server
+++++++++++++++++++++++++++++++
--> wie User Level
--> Authentifizierungsinformationen liegen auf einem Kennwort Server der Arbeistgruppe

Domain Level
++++++++++++++++++++++++++++++
security = domain
++++++++++++++++++++++++++++++
--> wie Server Level
--> Authentifizierungsinformationen liegen auf einem Domain Controler
--> gesicherte Verbindung zum Authentifizierungs-Server
--> Authentifizierung gegneüber einer Domäne anstelle von Einzelrechnern
--> Zugriff bei erfolg auf allen Rechnern der Domäne

ADS Level
+++++++++++++++++++++++++++++
security = ads
+++++++++++++++++++++++++++++
--> Verschlüsselung und Authentifizierung über Active Directory und Kerberos

__Authorisation__
+ Security Discriptor
+ ACLs
+ Dateisystem Berechtigungen

+users --> Namwe als Unixgruppe Name ansehen
&user --> Name als NIS-netgroup Namen ansehen

@users --> angeben von Unixgruppen entspricht +&users

Direktiven:
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#Liste der Nmen die auf den Root Account des Servers gemappt werden
#+Group löst Namen als Unix Gruppennamen auf
admin users = User1 User2 @Group [global]

#Nutzer die den Share betreten dürfen
valid users = Tim Struppi  [Share]

#Aliasnamen in einer Datei ablegen
#diese datei enthält pro zeile einen Eintrag alias = user
username map = /etc/samba/users.map

#Eine Datei angeben, die alle Hosts enthält die sich ohne Passwort anmelden dürfen
host equiv = <Datei>

#Zugriff auf einem Share aktivieren oder deaktivieren
available = Yes|No

#Nutzer die den Share betreten dürfen
valid users = [@]users [Share]

#Nutzer die den Share nicht betreten dürfen
invalid users = [@]users [Share]

#Ausnahmeregelungen für Dateien in Zusammenhang mit readonly = Yes | writeable = Yes
write list = /mein/projekt [Share]
read list = /home/share/.config [Share]

#Maximale Anzahl der Verbindungen die zum Server bestehen dürfen
#Weitere Verbindungsversuche werden mit einem Permissions denied quittiert
max connections = N [global]

#soll Samba Dateien in der Richtigen Groß und Kleinschreibung behandeln
case sentive = Yes|No [global]

#Was soll als Standardfall angenommen werden
default case = upper|lower [global]

#Soll Samba symbolischen Links auf dem Server folgen
follow symlinks = No|Yes [Share]

#Soll samba Links ausserhalt des Sharewurzel folgen
wide links = No|Yes [Share]

#Liste der Datein die nicht angezeigt wird
hide files = FILELIST [Share]

#Sollen Dateien die auf dem Server mit einem . beginnen versteckt werden
hide dot files = Yes|No [Share]

#Sollen Dateien die im Share liegen aber nicht lesbar sind angezeigt werden
hide unreadable = Yes | No [Share]

#Sollen Dateieen die im Share liegen aber nicht schreibbar sind angezeigt werden
hide unwriteable = No|Yes [Share]

#Auf diese Dateien darf generell nicht zugegriffen werden
#löschen, schreiben, lesen dieser Dateien ist nicht möglich
veto files = FILELIST [Share]

#Soll Samba Sockets und Named Pipes beim Lising mit aufführen
hide special files = Yes|No [Share]

#Soll das Verhalten von DOS gelten dass jeder Nutzer mit den entsprechenden Rechten die rechte Ändern darf
# Erinnerung: In Linux darf nur der Eigentümer der Datei die Rechte ändern
dos filemode = No|Yes
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Dos Attribute:
+ diese Atrribute werden von Microsoft Clients verwendet

Archive: --> wird gestzet, wenn die Datei sich ändert
	 --> Linux setzt dieses Bit nicht
         --> Samba kann damit umgehen ist aber per defaut nicht aktiviert

Hidden:  --> wenn gestzet ist die Datei nicht sichtbar

ReadOnly: --> Immutable Bit bei Linux

System: Identitifzierungs Bit für Dateien die vom Kernel benutzt werden (Memory und Swap)

--> Samba mapped die Attribute vom Standard rwx Rechten von Unix

ReadOnly: = r-- kein Schreibbit gestzet
Archive: = x Bit beim Nutzer
System: = x Bit bei der Gruppe
Hidden = x Bit bei Other

Direktiven:
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
map archive = Yes|No [Share]
map hidden = Yes|No [Share]
map readonly = Yes|No [Share]
map system = No|Yes [Share]
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

__Locking in Samba__
+ Datein die über den Share gerade von anderen bearbeitet werden, werden gelockt, so dass nicht meherere
  User gleichzeitig die gleiche Datei editieren können

Oplock Typen:
Exclusive: --> Zugriff auf Datei
	   --> lokale Modifikation beim Host
	   --> Änderungen werden erst geschrieben wenn der Host die Datei schließt

BATCH: --> wie Exclusive
       --> Eine Applikation kann eine Datei mehrfach hintereinadenr öffnen und schließen ohne den Lock zu lösen

Level2 --> Zugriff auf Datei
       --> Modifikation im Cache des Servers

Direktiven:
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#Oplock akitvieren
#Exclusive und Batch oplocks beachten
oplocks = Yes|No [global]

#Cachen von Datein auf dem Client anstelle eines oplocks verweden
veto oplock files = FILELIST [Share]

#Falls das Dateisystem Readonly ist oder Kernel Leasures nicht unterstützt werden
fake oplocks = No|Yes [Share]

#oplock Anfragen werden vom Kernel bearbeitet
kernel oplocks = Yes|No [Share]

#Soll Smaba nach Level 2 Oplocks cachen, falls möglich
level 2 oplocks = Yes|No [Share]
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

__Extended Attributes in Samba__
+ DOS EAS lassen sich auf Unix EAS mappen 
+ falls das Filesystem Unix EAS unerstützt und samba mit HAVE_SYS_XATTR_H gebaut wurde können DOS EAS in 
  Verzeichnisse geschriben werden

Direktiven:
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#Werden DOS EAs in Linux Directories gemappt
store dos attribute = Yes|No [Share]
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

__Berechtigungen verwalten in Samba__
Direktiven:
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#Festlegen eines oder mehrerer Nutzer die auf den Share zugreifen dürfen
valid users = User1 User2 [Share]

#Festlegen des Primären Nutzeraccounts auf dem Server für den Nutzer der sch zu diesem Share verbindet
Force User = Unix Name [Share]

#Angeben einer Menge von Berechtigungen für Dateien, Verzeichnisse auf Unix Ebene
#Standard ist 0744 
#AND
#Alle Bits die nicht gesetzt sind, werden aus den Windows Dateirechten entfernt
create mask = 7777 [Share]
create directroy mask = 7777 [Share]

#Angeben einer Menge von Datei-Verzeichnis Berechtigugnen
#Standard ist 0755
#OR 
force create mode = 777 [Share]
force directory mode = 777 [Share]

#Samba vererebt den Besitzer vom Elternverzeichnis
inherit owner = Yes|No [Share]

#Samba vererbt die Berechtigungen von Elternverzeichnis
#Setuid wird nie vererbt
inherit permissions = Yes|No [Share]
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

__Samba und ACLs__
+ --with-acl-support zur Kompilezeit benötigt
+ kann Possix ACLs mappen wenn diese beim mounten als Option mit angegeben wurden

**smbd -b|grep HAVE_ACL** -->erfragen ob samba mit acl support kompilliert wurde

Direktiven:
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#Sollen Unix Berechtigungen auf die Windwos Full Control ACLs gemappt werden
acl map full = Yes|No [Share]

#Ein Verzeichnis vererbt seine Standard ACLs an alle Unterverzeichnisse
inherit acls = No|Yes [Share]

#Soll smbd ACL Unterstützund an NT-Clients weitergegeben werden
nt acl support = Yes|No [Share]
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

__Virtual Filesysteme in Samba__
+ smbd Daemon interakiert mit einem VFS-Modul
+ Standard enthält: + Trash bin
		    + Logging Module um Nutzerzugriffe zu protokollieren

+Jedes Modul bietet eine Konfiguration der Form an:
module_name:option
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#Beispiel Konfiguration:
[hermes]
	read only = Yes
	vfs object = recycle
	recycle:reposittory = .trash
	recycle:keeptree = Yes
	recycle:exclude = *.tmp, *~, *.lock
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

__Serverseitige Scripte ausführen__
Direktiven
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#Vor der Verbindung ausführen
preexec = /Pad/zum/Script [global]

#Nach dem Abbau der Verbindugn ausführen
postexec = /Pfad/zum/Script [global]

#Vor der Verbindung als root asuführen
root preexec = /Pfad/zum/Script

#Nach dem Abbau der Verbindung als root asuführen
root postexec = /Pfad/zum/Script

__Kennwort Server einrichten__
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
security = server

#Wo befindet sich der Server
password server = 192.168.128.42
ppasword server = Keymaster
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!! Der Server darf nicht auf sich selbst als Server verweisen. Endlosschleife!!!

+ Auf dem Keynmaster muss eine entsprechende Passwort Datenbank abgelegt sein

__Samba und Winbind__
+ Abbilden von NT Domännen SIDs auf Linux UIDs und GIDs (Benutzer brauchen keine lokale UID GID)
+ Einmal vorgenommene Zuordung wird in einer lokalen Datenbank gespeichert
+ Namesnauflösung über NSS
+ Authentifizierung der Benutzer über PAM

Winbind Konfiguration:
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#Verwende UIDs aus diesem Bereich für das mapping der UIDs
idmap uid = 10000 - 19999

#Verwende GIDs aus diesem Breich für das mapping der GIDs
idmap gid = 10000 - 19999

#Erlaube das Aufzählen aller Gruppen und Nutzer in der Domäne
winbind enum users = yes
winbund enum groups = yes

#Angabe des Heimatverzeichnisses für den Winbind Daemon
template homedir = /home/%D/%U

#Die Shell die für das ausführen von Programmen genutzt wird
template shell = /bin/sh

#Trennzeichen für die Domainhierarchie
#Beispiel <Domäne>@<Benutzer>
winbind seperator = @

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

**service winbind start**, **/etc/init.d/winbind start**  --> Starten des Winbind Daemon

**wbinfo -u** --> Auflisten der Nutzer einer Domäne

**wbinfo -g** --> Auflisten der Gruppen einer Domäne

__Samba und LDAP__
+ Verwalten von großen Nutzerbeständen
+ Hinzufügen beliebig vieler Nutzerinformationen
+ benötigte Module: nss_ldap, pam_ldap ermöglichen es dass Samba Werkzeuge auf den Server zugreifen können
+ installieren der smbldap-tools http://samba.idealx.org/dist

(1) Konfigurieren des OpenLDAP Servers
   + hinzufügen des samba3.schema in die slapd.conf und Konfigurieren
    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    include 	/etc/openldap/schema/core.schema
    include 	/etc/openldap/schema/cosine.schema
    include 	/etc/openldap/schema/inetorgperson.schema
    include 	/etc/openldap/schema/nis.schema
    include 	/etc/openldap/schemas/samba3.schema

    pidfile 	/var/run/slapd/slapd.pid
    argsfile	/var/run/slapd/slapd.args
    
    access to dn.base=""
			by self write
			by * auth
   
    access to attr=userPassword
			by self write
			by * auth

    access to attr=shadowLastChange
			by self write
			by * read

    access to *
			by * read
			by anonymous auth
    
    schemacheck 	on
    idletimeout		30
    backend		bdb
    
    database		bdb
    checkpoint		1024 5
    cachesize		10000
    suffix		dc="example,dc=com"
    rootdn		cn=Admin,dc=example,dc=com
    rootpw		geheim
    
    index		objectClass		eq
    index		cn			press,sub,eq
    index		sn			press,sub,eq
    index		uid			press,submeq
    index 		displayName		press,sub,eq
    index		uidNumber		eq
    index		gidNumber		eq
    index		memberUID		eq
    index		sambaSID		eq
    index		sambaPirmaryGroupSID 	eq
    index		sambaDomainName		eq
    index		default			sub		
    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

(2) Anpassen der \\ /etc/samba/smb.conf \\
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
[global]
	netbios name = DONTPANIC
	workgroup    = Adams
	os level     = 34
	domain logons = Yes
	local master  = Yes
	domain master = Yes
	prefered master = Yes
	time server     = Yes
        logon drive 	= Z:
	logon script 	= logon.sh
        logon path 	= \\%L\profiles\%U

#Einstellungen für den LDAP Verzeichnisdienst
	#LDAP Adgesse zur  Passwortdatenpank
	passdb backend	= ldapsam:ldap://dontpanic.example.com
	idmap  backend	= ldap:ldap://dontpanic.com
	idmap uid	= 10000 - 19999
	idmap gid	= 10000 - 19999
	#LDAP Suchpfade
	ldap suffix 	= dc=example,dc=com
	ldap admin dn	= cn=Manager,dc=example,dc=com
	ldap amchine suffix = ou=People
	ldap user suffix    = ou=People
	ldap groups suffix  = ou=Groups
	ldap idmap suffix   = ou=Idmap
	ldap delete dn 	    = Yes

#Diese Direktiven benötigten ldaptools installiert
add machine script		= <Pfad>/smbldap-useradd -w '%u'
add user script	   		= <Pfad>/smbldap-useradd -m '%u'
delete user script		= <Pfad>/smbldap-userdel -m '%u'
add group script		= <Pfad>/smbldap-groupadd -p '%g'
delete group script		= <Pfad>/smbldap-groupdel '%g'
set primary group script	= <Pfad>/smbldap-usermod -g '%g' '%u'
add user to group script	= <Pfad>/smbldap-groupmod -m '%u' '%g'
delete user from group script 	= <Pfad>/smbldap-groupmod -x '%u' '%g'
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

(3) Kennwort für den LDAP Server Administrator setzen
**smbpasswd -w <Passphrase>**

(4) Starten des Samba Servers um SID zu erfahren
**service nmb start && service smb start && net getlocalsid >> SID.lokal && service smb stop**

(5) Anpassen des Scriptes smbldap-tools **perl configure.pl** bei $$Debina$$ \\ /usr/share/doc/smbldap-tools/configure.pl.gz \\ 
>> ldap suffix [] > dc=example, dc=com
>> ldap group suffix [] > Groups
>> ldap user suffix [] > People
>> ldap machine suffix [] > People
>> ldap master server [] > DONTPANIC.example.com
>> ldap master bin dn [] > dc=Admin,dc=example,dc=com
>> ldad master password [] > secret

(6) Starten des Ldap und Initialisieren des LDAP Verzeichnisdienstes
**rcldap start**, **service ldap start**, **/etc/init.d/slapd start**
**<Pfad>/smbldap-populate -a root -k 0 -m 0** (k 0 und m 0 entsprechenden der UID und GID des Users root)
**rcldap restart**, **service ldap restart**, **/etc/init.d/slapd restart**

(7) Konfigurieren der NSS-Plugin \\ /etc/ldap.conf \\
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#Konfiguration von libnss_ldap.so
host 127.0.0.1 
base dc=example,dc=com
binddn cn=Admin,dc=example,dc=com
bindpw secret

pam_password	exop
#Angabe des Pfades im LDAP Suchbaum für die entsprechenden Dateien
nss_base_passoword	ou=People,dc=example,dc=com?one
nss_base_shadow		ou=People,dc=example,dc=com?one
nss_base_group		ou=Groups,dc=example,dc=com?one

ssl	off|on
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

(8) Einträge in der \\ /etc/nsswitch.conf \\ anpassen
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
passwd:	files	ldap
shadow:	files	ldap
group:	files	ldap
hosts:	files	dns	wins

#passwd_compat ...
#group_compat ...
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

(9) Einen Benutzer anlegen
**smbldap-useradd -m -a -c "Arthur Dent" arthur
**smbldap-passwd arthur**

(10) EIne Gruppe hinzufügen
**smbldap-groupadd -a humans**

(11) Abschließen der Konfiguration durch Neustarteen des Samba Servers
**rcsmb start**
**service winbind start**
**net rpc join -S DONTPANIC -U root%admin**
**service winbind restart**

__Drucker Share mit Samaba einrichten__
+ zur Zentralen Verwaltung von Druckerresourcen in einem Windows Netzwerk
+ für linux: sollte mit --enable-cups kompilliert worden sein

**smbclient //SERVER/DRUCKER -c print papier.txt** --> drucken der Sambafreigabe

**smbpool** --> Programm um Druckerfreigaben und Druckerwarteschlangen einzurcihten

**ldd $(which smbd) |grep cups** --> überprüft ob Samba mit cups reden kann


+++++++++++++++++++++++++++++++++++
[print-q]
	print ok = Yes
+++++++++++++++++++++++++++++++++++
--> aktivieren eines Druckers
--> Dieser ist unter //Server/print-q ansprechbar

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#Name des Druckers angeben
in dem Fall verweise die Variable %p auf den Namen
printer name = DruckerName [printer]

#festlegen der Druckerqueue auf dem Server
path = /var/spool/cups

#spezifizierung des zu benzutzenmden Drucksystems
#benutzen sie sysv wenn eigene Drucker Commandos definiert werden sollen
printing = cups | sysv|bsd|lprng [global]

#Alle Printer als Freigabe anzeigen 
load printers = Yes [global]

#Den Befehl festlegen über den der Drucker auf dem Server angesprochen werden soll
#Dies ist meistens ein lpr Befehl der vollständig mit Pfad angegeben werden muss
print command = PATH/Command [printer]

#Den Befehl für das Verwalten und auflisten der Printerqueue
lpq command = PATH/Command [printer]

#Den Befehl festlegen der für das löschen von Aufträgen aus der Druckerqueue
lprm command = PATH/Command [printer]

#Den Befehl für das anhalten der Druckerwarteschlange festlegen
queue pause command = PATH/Command [printer]

#Den Befehel für das fortsetzen der Druckerwarteschlange festlegen
queue resume command = PATH/Command [printer]

#Den Befehl für das Hinzufügen eines Druckers
#falls Samba einen AddPrinter oder SetPrinter Request erhält
add printer command = PathCommand [gloabel] [printer]

#Den Befehl für das Entfernen eines Druckers
delette printer command = PATH/Command [global]  [printer]

#Durch Kommata getrennte Optionen für Cups, die beim Drucken eines Dokuments angewendet werden sollen
cusp options = None [global]

#Name und IP-Adresse des Durckers
#falls name verwendet wird muss dieser auflösbar sein 
cups server = IP/name [global]

#Sollen Einträge für Drucker in jeder in der \\ /etc/printcap \\ definierten Drucker erzeigt werden
load printers = No|Yes

#Maxmimale Anzahl erlaubter Drucker Jobs in der Queue
max print jobs = INT  [printer]

#Platz der frei sein muss, damit Samba neue Druckaufträge entgegennimmt
min print space = INT(KB) [printer]

#Datei die Liste über valide Drucker enthält
printcap name = Datei|Compile [global]
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

!!!Ein gemeinsamer Pdf-Drucker für Samba!!!
(1) Erzeigen der entsprechenden Section in der \\ /etc/samba/smb.conf \\
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
[pdfgen]
	print ok = Yes
	printing = cups
	comment = Pdf Generator
	path = /var/spool/samba
	print command = /usr/local/bin/pdfgen.sh
	lpq command = /bin/true
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
(2) Erstellen des Scriptes für /usr/local/bin/pdfgen.sh
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#!/bin/sh
USER=$(whoami)
ZEIT=$(date +%Y'-'%m'-'%d'-'%H'.'%M)

ps2pdf13 $1 $ZEIT.pdf
rm -f $1
mv $ZEIT.pdf /samba/transfer/pdf/
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

__Samba als Domain Controler__
+ Eine Domäne ist eine Gruppe von Rechnern, die eine gemeinsame Quelle für Informationen und Benutzerauthentifizierung haben.
                                                                                                                        (PDC)
+ Alle Rechner einer Domäne gelten als Mitglieder dieser Domäne.
+ Security Account Manager verwaltet die Informationen zentral als Teil der Registry

Primary Domain Controler:
+ ein PDC (Primary Domain Controler) verwaltet eine Domäne und alle Computer die zu einer Domäne zusmmanefasst wurden
+ Freigaben und Berechtigungen werden zentral verwaltet


+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#Minmalvorraussetzungen für einen PDC
[global]
	security = user
	encrypt password = Yes

#PDC Funktionalität einschalten
	domain master = Yes
#Konfigurieren als Logon Server
	domain logons = Yes
#NetBIOS Name of WORKGROUP setzen
	netbios name = WORKGROUP

#Share für den Netlogon einrichten
[netlogon]
	comment = Net Logon Service
	path = /var/lib/netlogon
	writelist = +ntadmin
	guest ok = Yes
	writeabel = No
	browseable = No
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Domain-Joins einrichten:
+ beim Domain Beitritt wird ein Passwort benutzt, dass nur der Client und der PDC kennen
                |
		|
		V
	machine Trusted account Password
		|
		|
		v
	Identifikation des Computers vei der Verbindung zum Domaincontroler

--> Samba nutzt das SeMachineAccountPrivelege um Nutzer / Gruppen eines Computers einer Domain beizutreten


Workflow einrichten eines Domain Joins:
(1) Erstellen einer Gruppe Domain Admins zum Verwalten der Benutzerrechte

(2) Erstellen von Nutzern mit dem Recht der Domain beizutreten

(3) Implemntieren der Infrastruktur, die notwendig 
	SID = Security ID 
	RID = relative Identifier

(3.1) Abfragen der SID mittles **net getlocalsid ORA**

(3.2) Domain Admin RID zur SID hinzufügen mittles **net groupdmad add=S_<SID> ntgroup="Domain Admins" unixgroup="ntadmin"

(4) Zuweisen des Rechts einer Gruppe und anschließend zuweusung der entsprechenden Nutzer

(5) Erstellebn der Gruppe Serveradmins , die dann auf dei Gruppe ntgroup gemappt wird
    **net groupmap add unixgroup=srvadmin ntgroup="Server Admins"

(6) Zuweisen des Privilegs auf den Server ORA der Gruppe "Server Admins" mittels
    **net rpc rights grant 'ORA\Server Admins' SeMachineAccountPrivelege -S stork -U cindy

Direktiven:
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#Wlches Script|Programme wird aufgerufen um weitere Nutzer und Gruppen hinzuzufügen
add machine script = /usr/sbin/useradd -g hosts -s /bin/false '%u'

#Welches Programm|Script wird aufgerufen um weitere Gruppen hinzuzufügen
add group script = /PATH/BIN <Options>...<ARGUMENTS>

#Welches Programm|Script wird aufgerufen um weitere Nutzer hinzuzufügen
add user script = /PATH/BIN <Options>...<ARGUMENTS>
add user script = /usr/sbin/useradd -s /bin/false '%u'

#Welches Programm|Script wird aufgerufen um weitere Nutzer einer Gruppe hinzuzufügen
add user to group script = /PATH/BIN <Options>...<ARGUMENTS>

#Welches Programm|Script wird aufgerufen eine Gruppe zu löschen
delete group script = /PATH/BIN <Options>..<ARGUMENTS>

#Welches Programm|Script wird aufgerufen einen Nutzer aus einer Grupper zu entfernen
delete user from script = /PATH/BIN/ <Options>...<ARGUMENTS>

#Welches Programm|Script wird aufgerufen um einen Nutzer umzubenenen
rename user script = /PATH/BIN <Options>...<ARGUMENTS>

#Welches Programm|Script wird für das Setzend er primären Gruppe verwendet
set primary group script = /PATH/BIN <Options>...<ARGUMENTS>

#Das Heimtverzeichnis festlegen
logon home = \\%L\\%u

#Laufwerksbuchstaben, die ein Client der sich am PDC anmelden will zu sehen bekommt
logon drive = P:

#Der UNC Pfad zum Heimatverzeichnis des Users
login home = \\%N\%U

#Der UNC Pfad  zum Nutzerprofil des Users
#
logon path = \\%N\%U\profile

#DOS Script relativ zum Batchfile dass beim Logon ausgeführt werden soll
logon script = UNC
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Backup Domain Controler:
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
[global]
	domain master = No
	domain logons = Yes
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
--> BDC muss <0x1c> Registrieren

__Spezielle Share Namen__
print$ --> Drucker Treiber

C$ --> C: Laufwerk des Servers

IPC$ --> Remote IPC für Netzwerkgenerierung gebraucht, kein wirklicher Share

ADMIN$ --> Remote Administrator

 


===Sicherheit===
**aide** **tripwire** --> autiding programme

**lynis** **chkrootkit** **rkhunter** --> Sicherheitskritische Programme und Einstellungen aufspüren

__sudo__
+ einzelnen Benutzern erlauben, gezielt Programme als root auszuführen

**sudo <Befehl> -u <User>** --> ein Befehl mit superuser Privilegien ausführen
		  --> nach Eingabe des Passwortes des Nutzers (nicht roots Passwort) wird <Befehl mit UID 0 ausgeführt
		  --> die Datei \\ /etc/sudoers \\ bestimmt was ein benutzer der sudo verwendet darf und was nicht
		  --> einmal authentifiziert halten die dem Nutzer zugeteilt UID 0 Pirvilegien eine gewisse Zeit vor
		  --> wird vom syslog Daemon protokolliert

**sudo -k** --> zurücksetzen des Passwortes so dass die Verwendung eines priviligierten Programms wieder nachfragt

**sudo -e <Datei> --> Die Datei als Nutzer editieren
		  --> legt eine Kopie der Datei und erlaubt das editiren

**sudo -l** --> auflisten der entsprehchenden Regeln für den entsprechenden Nutzer  

**sudo -s** --> Shell aufrufen

**sudo -u <User> <Befehl> --> <Befehl> als <User> ausführen

**visudo** --> editiren der Datei \\ /etc/sudoers \\ in dem vi oder in der mit VISUAL festgelegten Editor

**sudoedit** --> editor der für die Bearbeitung der Dateien von Dateien mit de sudo Kommando eingesetzt werden sollte

\\ /etc/sudoers \\
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#Aliasse
#<UserAlias> 
Shutdowners = horst maria tux 

#<HostAlias>
Switches = redPill bluePill

#<Befehls[Alias]
Down = /sbin/shutdown -h now, halt

#Regeln
#<User[Alias]> <Host[Alias]>([als <User]) [NOPASSWD:] <Pfad zum Programm innkl. Optionen und Parameter durch , getrennt> 
Shutdowners	Switches			Down
tux		redPill				/sbin/shutdwon -r 10
Shutdowners	ALL(ALL)			/usr/bin/less /var/log/failsshutdown

#Gruppen definieren
%group		ALL(Shutdowners)		/sbin/reboot
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
<User[Alias]>
	--> eine Liste von User definiert durch #UID, %group, User
  		
<Host[Alias]> 
	--> Rechnernamen in \\ /etc/hosts \\
	--> IP-Adressden
	--> Netzmasken in CIDR Notation

===PAM==
+ Pluggable Authentication Modules
+ Shared libraries die mit den das Authentifizierungverhalten gesteuert werden kann
+ On the fly Authentifzierungsmeachanismen
+ ermöglicht hardwaregestütztes Authentifizieren
+ ermöglicht Programmen sich zu authentifizieren
+ pam Funktionalität muss zur Kompilierzeit vom Programm unterstützt und mit entsprechenden Optionen kompilliert sein
+ Programme kommuniziern über die PAM-API

\\ /etc/pam.conf \\, \\ /etc/pam.d \\ --> Konfigurationdateien für PAM
				      --> falls \\ /etc/pam.d \\ exisitiert wird \\ /etc/pam.conf \\ ignoriert
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#PAM Regel sind Ketten der Form
#<service> <Typ> <Control> <Modulpfad> <Modulargumente>
#Der Stapel wird oben nach unten gelesen
#beim benutzen von \\ /etc/pam.d \\ fällt die Spalte <service weg
#und wird dann durch den Namen der Datei repräsentiert

#<service>
#Name der Applikation (zum Beispiel login oder su)

#<Typ> 
#Gruppe zu der die Regel korrespondiert
#	accont	--> Non-Account basiertes Managament
		--> benutzt um Services anhand von Tageszeiten oder verfügbaren Systemresourcen zuzulassen
	
	auth 	--> verifizieren des Nutzes durch Passwort oder andere Authentifizierungsmechanismen
		--> gewähren von Gruppenpmitgliedschaft oder Gruppenprivilegien von Applikationen
	
	password --> benötigt um Authentifikationsmerkmal mit einem Nuzer zu altualisieren
	
	session --> assoziert mit Dingen die vor oder nachdem ausgeführt werden sollen bevor die Kontrolle
		    an den Nutzer abgegeben wird

#<Control>
#Verhalten falls ein Service bei der Authentifizierung fehlschlägt
#	required --> ein Fehler dieses PAM wird ein Fehler an die PAM-API senden
		 --> andere Module im Stacks werden noch abgearbeitet

	requisite --> wie requiered
		  --> schlägt ein Modul fehl wird die Kontrolle sofort an die Anwendung zurückgegeben
	
	sufficient --> Erfolg dieses Modul reicht aus um den Nutzer zu authentifizieren
		   --> falls der Erfolg eines vorherigen required Moduls im Stack fehlgeschlagen ist, wird dieses
		       Modul ignoriert
		   --> Ein Misserfolg dieses Moduls wird nicht als notwendiges Kriterim angesehen einen Fehler
		       an die PAM-API zu senden
		   --> falls dieses Modul Erfolg meldet, werden anderen Module im Stapen nicht mehr abegarbeiet
	
	optional   --> Erfolg oder Fehler dieses Modul ist  nur wichtig, falls es das einzige im Stack ist

	include --> beziehe die Konfigurationsdatei eines bestimmten Typs mit ein
	
	ignore	--> wird irgnoriert und nimmt nicht Teil am Modul Stack
	
	bad --> wird Fehler an das Modul geliefert und ist das Modul der erste wird dieser Status an alle
		anderen Module weitergereicht
	
	die --> wie bad, allerdings wird der Modul Stack sofort beendet und der Wert an die Appliaktion zurückgegeben
	
	good --> gegenteil von bad
	
	done --> gegenteil von die
	
	N   --> springe zu Modul N
	
	reset --> den Modul Stack resetten

#<Modulpfad>
#Absoluter Pfad zur PAM Library Modul
#Relativer Pfad zu einem PAM unter \\ /lib/security \\
	 		
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++		


\\ /lib(64)/security \\ --> Module für PAM
                        --> dynamische Shared Libaries Object Dateien


===Linux Kernel===

__Aufgaben des Kernel__
+ Steuerung der Hardware
+ Speicher - und Prozessverwaltung
+ Zugriff auf Dateien (Hardwareebene)

__Versionen des Kernel__
A.x.n
2.6.18
A=Major
x=Minor
n=Patchlevel

\\ /boot/vmlinuz \\ --> komprimiertes Image des Betriebsystemkerns

\\ /proc/config.gz \\ --> die aktuelle Kernelkonfiguration des laufenenden Kernels

__Komprimmierungsverfahren__
+ immer in gzip komprimiert

zImage --> Zip Image

bzImage --> Big Zip Image


Ungerade Minor Versionen sind unstable (Ungeeigent für Produktiveinsatz)
Gerade Versionsnmmern refernzieren auf Stabile Versioenn

!! Adressse für Quellen und Patches: www.kernel.org!!
!! eine experimentelle Version gewartet und gepflegt.!!

\\ /usr/src/linux \\ --> wenn installiert ist dies ein Link der auf die Kernelquellen des aktuellen Kernels verweisen

\\ /usr/src/linux/Documentation \\ --> Die Documentation zum aktuellen Linux Kernel
				   --> Informationen über die benötigten Bibliotheken und Compiler zum Neubau 

\\ /usr/src/linux/.config \\ --> die Konfiguration die bei **make config** erzeugt wird

\\ /usr/src/linux/Makefile \\ --> das dazugehörige Makefile
			      --> Anpassungen des Releasenamens können hier vorgenommen werden


__Kernel kompilliren__

Make Targets:
<help> --> kurze Zusammenfassung aller verfügbaren Targets

<all> --> alle Ziele die beim Aufruf vom Target <help> mit einem * gekennzeichnet sind

<mrproper> --> löscht alle Obejctdateien und die Konfigurationsdateien, auch .config

<clean> --> löscht alle Objectdateien in allen Verzeichnissen

<distclean> --> <mrproper> + patches und Editor Notes

<config> --> erzeugen der notwendigen Kernel-Konfigurationsdatei interaktiv
		<y>|<n>|<m> --> wird kompilliert|nicht kompilliert|als modul kompilliert

<oldconfig> --> eine alte bestehende Konfiguration übernehmen
	    --> nur neu Implimentierte Module werden interativ abgefragt

<menuconfig>, <nconfig> --> erzeugen der notwendigen Kernel-konfiguration menubasiert 
				(setzt devel Pakete von ncurses vorraus)

<xconfig> --> erzeugen der notwendigen Kernel-konfiguration menubasiert 
		(setzt devel Pakete von qt3 und X-Server vorraus)

<cloneconfig> --> erzeugen der notwendigen Kernel-konfiguration aus einer vorhandenen in \\ /proc/config.gz \\

<prepare-all> --> testen der aktuellen Konfiguration und testen der Module

<dep> --> nur Kernel 2.4, aufspüren von Abhängigkeiten 

<modules_prepare> -->  Setup für externe Module vorberreiten

<modules> --> bauen der Module

<modules_install> --> installieren der Module unter \\ /lib/modules/$(uname -r) \\
		  --> erzeugen der Datei \\ /lib/modules/$(uname -r)/modules.dep \\  

<Image> --> ein unkomprimierts Kernel Image erzeugen

<bzImage> --> ein gzip kompirimiertes Kernel Image für big Modus erzeugen

<zImage> --> ein gzip kompirmiertes Kernel Imageg

<zdisk> --> Disketten Image erzeugen

<deb>, <kpkg>  --> ein Debian Paket erzeugen

<rpm> --> ein rpm Paket erzeugen

<binrpm> --> ein rpm Paket erzeugen, nur binär Paket

<install> --> installieren des Kernels und aller zugehörigen Module

__Kernel Patchen__
**diff -Nru <dirA> <dirB> > dir_A_B.patch > patch.log** --> erstellen eines Patches, der wenn angwendet die 
								Änderungen von dir_B auf dir_A schreibt
							--> erstellen eines Logfiles patch.log

	
**patch -d <dirA> -p 1 < dir_A_B.patch** --> anwenden des Patches auf <dirA>

**patch -R -d <dirA> -p 1 < dir_A_B.patch** --> macht den patch dir_A_B.patch rückgängig

**patch** --> Anwenden von Patches auf Dateien und Verzeichnisse
-b --> ein backup der Dateien erstellen bevor der Patch angewendet wird
-d <DIR> --> Angabe eines Zeilverzeichnis 
-p N --> Angabe des Patchlevels, dabei meint 0 /usr/src/linux, 1 src/linux  
-R --> reverse Patch, rückgängigmachen eines Patches

!!! Eine Fehlermeldung ohne Patchvorgang lässt auf ein falsches Patchlevel schließen !!!


__Initiale Ramdisk (initrd)__
+ enthält ein gültiges LinuxDateisystem in denen 
	+Treiber \\ ~/initfs/lib \\
	+Scripte  \\ ~/iniitfs/bin \\ \\ ~/initfs/linuxrc \\
	+Gerätedateien \\ ~/initfs/dev \\
	die zum booten des Kernels benötigt werden geladen werden können

+ kann mit cpio ausgepackt werden
+ muss vom Kernel unterstüzt werden

TRICK: Nachschauen was in der Initialen Ramdisk steckt
**cp /boot/initrd ~/initfs/initrd.gz**
**gunzip initfs/initrd.gz**
**zcat /initfs/initrd.gz|cpio -id**

**mkinitrd** --> Shellscript zum erstellen einer Initialen Ramdisk
-k </boot/vmlinuz> --> Angeben eines Linuxkernels
-i </boot/myinitrd> --> Angeben der Datei für die Initiale Ramdisk

__Erstellen einer Startdiskette__
Workflow 2.4:
**dd if=/boot/vmlinuz of=/dev/fd0** --> kopiert das Kernelimage bitweise auf die Diskette
**rdev /dev/fd0 /dev/sda2** --> setzen des Root Gerätes auf /dev/sda2 für den in /dev/fd0 befindlichen Kernel

Workflow 2.6:
1) Kopieren des Kernels und er initialen Ramdisk
**mount /dev/fd0 /media/fd0**
**cp /boot/vmlinuz /boot/initrd  /media/fd0**

2) Schreiben des Bootloaders **syslinux /dev/fd0**

3) Anpassen der syslinux.cfg
	Anpassen der Datei syslinux.cfg 
	++++++++++++++++++++++++++++++
	default linux
	label linux
	kenrel vmlinuz
	append initrd=initrd root=/dev/sda2 acpi=off
	timeout 80
	+++++++++++++++++++++++++++++++


__Kernel bauen__
Workflow:
1) untar **tar xvf linux-2.6.m.tar.bz2 -C /usr/src**


2) cd in Verzeichnis **cd /usr/src/linux-2.6.m**

3) lesen der Documentation und überprüfen ob die notwendigen Tools vorhanden sind 
	\\ /usr/src/linux-2.6.m/Documentation/Changes \\ ~~Current Minimal Requirements~~

4) Anpassen der Eigentümerberechtigungen, so dass der Bau des Kernels als normaler Nutzer erfolgen kann 
	**chown -R user:group /usr/src/linux-2.6.m**	

5) Anpassen des Kernelrelease durch editieren des Makefile

5 1) kann auch durch nachträgliches Editieren der .config erfolgen
     hierzu muss man die Option CONFIG_LOCALVERSION=<version> anpassen

6 1) Testen der Kernelpatches vom Verezeichnis \\ /usr/src/linux-2.6.m \\
     **bunzip2 -c /pfad/zu/patch.bz2 | patch -p1 --dry-run**
     **gunzip -c /pfad/zu/patch.gz | patch -p1 --dry-run**

6 2) Einspielen von Kernelpatches \\ /usr/src/linux-2.6.m
    **bunzip2 -c /pfad/zu/patch.bz2 | patch -p1**
    **gunzip -c /pfad/zu/patch.gz | patch -p1**
 

6 3) \\ /usr/src/linux-2.6.m/scripts/patch-kernel \\ --> Script zum anpassen von Kernelpatches
	-h --> für Hilfe 

6 4) Einspielen ungepackter Patches 
     **patch -d <kernel_src_dir> -p 1 < <patches>**

7) Aufräumen der Kernelquellen
	**make mrproper**


8) erstellen eines Build-Verzeichnisses
	**mkdir ~/build_kernel**

9 1)  Klonen der aktuellen Kernelkonfiguration falls eine \\ /proc/config.gz \\ exisitiert

	**cd ~/build_kernel**
	**zcat /proc/config.gz > .config**	

9 2) Klonen der aktuellen Kernelkonfiguration falls keine \\ /proc/config.gz \\ aber \\ /boot/config-<version> \\
	** cd ~/build_kernel**
	** cat /boot/config-<version> > .config**

10 1) Erstellen der neuen Konfiguration aus der geklonten Variante
	**make O=~/build_Kernel** oldconfig

10 2) Erstellen einer Standardkonfiguration 
	**make O=~/build_kernel defconfig**

10 3) Erstellen einer Konfiguratione die alle möglichen Module enthält
	**make O=~/buiild_kernel allmodconfig**

10 4) Erstellen einer minimalen Konfiguration
	**make O=~/build_kernel allnoconfig**

10 5) Erstellen einer zufällig ausgewählen Konfiguration
	**make O=~/build_kernel randconfig**

11 1) Anpassen der Kernel Konfiguration mit Menu
	**make O=~/build_kernel/ menuconfig** --> ncurses basiertes Menu
	**make O=~/build_kernel/ xconfig** --> qt3 qt3 basiertes Menu
	**make O=~/build_kernel/ gconfig** --> gtk2 basiertes Menu

11 2) Anpassen der Kernel Konfiguration nach Abfrage (fragt jedes einzelne Modul zur Konfiguration ab)
	**make O=~/build_kernel config**

12) Vorbereiten der zu verwendenden Module
	**make O=~/build_kernel  modules_prepare**


13 1) bauen des Kernels im BuildVerzeichnis
	**make all**

13 2) bauen eines Rpm Paketes
	**make rpm-pkg** --> erstellt ein rpm Paket inklusive src.rpm

	**make binrpm-pkg** --> erstellt nur das binäre rpm Paket  


14) Die Module installieren, falls kein Kernel Paketiert wird 
	**make modules_install**

15) kopieren des Kernels
	**cp ~/build_kernel/arch/i386/boot/bzImage /boot/vmlinuz-2.6.n-arch**


16) kopieren der Kernel Systemmap
	**cp ~/build_kernel/System.map /boot/System.map-2.6.n-arch**
	

17) erstellen der Initial Ramdisk
	**mkinitrd -k vmlinuz-2.6.n-arch -i initrd.img-2.6.n-arch**  --> $$SUSE$$
	**mkinitramfs -k <Version> -o initrd.img-<Version>** --> $$Debian$$

18) Anpassen von Grub /boot/grub/menu.lst

19) erstellen der Datei \\ /lib/modules/<kernelversion>/modules.dep \\ mittels **depmod**

__Module im Kernel__
Module (durch m gekennzeichnet) sind modular zur Laufzeit 
+ mittles **insmod** oder **modprobe** ladbare Programmteile.
+ können mit **rmmod** entladen werden
+ **lsmod** listet die aktuell geladenen Module
+ mit **modinfo** kann man sich detailiierte Informationen zu einem Kernel anzeigen lassen

\\ /lib/modules/<Version>/modules.dep \\ --> listet die Abhängigkeiten aller Module 

\\ /etc/depmod.conf \\ --> Konfigurierren der Module 

\\ /etc/depmod.d/


\\ /etc/modprobe.d\\  --> Konfigurationstool für Ladbare Module zur Laufzeit

**depmod** --> erzeugen und auflisten der \\ /lib/modules/<Version>/modules.dep \\
-A | --quick --> scannen nach neueren Modulen als die in modules.dep
-C --> überschreibt \\ /ect/depmod.conf \\
--dryrun --> testlauf
-q --> unterdrücken von Fehlermeldungen

__Kernelparameter zur Laufzeit anpassen__
+ \\ /proc/sys \\ verwaltet Kernel Parameter
+ \\ /sys \\ verwaltet einige systemspezifische Einstellungen

**cat /proc/sys/<Blob>** --> Den Kernel Parameter als /proc/sys/<Blob> auslesen
			 --> 0 ist aus und 1 ist Kernel Parameter ist aktiviert

**sysctl <Blob>** --> den Blob Kernel Parameter auslesen dabei wird zum Beispiel /proc/sys/net/ipv4/forwarding zu
		      net.ipv4.forwarding

-w <Blob>=Wert --> den Kernel Paramter <Blob> mit <Wert> versehen

-a --> Auflisten aller Blobs die momentan vorhanden sind

\\ /etc/sysctl.conf \\ --> Dauerhaftes Schreiben der Kernel Parameter Blobs
++++++++++++++++++++++++++++++++
net.ipv4.forwarding = 1

__ACPI mittels /sys konfigurieren__
\\ /sys/power/state \\  --> konfigurieren der ACPI Einstellungen

**echo disk > /sys/power/state** --> Suspend to disk

**echo mem > /sys/power/state** --> Suspend to ram

__Software aus dem Quelltext installieren__

Workflow:
1) herunteraden und dekomprimieren des Sourcecode Archivs
	**tar xvfz source.tar.gz** falls tar.gz

1.2)  	**tar xvjf source.tar.bz2** falls tar.bz2

2) In den Ordner wechseln und  configure ausführen
	**./configure --prefix=/usr/local**

3) Software bauen und installieren
	**make && make install** 


===LVM===
**vg|lv|pv-display** --> Anzeigen von Informationen

Physical Volume (100G 50G 200G)

**pvcreate <Gerät>** --> Das Volume (Platte|Partition) als LVM verwendtbar labeln
-u --> uuid anstelle des Gerätes verwenden
-y --> Ja zu allem ohne Nachfrage
-f --> erzwinegen, sollte nie verwendet bzw. gebraucht werden

**pvremove <Gerät>** --> Das Volume (Platte|Partition) als LVM verwendtbar entfernen
		     --> entfernt das Label

Volumegroup (350G)

**vgcreate [Name] <Gerät1>,.. <GeräteN>** --> eine Volumegruppe mit den Geräten die zuvor mit **pvcreate markiert wurden
					      hinzufügen

-f --> force
-y --> ja zu allem ohne Nachfrage

**vgremove <Name>** Die Volumegruppe entfernen

**vgreduce <Volumegroup> <Physical Volume>** --> entfernen des physikalischen Volumes aus der Volumengroup
-a --> alle Unbebutzen PVs

**vgextend <Volumegroup> <Physical Volume>** --> hinzufpgen eines neuen Gerätes zu eine VolumeGroup

Logical Volume (20G 20G 20G 20G ...)

**lvcreate -n <Name> -L <Größe> <Volume Group>** --> ein logisches Volume der <Größe auf Volumegroup <VG> erstellen

**lvextend -L +|- <Größe> /dev/mappen/<Geräts>** --> ein logisches Volume erweitern

**vgchange** --> Attribute für eine Volumengruppe ändern
-av ativiere
-an deaktiviere

**pvmove** --> Verschieben des Dateninhalts von einem phyiskalischen Gerät in die Volumegruppe

__Erweitern der Volumegruppe__
1) pvcreate /dev/sdd
2) vgextend system /dev/sddd
3) lvextend -L +500M /dev/mapper/system-bak
4) resize2fs /dev/mapper/system-bak

__Reduzieren eines logischen Volumes__
1) e2fsck -p /dev/mapper/system-bak
2) resize2fs /dev/mapper/system-bak 700M
3) pvmove /dev/sdd
4) lvreduce -L 700M /dev/mapper/system-bak
5) vgreduce system /dev/sdd
6) pvremove /dev/sdd

__Snapshot__
+ Erstellen einen Snapshot zu einem bestimmten Zeitpunkt
+ Dieses kann dann eingehängt und gesichert werden

**lvcreate -n <Name> -L <Größe> --snapshot <LGVolume>


===RAID===
__Raid-Level__
0 (Striping) + 2-N Platten | 1:1 Größe | 0 Fehler Toleranz
	     + paralleler Schreib|-Lesezugriff
	     + Erhöhung des Datendurchsatzes

1 (Mirroing) + 2-N Platten|1:N Größe| N-1 Fehler Toleranz
             + auf den Platen wird gleichzeitig die gleiche Datei gechrieben
	     + Redundanz von Daten

4 (Block-level Stripping mit dedizierter Parität)
	     + 3 Platten| 1-1:N Größe| 1 Disk Toleeranz
             + eine Platte mit Paritätsinformationen
             + Erhöhung des Datendurchsatz

5 (Block-level Stripping mit dedizierter Parität)
	     + 3 Platten | 1-1:N Größe | 1 Disk Fehler Toleranz
	     + die Pariritätsinformationen wird über mehrere Platten verteilt
	     + Erhöhung des Datendurchsatze bei Mirroing

6 (Block-Level mit doppelt vertielter Parität)
	    + 4 Platten | 1-2:N Größe | 2 Disk Fehler Toleranz
	    + die Paritätsinformatioen wird über mehrere Platten redundant abgelegt
	    + maximale Datenredundanz

**mdadm** --> Tool zum Verwalten, erstellen von Softwareraids

Sparedisks --> Zusatzplatte die beim Ausfall sofort einspringt

\\ /proc/mdstat \\ --> Informationen über Raid

\\ /etc/raidtab \\ --> Konfiguration der Raidtools 

**mdadm --create /dev/md0 --level=<raid-level> --raid-devices=<# der RaidGeräte> <Device1>...[missing]**
--> erstellen eines Raids 
--> wird missing vrerwendet werden alle verfügbaren Platten für das Raid verwendet, überflüssige werden als
    Spare verwendet

**mdadm /dev/md0 -f <Device>** --> markiert eine Platte als Fehlerhaft (faulty)

**mdadm /dev/md0 -r <Gerät>** --> softwareseitiges entfernen einer als Fehlerhaft gekennzeichneten Platte

**raidhotadd** | **raidhotremove** --> Befehle für Hardwareseitiges raid korespond **mdadm -a|-r**

__Fehlerhafte Festplatte ersetzen__
1) Disk als Fehlerhaft markeiern **mdadm -f /dev/sdb**

2) Einen dump der Partitiontabelle erstenen **dd if=/dev/sdb of=partitions.sdb count=1 bs=446** 
					    **sfdisk -d /dev/sdb >partitions.sdb

3) Softwareseitiges entfernen **mdadm -r /dev/md0 /dev/sdb

4) Herausnahnme der Platte nun möglich

5) neue Dislk einbauen

6) Disk hinzufügen Softwareseitig **mdadm -a /dev/sdb

7) Den dump zurückspielen **sfdisk /dev/sdb < partitions.sdb**
			  **dd if=partitions.sdb of=/dev/sdb bs=446 count=1

__hdparm__
+setzen und abfragen von Parametern von Festplatten Parametern von Festplatten

**hdparm <Gerät>** --> Statistiken der Festplatte überprüfen 
-C --> status u der Platte überprüfen
-c 0 --> disable 32 bit I/O Unterstzung
   1 --> enable 32 bit I/O Unterstützung
   2 --> enbale 32 bit I/O Unterstützung mit sync

-d 0 --> DMA disable
   1 --> DMA enable

-f --> synchronisiernen und reinges des bufferCaches

-g --> Geometrie (heads, cylinder, sectors)

**badblocks >Geräte>** --> nach defekten Blöcken suchen

**sync** --> Den Buffer der Platten synchronisieren

===Udev===
+ Der **udevd** lauscht auf \\ /sys \\ nach neuen Geräten
+ Gleichzeitig werden \\ /etc/udev/rules.d \\ gelesen
+ Es werden Empfhelungen an den Kernel gegeben wie Geräte unter \\ /dev \\ verwaltet werden soll

sysfs: + Pseudodateisystem im Kernel 2.6.x
       + exportieren von Informationen über Hardware
       + management vom Kernel

\\ /etc/udev/udev.conf \\ --> globale Kinfigurationen 
                          --> Konfiguration von loggin und Informationen über loglevel

\\ /dev/disk/ 
		by-uuid \\ --> Geräte nach uuid 
		by-id \\     --> Geräte nach Id
		by-label \\  --> Geräte nach Lbel
		by-patN \\ --> Geräte nach PattN

--> Persisitenen Naming Geräte für udev

\\ /etc/udev/rules.d/ \\ --> Verzeichnis für Dateien für udev-Regeln

\\ /etc/udev/rules.d/persistent-net.rules \\ -->  weist MAC neue Gerätedatei zu

___Eine Regel definieren__
+ Erstellen eine Regel unter \\ /etc/udev/rules.d/99-myrule
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
<Regel>=[=]"Wert", <Regel2>=[=]"Wert",
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
= --> Zuweisungsoperator a=B
==|!= --> Vergleichsoperator a==B Matching

!! Jede Regel muss mindestens einen Matchkey und ienen Assignemntkey haben !!

__Matchkeys__
ACTION --> Event action

KERNEL --> Kernel Name des Gerätes

NAME --> Name des Geräteknotens

SYMLINK --> Name des symbolischen Links

DRIVER --> Name des Treibers

ATTRS{filename} --> sysfs Attribute Werte

ENV{key} ..> Eigentümer Werte

TAG --> device Tag

__AssignmentKeys__
NAME --> Regel, wie eine Gerät benannt werden sol
     --> überschreibt die Knerledefinition
     --> kann verwendet werden, um zum Beispiel dem USB-Geräte eine eindeutige Nummer zuzuweisen

SYMLINK --> zuweisung eines symbolischen Links
        --> wie Name
        -->+= kann zusätzlichenr Symlink zugewiesen werden

ATTR{key} --> Wert der sysfs zugewiesen wird

TAG --> Einem Gerät ein Taf zuweisen

RUN --> Ein Programm ausführen
    --> voller Pfad zum Befehl | Script
    --> += mehere Programme gleichzeitig zuweisen| nahcheinaner ausführen

__String Matching__
%k --> Kernelname

%n --> Kernelnumber

%Variableninitialisierung

* --> matcht eine oder mehrere Zeichen

[abcdef] --> matcht eines der Zeichen in der Klammer

? --> matcht ein Zeichen genau einmal


**udevadm** --> Administrationstool für udev

**udevadm monitor** --> warten auf Udev Uvents und ausgabe auf Standardausgabe, ersetzt **udevmonitor**

**udevadm info --query=all --name=<Gerät> --attribute-walk** --> zeigt an welche Regeln für <Gerät> vergeben werden können

==Autofs==
+ mounted das Dateisystem automatisch beim betreten des Verzeichnisses

\\ /etc/auto.master \\ --> beschreibt die MountPunkte
		       --> Jede Zeile enthält genau eine Datei und zeigt auf eine weitere Optionen fürs Mounten
                           enthält
                       --> die 3. Spalte erlaubt spezielle Optionen die in **mount(5)** beschrieben sind
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#</Pfad>	<Konfigurationsdatei> 	<Optionen>

/home	ldap	10.1.7.7 ou=home ou=autofs dc=foo dc=bar

/misc	/etc/misc.auto	--timeout 60 #nach 60 minuten automatisch wieder asuhängen wenn nciht eingehängt
        #verweis auf /etc/aut.misc 

/mnt	yp:/mnt.map

#Freigabe für NFS
Slarty	DONTPANIC.example.com:/home/Erde/
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\\ /etc/<Konfigurationsdatie>.auto
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#zum beispiel misc.auto

</Subpfad>	<Optionen>	:<Gerät>
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Die Verzeichnisse werden </Pfad>/<Subpfad> von autofs automatisch beim Betreten erzeugt und das Gerät dort eingehängt
!!nach Ändern muss die Konfoigurationsdatei neugeladen werden:
**service autofs reload**
**/etc/init.d/autofs reload**
**killall -1 autofs**

===DNS==
\\ /etc/hosts \\ 
++++++++++++++++++++++++++++++++++++++++++
IPAdresse	Hostadresse
+++++++++++++++++++++++++++++++++++++++++
--> lokale Namensauflösung
--> FQDN nd Nmen des Rechneres auf 127.0.0.1

\\ /etc/host.conf \\
+++++++++++++++++++++++++++++++++++++++++
order bind, host

#Mehrere IpAdressen pro Host
multi on

#Checke IPAdreseen Spoofing
nospoof on
+++++++++++++++++++++++++++++++++++++++++
--> Reihenfolge des Lookups festlegen
--> verschiedene Lookup Optionen ffestlegen

\\ /etc/nsswitch.conf \\
++++++++++++++++++++++++++++++++++++++++++
hosts: 	dns files
network dns files
++++++++++++++++++++++++++++++++++++++++++
--> festlegen der Reihenfolge in der Dienste abgefragt werden

\\ /etc/resolv.conf \\
+++++++++++++++++++++++++++++++++++++++++++
search <Domain>
nameserver <Master-IP>
nameserver <Slave-IP>
nameserver <Gateway>

#round robin
Options rotate
+++++++++++++++++++++++++++++++++++++++++
--> wie werden IP-Adrssen aufgelöst
--> Konfiguration des Resolvers Clientseitig

\\ /etc/named.conf \\ --> Konfigurieren des bind named Daemons für die Namensauflösung zuständig ist

\\ /etc/bind/db.root \\ --> Root-Hints-Datei
			--> Verweis auf die Root-Zonen-Server

\\ /etc/named.local \\ --> zur Auflösung der Loopbackadresse

\\ /var/lib/named/192.168.128.zone \\ --> Zonendatei für die reverse Auflösung

\\ /var/lib/named/site.zone \\ --> Zonendatei für die forward Auflösung

__Zone__
+ Teil des Namensraumes einer Domain über die ein Namensserver Autorität hat (authoritive Zone)
+ rfc 1033

__Master__
+ authoritive für alle Informationen einer bestimmten Zpne
+ läd Domaininformatioen aus Zonefiles

__Slave__
+ übertragen der Informationen vom Master Server
+ Zonenndateien werden vom Master geholt

__Caching Only|StubZone__
+ führt die Namenesserver Software aus
+ Zonendefinitionen werden nicht vorgehalten
+ lernt Anfragen vom entfernten Server und legt diese im Cache ab
+ Stubzone verweisen nur auf den nächsten Master|Slave

__Konfigurationsdatei \\ /etc/named.conf (bind 9)__
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\\ Caching Only:
options {
	directory "/var/named"; //Verzeichnis für den Cache
	forwarders {172.16.12.1; 172.16.12.2}; //falls Server Antwort nicht weiß, verweis auf Forwarders
};

zone "." {
	type hint;
	file "db.root"; \\definieren der hints Datei für root zonen server
};

zone "0.0.127.in-addr-arpa" {
	type master;
	file "named.local"; \\für die loakale Namensauflösung
};

\\Master
options {
	directory "var/named"; \\Verzeichnis für Cache und Zonendateien
}

zone "." {
	type hint;
	file "db.root";
};

zone "Marvin.com" {
	type master;
	file "Marvin.zone";
};

zone "16.172.in-addr.arpa" {
	type master;
	file "Marvin.zone";
};

\\Slave

options {
	directory "/var/named";
}

zone "." {
	type hint;
	file "db.root";
};

zone "0.0.127.in-addr.arpa" {
	type master;
	file "named.local";
};

zone "Marvin.com" {
	type slave;
	file "Marvin.hosts";
	masters {172.16.12.1; };
};

zone "16.172.in-addr.arpa" {
	type slave;
	file "192.168.128.zone"
	masters {172.16.12.1 };
};
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

__Konfiguration der Zoenendatei__

Records:
SOA --> Start of Authority
    --> definiert Anfang der Daten einer Zonen
    --> Parameter die die gesamte Zone betreffen

NS --> Name Server
   --> Bestimme die Nameserver einer Domain

A --> Adress
  --> konvertiert Hostnamen in Adresse

PTR --> Pointer
    --> konvertiert Adresse in Hostnamen

MX --> Mail Exchange
   --> bestimme Mail für HostDomain
   --> Namen Zuständigkeit

TXT --> Text
    -_> abspeichern beliebiger Textstrings

$TTL --> Standard Time To Live
     --> gültigkeitsdauer im Cahce

$INCLUDE --> hinzufügen weiterrer Verweise

Reverse-Zonendatei:
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
$TTL 1W
@	IN 	SOA 	linux.01.site.		root.linux01.site. (
		101214	;serial
		2D	;refresh
		4H	;retry
		6w	;expiry
		1W	;minimum)

	IN 	NS	linux01.site.
1	IN	PTR	localhost.
69	IN	PTR	linux01.site.
70	IN	PTR	linux02.site.
71	IN	PTR	linux03.site.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Forward-Zonendatei:
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
$TTL 1W
@	IN	SOA	linux01.site.	root.linux01.site. (
		101214	;serial
		2D	;refresh
		4H	;retry
		6W	;expiry
		1W	;minimum)

	IN 	NS	linux01.site.
	IN	A	127.0.0.1
linux01	IN	A	192.168.128.69
slave	IN	NS	192.168.128.70
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

__Verwalten des BIND__
**rndc** --> Verwwaltund des Namensserver diesestes \\ /etc/init.d/named \\
status --> Stausmeldungen
dumpdb	--> schreiben des Cache in named_dump-dn
reload --> lädt den Nameserver neu, liest die Konfigurations neu ein
stats --> schreibt Statistiken in die named.stats
trace --> Aktiviert tracing nach \\ named.run \\
notrace --> deaktiviert tracinv
querylog --> Protokollierung des syslogd ausschalten
start --> starten des named
stop --> anhalten des named
restart --> stop;start


**nslokup** --> Tool zum Debuggen von DNS Lookups
            --> bietet interkativen und nichtinteraktiven Modus

**dig** --> testen der Namensauflösung
        --> Debuggen von DNS
	--> Syntax mit der der Zonefiles Äquivalent

**dig [@<Nameserver>] <Adresse> <Record> --> lookup über entsprechenden Nameserver nach bestimmten Record durchführen
					 --> wird @Nameserver weggelassen weden die Namen im Resolver (/etc/resolv.conf)
					     gefragt
-4|-6 --> IPv4|6 

**host** --> Resolver Infomatioen ausgeben

**host <Adresse|IP|in.addr.arp>**

**hostname** --> Informationen über die loklae Namensauflösung erhalten
-d --> DNS Domain Name
-f --> FQDN
-i --> IP-Adresse

__DNS Sicherheit__
+ Bind Versionsnummer verstecken \\ /etc/named.conf \\
++++++++++++++++++++++++++++++++++++++++++++
options {
	version "hidden";
};
++++++++++++++++++++++++++++++++++++++++++++

+ ACL Implementieren \\ /etc/named.conf \\
+++++++++++++++++++++++++++++++++++++++++++
acl "trusted" {
	localhost;
	192.168.1.0/24
};

+ Queries einschränken, welcher Hist darf den Server fragen
+++++++++++++++++++++++++++++++++++++++++++
options {
	allow-query {192.168.1.0/24  };
};
++++++++++++++++++++++++++++++++++++++++++

+ Zonen Transfer für Slave einschränken
++++++++++++++++++++++++++++++++++++++++++
options {
	allow-transfer {192.168.1.0/24 };
};
+++++++++++++++++++++++++++++++++++++++++

Master-Sicherheit:
+ limitiere dide Liste der Zonendatieen auf Slave Servers
++++++++++++++++++++++++++++++++++++++++++
acl "my_slave_servers" {
	24.123.240.3;
};

zone "example.com" {
	type master;
	allow-transfer {  
			my_slave_servers;...	};

};
++++++++++++++++++++++++++++++++++++++++++++
Slave-Sicherheit:
+ keine weiteren Transfers außer den Master zulassen
+++++++++++++++++++++++++++++++++++++++++++++
zone "example.com" {
	type slave;
	allow-transfer {
		none;
		};
};

zone "128.168.in-addr.arpa" {
	type slave;
	allow-transfer {
		none;
		};
};
++++++++++++++++++++++++++++++++++++++++++++++
+ glue-fetching ausschalten in BIND 8 (nicht notwendig in Bind 9)
++++++++++++++++++++++++++++++++++++++++++++++
options {
	fetch-glue no;
};
+++++++++++++++++++++++++++++++++++++++++++++

+Bind mit geringeren Privilegie:
	1) erstellen einen spezielen Benutzer named und einen Gruppe named
	2) start den Server **named -u named -g named**
			   **start-stop-daemon --exec /usr/sbin/bamed -- -u named -g named

+ Bind in chroot Jail booten lassen
	+ \\ /var/cache/bind als / für named behandeln
	+ kann den rest des Dateisystems nicht finden
	+ \\ /etc, /dev /lib/ /sbin /usr/sbin, /var/run \\ müssen Teil des chroots sein
	+ \\ /dev/null \\ wird im Jail benötigt **mknod -m 666 /var/cache/bind/dev/null c 1 3**
	+ Password und Gruppendatei werden benötigt **cp -p /etc/{passwd, group, shadow} /var/cache/bind/etc/**
	+ ld.so.cache wird benötig **cp -p /etc/ld.so.cache /var/lib/bind/etc/ && cp -p /etc/localtime /var/lib/bind/etc/**
	+ Das neue lib verzeichnis muss alle libs enthalten die named benötigt **ldd /usr/sbin/named**
									       **cp ^^^ /var/lib/bind/lib/**
	+ Die Konfigurationsdatie muss im Chroot Jail /etc/ vorhanden sein
	+ namedn und named-xfer müssn im chroot Jail vorhanden sein
	+** named -t /var/cache/bind**
	 **start-stop-daemon --exec /usr/sbin/named -- -t /var/cache/bin/
	+ Logging muss geändert werden da der syslogdaemon nicht im Chroot Jail läuft
		++++++++++++++++++++++++++++++++++++++++++++++++++++++
		logging {
				channel some-log {
				file "bind.log";
				severity info;
			}
			categoryM default {same-log;};
		};
		+++++++++++++++++++++++++++++++++++++++++++++++++++++++

+ Name Server Verbindunden absichern
**dnssec** generiert + public und private Schlüssel für die Authentifierzierung von Zonendatiene
-a RSA|DSA|HMAC-MD5
-b --> Schlüsselgröße
-n --> Zone| Host|ENTITY|USER|OTHER


###!!! nstat!!!!####
###!!!ifstat!!!####
###!!!ss!!!!####
###rpm -ql nmap|grep services|xargs less###
###\\ /etc/protocols \\###
###/var/log/wtmp /var/run/utmp and the last command###
###wie ist die datei /etc/printcap beschaffen###
###whois###
###finger###
##netcat##
###wodim -v dev=/dev/sr0 speed=4 filename.iso###
###shopt --> Shell Optionen setzen und anzeigen
